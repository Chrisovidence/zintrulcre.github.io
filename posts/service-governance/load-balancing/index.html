<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Zhengyu Chen">
    <meta name="description" content="ZintrulCre @ 尾張">
    <meta name="keywords" content="ZintrulCre, 尾張">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="负载均衡和一致性哈希"/>
<meta name="twitter:description" content="负载均衡和一致性哈希 [TOC] 反向代理 reverse proxy 是指以代理服务器来接收由客户端发送来的请求，并通过一定的策略将其转变发给实际处理请求的后端服务器；主要应用"/>

    <meta property="og:title" content="负载均衡和一致性哈希" />
<meta property="og:description" content="负载均衡和一致性哈希 [TOC] 反向代理 reverse proxy 是指以代理服务器来接收由客户端发送来的请求，并通过一定的策略将其转变发给实际处理请求的后端服务器；主要应用" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zintrulcre.vip/posts/service-governance/load-balancing/" />
<meta property="article:published_time" content="2020-10-25T23:06:52+08:00" />
<meta property="article:modified_time" content="2020-10-25T23:06:52+08:00" />


    
      <base href="https://zintrulcre.vip/posts/service-governance/load-balancing/">
    
    <title>
  负载均衡和一致性哈希 · 尾張
</title>

    
      <link rel="canonical" href="https://zintrulcre.vip/posts/service-governance/load-balancing/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="https://zintrulcre.vip/css/coder.min.28d751104f30c16da1aa1bb04015cbe662cacfe0d1b01af4f2240ad58580069c.css" integrity="sha256-KNdREE8wwW2hqhuwQBXL5mLKz&#43;DRsBr08iQK1YWABpw=" crossorigin="anonymous" media="screen" />
    

    

    

    

    <link rel="icon" type="image/png" href="https://zintrulcre.vip/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://zintrulcre.vip/images/favicon-16x16.png" sizes="16x16">

    <meta name="generator" content="Hugo 0.76.5" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://zintrulcre.vip">
      尾張
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://zintrulcre.vip/posts/">Posts</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://zintrulcre.vip/about/">About</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">负载均衡和一致性哈希</h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fas fa-calendar"></i>
              <time datetime='2020-10-25T23:06:52&#43;08:00'>
                October 25, 2020
              </time>
            </span>
            
          </div>
          <div class="categories">
  <i class="fas fa-folder"></i>
    <a href="https://zintrulcre.vip/categories/consistent-hashing/">consistent hashing</a></div>

          
        </div>
      </header>

      <div>
        <h1 id="负载均衡和一致性哈希">负载均衡和一致性哈希</h1>
<p>[TOC]</p>
<p>反向代理 reverse proxy 是指以代理服务器来接收由客户端发送来的请求，并通过一定的策略将其转变发给实际处理请求的后端服务器；主要应用于负载均衡、动态缓存、安全认证、内网穿透、SSL 加密等；而负载均衡 load balancing 是指在多个 slot（槽，一般是某种计算资源）中分配负载，以优化资源利用率和避免单点故障问题的方法，是高可用性分布式系统的必备中间件；常用的开源 load balancer 有 nginx，LVS，Haproxy 等；负载均衡可以视为反向代理的一种应用，负载均衡的方法大致可以分为传统负载均衡算法和哈希算法两种，本文简单地总结了这些算法的原理。</p>
<p><img src="https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/reverse-proxy/reverse-proxy.png" alt="reveser-proxy"></p>
<h2 id="1-传统负载均衡算法">1 传统负载均衡算法</h2>
<ol>
<li>随机 random：将 key 随机分配到某一个 slot 上，根据概率论可知，吞吐量越大，随机算法的效果越好；</li>
<li>加权随机 weighted random：为每一个 slot 分配一个权重，在随机的时候考虑权重的影响；可以通过在所有 slot 的权重总和中随机出一个数字 k，找到 k 所在的 slot 位置来实现；</li>
<li>轮询 round robin：按顺序依次将 key 分配给每一个 slot；</li>
<li>加权轮询 weighted round robin：为每一个 slot 分配一个权重，在按序分配时为权重更高的 slot 分配更多的 key；</li>
<li>平滑加权轮询 smooth weighted round robin：一种能够均匀地分散调度序列的加权轮询方法，分为以下几个步骤：
<ol>
<li>选出当前权重最高的 slot，将 key 分配给它；</li>
<li>将选出的 slot 的权重数值减去其初始权重；</li>
<li>将所有 slot 的权重数值都加上它们的原始权重；</li>
<li>重复以上步骤；</li>
</ol>
</li>
<li>最少连接数 least connections：将 key 分配给当前具有最少连接数量的 slot；</li>
</ol>
<h2 id="2-mod-n-哈希">2 Mod-N 哈希</h2>
<p>在有些场景下，传统负载均衡算法无法满足我们的需求，例如：</p>
<ol>
<li>当我们需要充分利用到 slot 的缓存，在任何时候都希望将同一个 key 映射到固定的 slot 上，而不是让其被任意地分配到一个负载较低的 slot 上；</li>
<li>当我们希望把数据分配到一些具有键值存储功能（可以是 memcache, redis, mysql 等）的 slot 上进行有状态服务，而又不使用一个全局的数据库；</li>
</ol>
<p>对于以上两个问题，我们可以先使用哈希函数（如 md5, sha1 等，需要保证哈希后的分布平均）将 key 映射为一个 <code>uint32</code> 的值（key 本身可能是一个字符串或其他值），再用该值对 N（slot 的数量）进行取模运算来映射出一个值， 即 <code>value = hash(key) mod n</code>，这种方法可以称为 Mod-N 哈希；这里做了两次哈希，第一次是对 key 做映射，第二次是进行取模运算。</p>
<p>一般来说好的哈希函数应该满足一些条件：</p>
<ol>
<li>从哈希值不可反向推导出 key；</li>
<li>发生哈希冲突的概率尽可能小；</li>
<li>效率高；</li>
</ol>
<h3 id="哈希冲突碰撞-hash-collision">哈希冲突/碰撞 Hash Collision</h3>
<p>当我们把较大的值空间映射到较小的值空间时，冲突是不可避免的；如果两个 key 通过哈希方法被映射为了同一个值，那么就称为发生了 <a href="https://en.wikipedia.org/wiki/Hash_table#Collision_resolution">hash collision</a>，一般来说其解决方案有：</p>
<h4 id="1-单链表法-separate-chaining">(1) 单链表法 separate chaining</h4>
<p>也称作 open hashing；对于每一个通过哈希方法映射出的值，我们将其作为一个 bucket；当有 key 被映射到 bucket 上时，如果 bucket 为空，则为其新分配一个链表节点，否则遍历这个链表，在这个链表的尾部为其分配新的链表节点；</p>
<p><img src="https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/consistent-hashing/separate-chaining.png" alt="separate-chaining"></p>
<h4 id="2-开放寻址法-open-addressing">(2) 开放寻址法 open addressing</h4>
<p>也称作 closed hashing；主要思路是通过搜索哈希表中的其他空的 slot（探测序列 probe sequence）来进行 key 的插入，进行查找时应该采用与插入时相同的线性探测规则；获取 probe sequence 的方法一般有：</p>
<ol>
<li>
<p>线性探测 linear probing：查找哈希表中离冲突位置最近的空的 slot，即 <code>value = (hash(key) + k) mod n, k = 1, 2, 3, 4...</code></p>
<p><img src="https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/consistent-hashing/open-addressing.png" alt="open-addressing"></p>
</li>
<li>
<p>二次探测 quadratic probing：对哈希结果添加一个二次多项式直到找到一个空的 slot，即 <code>value = (hash(key) + k^2) mod n, k^2 = 1, 4, 9, 16...</code></p>
</li>
<li>
<p>双重哈希 double hashing：借助另一个哈希函数 hash' 的结果，作为偏移量获取值，即 <code>value = hash'(key) mod n</code>；</p>
</li>
</ol>
<h2 id="3-一致性哈希-consistent-hashing">3 一致性哈希 Consistent Hashing</h2>
<p>在数据量较大的场景下，假设我们因为某些原因需要将原本的 n 个 slot 扩容为 m 个 slot，如果仍然使用 Mod-N 哈希，将会有 n/m 份缓存不能正确命中，从而产生大量的数据库请求，可能导致<a href="https://alibaba-cloud.medium.com/struggling-with-poor-responsiveness-unlock-the-power-of-caching-b3186f2b3cd0">缓存雪崩</a>。</p>
<p>对于传统的哈希映射，添加或者删除一个 slot，会造成哈希表的全量重新映射；而**<a href="https://dl.acm.org/doi/10.1145/258533.258660">一致性哈希</a>**的目的是达成增量式的重新映射，即当 slot 的数量发生变化时，降低重新映射的数量，尽量最小化重新映射（minimum disruption）。</p>
<p>一致性哈希算法的设计关键有 4 点：</p>
<ol>
<li>平衡性 balance：所有的 key 能被均匀地映射到各个 slot 上；</li>
<li>单调性 monotonicity：增加新的 slot 后，原有的 key 应该被映射到原有的 slot，或新的 slot 上，而不是其他旧的 slot ；</li>
<li>分散 spread：服务扩容或者缩容时，尽量减少数据的迁移；</li>
<li>负载 load：尽量降低 slot 的负载；</li>
</ol>
<h3 id="31-ketama">3.1 Ketama</h3>
<p><a href="https://www.metabrew.com/article/libketama-consistent-hashing-algo-memcached-clients#:~:text=Ketama%20is%20an%20implementation%20of,complete%20remap%20of%20all%20keys.">ketama</a> 算法是最常用的一种一致性哈希算法，也叫做哈希环法（hash ring）， 被广泛的应用在数据库，缓存系统和服务框架上，包括但不限于 memcache, redis, dubbo, nginx 等，其步骤是：</p>
<ol>
<li>对于一个 [0, uint32] 的区间，将其首尾相连，形成顺时针的环；</li>
<li>对 slot 进行哈希，映射到 [0, uint32] 区间上，并将结果标记到环上；</li>
<li>对 key 进行哈希，映射到区间上，沿着环顺时针寻找并将其分配到距其最近的 slot；</li>
</ol>
<p>举个例子，假设现在有 N0, N1, N2 三个 slot 以及 a, b, c 三个 key，其中 a 会被分配 N1 上，b 和 c 都会被分配到 N2 上；</p>
<p><img src="https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/consistent-hashing/hash-ring-add-1.png" alt="hash-ring-add-1"></p>
<p>现在我们<strong>新增</strong>一个 N3 slot，并将其映射到 [a, N1] 之间，那么 a 和<strong>所有在 [N0, N3] 之间的 key 都会被重新分配到 N3 这个 slot 上，除此之外的其他所有 key 则不会被重新映射</strong>；</p>
<p><img src="https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/consistent-hashing/hash-ring-add-2.png" alt="hash-ring-add-2"></p>
<p>假设我们<strong>移除</strong> N2 slot，那么<strong>所有在 [N1, N2] 之间的 key 都会被重新映射到 N0 上，除此之外的其他所有 key 则不会被重新映射</strong>。</p>
<p>可以发现，ketama 算法达成了在新增或移除 slot 后的<strong>增量式重新映射</strong>（minimum disruption），不会破坏大多数 key 的映射关系；因为要构造出一个环来存储所有 slot 的 key 被映射到的位置，所以其空间复杂度是 O(n)；为了方便地进行查找，可以将环转换成一个有序数组，在其中进行二分查找，时间复杂度是 O(logn)。</p>
<h4 id="虚拟节点">虚拟节点</h4>
<p>有时候我们可能会对不同的节点赋予不同的权重，也就导致了每个节点的地位不平等，从而不能直接将节点放在环上，解决方案是使用不同数量的虚拟节点（virtual node）来代表实际的节点，一般来说每个虚拟节点代表一个单位节点，虚拟节点数量之和等于实际节点的权重；即使不同节点之间的权重相同，也建议将一个实际节点映射为多个虚拟节点，因为节点越多，它们在环上的分布就越均匀，因此使用虚拟节点还可以降低节点之间的负载差异；假设 N0, N1, N2 三个节点具有相同的权重，那么用虚拟节点代替之后则大致如图：</p>
<p><img src="https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/consistent-hashing/virtual-slot.png" alt="virtual-slot"></p>
<h3 id="32-jump-consistent-hashing">3.2 Jump Consistent Hashing</h3>
<p><a href="https://arxiv.org/abs/1406.2294">Jump Consistent Hashing</a> 跳跃一致性哈希是 Google 发表的一个非常简洁的一致性哈希算法，其主要思路是：</p>
<ol>
<li>假设有 n 个 slot 和 k 个 key，所有的 k 个 key 都被均匀地映射到了这 n 个 slot 上；</li>
<li>现在增加 1 个 slot，为了将原有的 k 个 key 均匀地映射到 n + 1 个 slot 上，需要将其中 k / n + 1 个 key 进行重新映射，即每次增加 1 个 slot 都需要重新映射 k / n + 1 个 key；</li>
<li>使用**<a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator">伪随机</a>**的方式（给定一个随机种子，生成一个固定的随机序列）来决定哪 k / n 个 key 需要被重新映射；</li>
</ol>
<p>这里使用伪随机的含义是，对于每一个 key，我们使用这个 key 来作为随机种子，生成一个固定的随机序列 seq，于是 seq 在其下标为 [1, n] 的区间里的值都是固定的；接下来遍历 seq，在每一次迭代 i 中，如果 seq[i] &lt; 1/i，则将其重新分配到第 i 个 slot 上，否则保持不变；整个过程在给定 key 时就已经确定了。</p>
<p><img src="https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/consistent-hashing/jump-consistent-hashing-0.png" alt="jump-consistent-hashing-0"></p>
<p>这样一来就达成了一致性哈希的平衡性和单调性，没有使用额外的内存，所以空间复杂度是 O(1)；而因为遍历了 n 个 slot，所以时间复杂度是 O(n)，还可以从时间复杂度的角度继续优化；在 seq[i] &lt; 1 / i 这个公式中（即被重新分配这个假设成立），1 / i 会随着 i 的增大而变得越来越小，而 seq[i] 是随机数，因此可以认为公式成立的概率会越来越小，所以我们可以让 i 的步进增大，来减少迭代的次数。</p>
<p>假设当前 key 所在的 slot 是 b，迭代次数是 b + 1 ，下一次迭代某一个 key 会被重新映射的概率是 1 / b + 2（上面思路第 2 点），即其不会被重新分配到新 slot 的概率为 b + 1 / b + 2，再下一次的概率是 b + 2 / b + 3，直到第 j 次的概率是 j - 1 / j，将这些概率相乘得到在这 j - b 次之间 key 不会被重新分配的概率是 b + 1 / j；假设把 seq[i] 用 r = random.next() 来表示，要使得 r &lt; (b + 1) / j（即被重新分配这个假设成立），就必须有 j &lt; (b + 1) / r，那么 key 在步进大于等于 (b + 1) / r 次后一定会被重新分配。</p>
<p><img src="https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/consistent-hashing/jump-consistent-hashing-1.png" alt="jump-consistent-hashing-1"></p>
<p>这样一来时间复杂度就减少到了 O(ln(n))；但其局限性也很明显，因为只能通过步进的方式来重新映射和分配 slot，导致其只能在尾部增删 slot，否则在中间进行增删的话会导致其后续的 slot 下标和步进关系都发生变化，</p>
<p>论文中还对比了其与哈希环法的运行时间。</p>
<p><img src="https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/consistent-hashing/karger.png" alt="karger"></p>
<h3 id="33-maglev-hashing">3.3 Maglev Hashing</h3>
<p><a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/44824.pdf">Maglev</a> 是 Google 研发的一个负载均衡组件，使用了其自研的一致性哈希算法 Maglev Hashing，其主要思路是通过维护两个 table 来将 key 映射到 slot 上；一个表是 lookup table 查找表，用于将 key 映射到 slot 上；另一个表是 permutation table 排列表，用于记录一个 slot 在 lookup table 中的位置序列：</p>
<p><img src="https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/consistent-hashing/maglev-table.png" alt="maglev-table"></p>
<p>对于 n 个 slot 和一个长度为 m 的映射序列（即 permutation table 和 lookup table 的长度），我们希望为每一个下标为 i 的 slot 都计算出一个数量为 m 的排列，计算时需要使用两个<strong>不同的哈希函数</strong> h1 和 h2，来计算 offset 和 skip 两个值（这里需要保证每一个 slot 的 name 都不相同）：</p>
<p><img src="https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/consistent-hashing/permutation.png" alt="permutation"></p>
<p>举个例子，假设 n = 3，m = 7，对于下标为 0 的 slot，通过某两个哈希函数计算出来的 offset = 3，skip = 4，为其生成一个长度 m = 7 的 permutation：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">permutation[i][0] = (3 + 0 * 4) mod 7 = 3
permutation[i][1] = (3 + 1 * 4) mod 7 = 0
permutation[i][2] = (3 + 2 * 4) mod 7 = 4
permutation[i][3] = (3 + 3 * 4) mod 7 = 1
permutation[i][4] = (3 + 4 * 4) mod 7 = 5
permutation[i][5] = (3 + 5 * 4) mod 7 = 2
permutation[i][6] = (3 + 6 * 4) mod 7 = 6
</code></pre></div><p>再加上另外两个计算好 permutation 的下标为 1 和 2 的 slot，对应的 permutation table：</p>
<table>
<thead>
<tr>
<th>m</th>
<th>s0</th>
<th>s1</th>
<th>s2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>3</td>
<td>0</td>
<td>3</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>4</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>6</td>
<td>6</td>
</tr>
<tr>
<td>4</td>
<td>5</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>6</td>
<td>6</td>
<td>5</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>现在我们让 3 个 slot 轮流地从其 permutation 中，按顺序选择第一个没有被分配的 key，来填充到之后的 lookup table 中，流程是：</p>
<ol>
<li>s0 的 permutation 中的第一个数字 3 没有被分配，选择 3；</li>
<li>s1 的 permutation 中的第一个数字 0 没有被分配，选择 0；</li>
<li>s2 的 permutation 中的第一个数字 3 已经被分配了，往后遍历到数字 4，选择 4；</li>
<li>s0 在 permutation 中往后遍历，0 和 4 都已经被分配了，选择 1；</li>
<li>s1 在 permutation 中往后遍历，选择 2；</li>
<li>s2 在 permutation 中往后遍历，4 已经被分配了，选择 5；</li>
<li>s0 在 permutation 中往后遍历直到选择 6；</li>
</ol>
<p>于是就有了 lookup table：</p>
<table>
<thead>
<tr>
<th>m</th>
<th>slot</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>s1</td>
</tr>
<tr>
<td>1</td>
<td>s0</td>
</tr>
<tr>
<td>2</td>
<td>s1</td>
</tr>
<tr>
<td>3</td>
<td>s0</td>
</tr>
<tr>
<td>4</td>
<td>s2</td>
</tr>
<tr>
<td>5</td>
<td>s2</td>
</tr>
<tr>
<td>6</td>
<td>s0</td>
</tr>
</tbody>
</table>
<p>这种方法类似于开放寻址法中的双重哈希，通过使用两个无关的哈希函数来生成排列（也可以使用其他生成随机排列的方法，例如 <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">fisher-yates shuffle</a>，必须保证方法的的随机性）降低了哈希碰撞的概率；在增加或移除 slot 时，需要为新的 slot 生成 permutation table，再重新生成 lookup table，这会导致部分重新映射，不满足最小化重新映射（minimum disruption）；维护两个表的空间复杂度是 O(n)，查询的时间复杂度是 O(1)；建立表的复杂度可以参考论文的第 3.4 节。</p>
<p><img src="https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/consistent-hashing/minimal-disruption.png" alt="minimal-disruption"></p>
<h2 id="4-总结">4 总结</h2>
<p>本文主要介绍了负载均衡的概念，并简单地阐明了一致性哈希算法的原理，关于一致性哈希算法的优缺点、边界条件、复杂度分析、效率对比、实际应用等还需要结合论文和开源组件进行更深入的了解。</p>

      </div>

      <footer>
        


        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "zintrulcre" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </footer>
    </article>

    
  </section>

      </div>

      <footer class="footer">
  <section class="container">
    
    
    
    
      
      <a href="https://github.com/luizdepra/hugo-coder/tree/"></a>
    
  </section>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
    </main>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-132809676-1', 'auto');
	
	ga('send', 'pageview');
}
</script>


  </body>

</html>
