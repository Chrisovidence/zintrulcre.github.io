<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>C++ 闭包和匿名函数 | 尾張</title>
<meta name=keywords content="C++,Pointer,C++11">
<meta name=description content="C++ 闭包和匿名函数 [TOC]
本文主要介绍了 C++ 中闭包和仿函数，以及匿名函数相关的概念。
1 闭包和仿函数 闭包（Closure）可以被理解为一个附带数据的操作，WikiPedia 对闭包的定义是 &ldquo;In programming languages, a closure, also lexical closure or function closure, is a technique for implementing lexically scoped name binding in a language with first-class functions.&#34;，其中有两层含义：
 词法作用域（lexically scoped）的名字绑定（name binding）：在词法作用域（C++ 的词法作用域是静态绑定的，包括块、函数、类、命名空间、全局作用域等）中，变量名与其词法上下文的标识符相关联，而独立于运行时的调用栈； 函数被当作头等公民（first-class citizen）：在运行时可以构造一个函数对象并将其作为参数传递给其他函数；  显然 C++ 98 并不符合这两点定义，因此 C++ 98 中并没有严格意义上的闭包，但我们可以用仿函数（Functor）来模拟闭包的行为；仿函数即一个重载了小括号操作符的类，这个类拥有与函数相近的行为方式，它拥有自己的私有成员变量，例如：
class Adder { public: int operator()(int num) { sum += num; return sum; } Adder() : sum(0) {} Adder(int num) : sum(num) {} private: int sum; }; int main() { Adder adder(0); cout << adder(1) << endl; cout << adder(2) << endl; cout << adder(3) << endl; } $ g++ -std=c++98 -o adder adder.">
<meta name=author content="Providence">
<link rel=canonical href=http://example.org/posts/c++/closure-and-anonymous-function/>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://example.org/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=http://example.org/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=http://example.org/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=http://example.org/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=http://example.org/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.0">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-132809676-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="C++ 闭包和匿名函数">
<meta property="og:description" content="C++ 闭包和匿名函数 [TOC]
本文主要介绍了 C++ 中闭包和仿函数，以及匿名函数相关的概念。
1 闭包和仿函数 闭包（Closure）可以被理解为一个附带数据的操作，WikiPedia 对闭包的定义是 &ldquo;In programming languages, a closure, also lexical closure or function closure, is a technique for implementing lexically scoped name binding in a language with first-class functions.&#34;，其中有两层含义：
 词法作用域（lexically scoped）的名字绑定（name binding）：在词法作用域（C++ 的词法作用域是静态绑定的，包括块、函数、类、命名空间、全局作用域等）中，变量名与其词法上下文的标识符相关联，而独立于运行时的调用栈； 函数被当作头等公民（first-class citizen）：在运行时可以构造一个函数对象并将其作为参数传递给其他函数；  显然 C++ 98 并不符合这两点定义，因此 C++ 98 中并没有严格意义上的闭包，但我们可以用仿函数（Functor）来模拟闭包的行为；仿函数即一个重载了小括号操作符的类，这个类拥有与函数相近的行为方式，它拥有自己的私有成员变量，例如：
class Adder { public: int operator()(int num) { sum += num; return sum; } Adder() : sum(0) {} Adder(int num) : sum(num) {} private: int sum; }; int main() { Adder adder(0); cout << adder(1) << endl; cout << adder(2) << endl; cout << adder(3) << endl; } $ g++ -std=c++98 -o adder adder.">
<meta property="og:type" content="article">
<meta property="og:url" content="http://example.org/posts/c++/closure-and-anonymous-function/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2020-11-14T21:20:18+08:00">
<meta property="article:modified_time" content="2020-11-14T21:20:18+08:00"><meta property="og:site_name" content="尾張">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="C++ 闭包和匿名函数">
<meta name=twitter:description content="C++ 闭包和匿名函数 [TOC]
本文主要介绍了 C++ 中闭包和仿函数，以及匿名函数相关的概念。
1 闭包和仿函数 闭包（Closure）可以被理解为一个附带数据的操作，WikiPedia 对闭包的定义是 &ldquo;In programming languages, a closure, also lexical closure or function closure, is a technique for implementing lexically scoped name binding in a language with first-class functions.&#34;，其中有两层含义：
 词法作用域（lexically scoped）的名字绑定（name binding）：在词法作用域（C++ 的词法作用域是静态绑定的，包括块、函数、类、命名空间、全局作用域等）中，变量名与其词法上下文的标识符相关联，而独立于运行时的调用栈； 函数被当作头等公民（first-class citizen）：在运行时可以构造一个函数对象并将其作为参数传递给其他函数；  显然 C++ 98 并不符合这两点定义，因此 C++ 98 中并没有严格意义上的闭包，但我们可以用仿函数（Functor）来模拟闭包的行为；仿函数即一个重载了小括号操作符的类，这个类拥有与函数相近的行为方式，它拥有自己的私有成员变量，例如：
class Adder { public: int operator()(int num) { sum += num; return sum; } Adder() : sum(0) {} Adder(int num) : sum(num) {} private: int sum; }; int main() { Adder adder(0); cout << adder(1) << endl; cout << adder(2) << endl; cout << adder(3) << endl; } $ g++ -std=c++98 -o adder adder.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://example.org/posts/"},{"@type":"ListItem","position":2,"name":"C++ 闭包和匿名函数","item":"http://example.org/posts/c++/closure-and-anonymous-function/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ 闭包和匿名函数","name":"C\u002b\u002b 闭包和匿名函数","description":"C++ 闭包和匿名函数 [TOC]\n本文主要介绍了 C++ 中闭包和仿函数，以及匿名函数相关的概念。\n1 闭包和仿函数 闭包（Closure）可以被理解为一个附带数据的操作，WikiPedia 对闭包的定义是 \u0026ldquo;In programming languages, a closure, also lexical closure or function closure, is a technique for implementing lexically scoped name binding in a language with first-class functions.\u0026quot;，其中有两层含义：\n 词法作用域（lexically scoped）的名字绑定（name binding）：在词法作用域（C++ 的词法作用域是静态绑定的，包括块、函数、类、命名空间、全局作用域等）中，变量名与其词法上下文的标识符相关联，而独立于运行时的调用栈； 函数被当作头等公民（first-class citizen）：在运行时可以构造一个函数对象并将其作为参数传递给其他函数；  显然 C++ 98 并不符合这两点定义，因此 C++ 98 中并没有严格意义上的闭包，但我们可以用仿函数（Functor）来模拟闭包的行为；仿函数即一个重载了小括号操作符的类，这个类拥有与函数相近的行为方式，它拥有自己的私有成员变量，例如：\nclass Adder { public: int operator()(int num) { sum += num; return sum; } Adder() : sum(0) {} Adder(int num) : sum(num) {} private: int sum; }; int main() { Adder adder(0); cout \u0026lt;\u0026lt; adder(1) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; adder(2) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; adder(3) \u0026lt;\u0026lt; endl; } $ g++ -std=c++98 -o adder adder.","keywords":["C++","Pointer","C++11"],"articleBody":"C++ 闭包和匿名函数 [TOC]\n本文主要介绍了 C++ 中闭包和仿函数，以及匿名函数相关的概念。\n1 闭包和仿函数 闭包（Closure）可以被理解为一个附带数据的操作，WikiPedia 对闭包的定义是 “In programming languages, a closure, also lexical closure or function closure, is a technique for implementing lexically scoped name binding in a language with first-class functions.\"，其中有两层含义：\n 词法作用域（lexically scoped）的名字绑定（name binding）：在词法作用域（C++ 的词法作用域是静态绑定的，包括块、函数、类、命名空间、全局作用域等）中，变量名与其词法上下文的标识符相关联，而独立于运行时的调用栈； 函数被当作头等公民（first-class citizen）：在运行时可以构造一个函数对象并将其作为参数传递给其他函数；  显然 C++ 98 并不符合这两点定义，因此 C++ 98 中并没有严格意义上的闭包，但我们可以用仿函数（Functor）来模拟闭包的行为；仿函数即一个重载了小括号操作符的类，这个类拥有与函数相近的行为方式，它拥有自己的私有成员变量，例如：\nclass Adder { public: int operator()(int num) { sum += num; return sum; } Adder() : sum(0) {} Adder(int num) : sum(num) {} private: int sum; }; int main() { Adder adder(0); cout  adder(1)  endl; cout  adder(2)  endl; cout  adder(3)  endl; } $ g++ -std=c++98 -o adder adder.cpp $ ./adder 1 3 6 相比之下 golang 中真正的闭包显得简洁很多：\nfunc adder() func(int) int { sum := 0 return func(num int) int { sum += num return sum } } func main() { numAdder := adder() fmt.Println(numAdder(1)) fmt.Println(numAdder(2)) fmt.Println(numAdder(3)) } $ go run main.go 1 3 6 C++ 98 的标准库中提供了很多实用的函数，例如 std::sort，当我们需要定制其排序规则的时候，也可以定义一个简单的仿函数（或者普通的函数）作为参数传入 ，注意定义排序规则的时候要满足 Strict Weak Ordering：\nstruct Foo { int a_, b_; Foo(int a, int b) : a_(a), b_(b) {} }; struct FooComparatorGreater { bool operator()(const Foo f1, const Foo f2) { if (f1.a_ != f2.a_) return f1.a_  f2.a_; return f1.b_  f2.b_; } }; int main() { vectorFoo foo{ Foo(3, 6), Foo(9, 2), Foo(9, 8) }; sort(foo.begin(), foo.end(), FooComparatorGreater()); for (const auto\u0026 f : foo) cout  f.a_  ' '  f.b_  endl; return 0; } $ g++ -std=c++11 -o sort-functor sort-functor.cpp $ ./sort-functor 9 8 9 2 3 6 2 匿名函数 匿名函数（Anonymous Function）起源于第一个函数式编程语言 Lisp，C++ 11 标准中正式引入了匿名函数，也叫做 lambda 表达式（Lambda Expression）；匿名函数是一种没有被绑定标识符的函数，可以用于很方便地定义一个临时的函数对象，或作为一个函数对象传递给更上层的函数（例如 std::for_each），其在 C++ 11 的语法上表现得非常轻量级，不需要像普通的具名函数一样单独在头文件中作出声明，且符合闭包的定义。\n匿名函数可以替代掉复杂且冗余的仿函数，使得代码更易于理解和维护：\nsort(foo.begin(), foo.end(), [](const Foo\u0026 f1, const Foo\u0026 f2) { return f1.a_ != f2.a_ ? f1.a_  f2.a_ : f1.b_  f2.b_; }); 匿名函数由以下几个部分组成，其中只有 1, 2, 6 三个部分是必须的，其余部分可以省略：\n 捕获子句 capture clause / lambda introducer 参数列表 parameter list / lambda declarator 可变规格 mutable specification  被 mutable 修饰的匿名函数可以修改按值捕获的变量   异常规格 exception specification 尾随返回类型 trailing-return-type 匿名函数体 lambda body  2.1 捕获子句 捕获子句用于捕获外部变量，使得匿名函数体可以使用这些变量，捕获的方法分为引用捕获和值（拷贝）捕获两种，使用方法如下：\n  [] 不捕获任何变量；\n  [\u0026] 按引用捕获所有外部变量；\n  [=] 按值捕获所有外部变量\n  [\u0026, var] 默认按引用捕获，仅按值捕获 var；\n  [=, \u0026var] 默认按值捕获，仅按引用捕获 var；\n  [y, y] 重复按值捕获同一个变量，没有意义，会报 warning；\n  [\u0026, \u0026var] 默认按引用捕获，并按引用捕获 var，没有意义，会报 warning；\n  [=, this] 默认按值捕获，并按值捕获 this 指针，没有意义，同样会报 warning；\nstd::functionvoid() AnonyFunc = [=, this]() - void {};// warning: explicit by-copy capture of ‘this’ redundant with by-copy capture default   [this] 按值捕获 this 指针，this 指针虽然不能被修改，但其指向的对象可以被操作并修改，相当于按引用捕获了 this 指向的对象，即 [\u0026(*this)]；\nclass Foo { public: void Func() { int y{ 0 }; std::functionvoid() AnonyFunc = [this]() - void { x_ = 2; // ok，x_ 是类的成员变量，可以被修改  y = 2; // error: ‘y’ is not captured，函数的局部变量并没有被捕获  this = nullptr; // error: lvalue required as left operand of assignment，这里捕获的 this 指针是一个临时变量即右值，不能被修改  }; AnonyFunc(); } private: int x_ = 0; };   [*this] 在 C++ 11 中不能按值捕获 this 指针指向的对象；\nstd::functionvoid() AnonyFunc = [*this]() - void {}; // error: expected identifier before ‘*’ token   在使用捕获子句的时候，需要注意一些问题：\n  不建议使用 2，3 这两种方式进行捕获（对性能影响较大），应该明确地指出需要按引用捕获的变量；\n  按值捕获的变量是 read-only (const) 的，只有当匿名函数的可变规格被显式声明为 mutable 的时候才可以修改按值捕获的变量；\nint x{ 0 }; auto AnonyFunc = [=]() - void { x = 1; // error: assignment of read-only variable ‘x’ } auto AnonyFunc = [=]() mutable - void { x = 1; // ok }   按值捕获的变量的值在匿名函数生成的时候就已经确定了，如果在匿名函数生成后修改外部变量的值，则不会影响到匿名函数内被捕获的变量值，因为它们是两个作用域不同的变量：\nint i{ 0 }; auto AnonyFunc = [i]() - void { cout  i  endl; cout  \u0026i  endl; }; i = 1; cout  i  endl; cout  \u0026i  endl; AnonyFunc(); $ g++ -std=c++11 -o lambda-capture lambda-capture.cpp $ ./lambda-capture 1 0x7ffe31fced8c 0 0x7ffe31fced80   对于按引用捕获的变量（或按值捕获的指针），如果该引用变量（或指针指向的对象）在外部被析构，那么匿名函数中的引用变量（或指针）则会成为悬空引用/指针（Dangling Pointer）：\nint* x = new int[1000000]; x[0] = 0; auto AnonyFunc = [\u0026x]() { x[0] = 1; // Segmentation fault }; delete[] x; AnonyFunc(); struct Foo { int x_[1000000]; }; int main() { Foo* f = new Foo(); f-x_[0] = 0; auto AnonyFunc = [f]() - void { f-x_[0] = 1; // Segmentation fault  }; delete f; AnonyFunc(); }   2.2 匿名函数和闭包 Scott Meyers 对 lambda 表达式（匿名函数）与闭包之间的关系的解释是 “The distinction between a lambda and the corresponding closure is precisely equivalent to the distinction between a class and an instance of the class. A class exists only in source code; it doesn’t exist at runtime. What exists at runtime are objects of the class type. Closures are to lambdas as objects are to classes. This should not be a surprise, because each lambda expression causes a unique class to be generated (during compilation) and also causes an object of that class type–a closure–to be created (at runtime).\"；\n这段解释可以拆分为两段：\n 匿名函数和闭包的关系就如同类和类对象的关系，匿名函数和类的定义都只存在于源码（代码段）中，而闭包和类对象则是在运行时占用内存空间的实体； 对匿名函数的定义会生成一个独一无二的类，并在运行时生成其类对象；  再结合 C++ 11 的标准说明：\n \"[C++11: 5.1.2/3]: The type of the lambda-expression (which is also the type of the closure object) is a unique, unnamed non-union class type — called the closure type…\"，C++ 11 中的匿名函数实际上也是用类（closure type）来实现的； “[C++11: 5.1.2/5]: The closure type for a lambda-expression has a public inline function call operator (13.5.4) whose parameters and return type are described by the lambda-expression’s parameter-declaration-clause and trailing-return-type respectively. [..]”，匿名函数生成的类中也重载了 operator()，其参数与匿名函数的参数列表相同，返回值与匿名函数的尾随返回类型相同； \"[C++11: 5.1.2/6]: The closure type for a lambda-expression with no lambda-capture has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure type’s function call operator. The value returned by this conversion function shall be the address of a function that, when invoked, has the same effect as invoking the closure type’s function call operator.\"，如果匿名函数没有任何参数，那么将会生成一个普通的函数，而不是闭包类型；  可以知道实际上匿名函数也是用仿函数实现的，它实际上是 C++ 11 加入的语法糖，不过其语法特性是符合闭包定义的。\n3 匿名函数在 C++ 14 及之后的变化 C++ 14 广义捕获 C++ 14 中引入了新的广义 lambda 捕获（Generalized Lambda Captures），即可以在捕获列表中以任意方式初始化匿名函数中的变量，使得某些被禁用了拷贝构造函数的类型可以通过 std::move 的方式被捕获到匿名函数中：\nauto ptr_0 = make_uniqueint( 0 ); auto AnonyFunc = [ptr_0 = move(ptr_0)]() { *ptr_0 = 1; cout  *ptr_0  endl; }; AnonyFunc(); 这里捕获列表中左边和右边的 ptr_0 不是同一个变量，它们的作用域分别是匿名函数内和匿名函数外；\n除此之外广义 lambda 捕获还可以用来间接地捕获 *this，即在 C++ 11 中无法实现的按值捕获 this 指向的对象：\nauto AnonyFunc = [this_copy = *this]() mutable { this_copy.x_ = 1; cout  this_copy.x_  endl; }; AnonyFunc(); C++ 17 捕获 *this 在 C++ 17 中，终于可以直接捕获 *this 了，提案 P0018R3 指出捕获 *this 可以用于需要进行异步操作的并发应用，因为 this 可能失效：\nauto AnonyFunc = [*this]() mutable { x_ = 1; cout  x_  endl; }; AnonyFunc(); cout  x_  endl; $ g++ -std=c++17 -o lambda lambda.cpp $ ./lambda 1 0 ","wordCount":"955","inLanguage":"en","datePublished":"2020-11-14T21:20:18+08:00","dateModified":"2020-11-14T21:20:18+08:00","author":{"@type":"Person","name":"Providence"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://example.org/posts/c++/closure-and-anonymous-function/"},"publisher":{"@type":"Organization","name":"尾張","logo":{"@type":"ImageObject","url":"http://example.org/%3Clink%20/%20abs%20url%3E"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://example.org/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=http://example.org/archives/ title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=http://example.org/about/ title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=http://example.org/>Home</a>&nbsp;»&nbsp;<a href=http://example.org/posts/>Posts</a></div>
<h1 class=post-title>
C++ 闭包和匿名函数
</h1>
<div class=post-meta><span title="2020-11-14 21:20:18 +0800 CST">November 14, 2020</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Providence&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/C++/closure-and-anonymous-function.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header> <div class=toc>
<details open>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#c-%e9%97%ad%e5%8c%85%e5%92%8c%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0 aria-label="C++ 闭包和匿名函数">C++ 闭包和匿名函数</a><ul>
<li>
<a href=#1-%e9%97%ad%e5%8c%85%e5%92%8c%e4%bb%bf%e5%87%bd%e6%95%b0 aria-label="1 闭包和仿函数">1 闭包和仿函数</a></li>
<li>
<a href=#2-%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0 aria-label="2 匿名函数">2 匿名函数</a><ul>
<li>
<a href=#21-%e6%8d%95%e8%8e%b7%e5%ad%90%e5%8f%a5 aria-label="2.1 捕获子句">2.1 捕获子句</a></li>
<li>
<a href=#22-%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0%e5%92%8c%e9%97%ad%e5%8c%85 aria-label="2.2 匿名函数和闭包">2.2 匿名函数和闭包</a></li></ul>
</li>
<li>
<a href=#3-%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0%e5%9c%a8-c-14-%e5%8f%8a%e4%b9%8b%e5%90%8e%e7%9a%84%e5%8f%98%e5%8c%96 aria-label="3 匿名函数在 C++ 14 及之后的变化">3 匿名函数在 C++ 14 及之后的变化</a><ul>
<li>
<a href=#c-14-%e5%b9%bf%e4%b9%89%e6%8d%95%e8%8e%b7 aria-label="C++ 14 广义捕获">C++ 14 广义捕获</a></li>
<li>
<a href=#c-17-%e6%8d%95%e8%8e%b7-this aria-label="C++ 17 捕获 *this">C++ 17 捕获 <code>*this</code></a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h1 id=c-闭包和匿名函数>C++ 闭包和匿名函数<a hidden class=anchor aria-hidden=true href=#c-闭包和匿名函数>#</a></h1>
<p>[TOC]</p>
<p>本文主要介绍了 C++ 中闭包和仿函数，以及匿名函数相关的概念。</p>
<h2 id=1-闭包和仿函数>1 闭包和仿函数<a hidden class=anchor aria-hidden=true href=#1-闭包和仿函数>#</a></h2>
<p><strong>闭包</strong>（<a href=https://en.wikipedia.org/wiki/Closure_(computer_programming)>Closure</a>）可以被理解为一个附带数据的操作，WikiPedia 对闭包的定义是 <em>&ldquo;In programming languages, a <strong>closure</strong>, also <strong>lexical closure</strong> or <strong>function closure</strong>, is a technique for implementing <strong>lexically scoped name binding</strong> in a language with <strong>first-class functions</strong>."</em>，其中有两层含义：</p>
<ol>
<li>词法作用域（<a href=https://en.wikipedia.org/wiki/Lexically_scoped>lexically scoped</a>）的名字绑定（<a href=https://en.wikipedia.org/wiki/Name_binding>name binding</a>）：在词法作用域（C++ 的词法作用域是静态绑定的，包括块、函数、类、命名空间、全局作用域等）中，变量名与其词法上下文的标识符相关联，而独立于运行时的调用栈；</li>
<li>函数被当作头等公民（<a href=https://en.wikipedia.org/wiki/First-class_citizen>first-class citizen</a>）：在运行时可以构造一个函数对象并将其作为参数传递给其他函数；</li>
</ol>
<p>显然 C++ 98 并不符合这两点定义，因此 C++ 98 中并没有严格意义上的闭包，但我们可以用仿函数（<a href=https://www.geeksforgeeks.org/functors-in-cpp/>Functor</a>）来模拟闭包的行为；仿函数即一个重载了小括号操作符的类，这个类拥有与函数相近的行为方式，它拥有自己的私有成员变量，例如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Adder</span>
{
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>int</span> <span style=color:#66d9ef>operator</span>()(<span style=color:#66d9ef>int</span> num)
    {
        sum <span style=color:#f92672>+=</span> num;
        <span style=color:#66d9ef>return</span> sum;
    }

    Adder() <span style=color:#f92672>:</span> sum(<span style=color:#ae81ff>0</span>) {}
    Adder(<span style=color:#66d9ef>int</span> num) <span style=color:#f92672>:</span> sum(num) {}
<span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>int</span> sum;
};
   
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
{
    Adder adder(<span style=color:#ae81ff>0</span>);
    cout <span style=color:#f92672>&lt;&lt;</span> adder(<span style=color:#ae81ff>1</span>) <span style=color:#f92672>&lt;&lt;</span> endl;
    cout <span style=color:#f92672>&lt;&lt;</span> adder(<span style=color:#ae81ff>2</span>) <span style=color:#f92672>&lt;&lt;</span> endl;
    cout <span style=color:#f92672>&lt;&lt;</span> adder(<span style=color:#ae81ff>3</span>) <span style=color:#f92672>&lt;&lt;</span> endl;
}
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ g++ -std<span style=color:#f92672>=</span>c++98 -o adder adder.cpp 
$ ./adder 
<span style=color:#ae81ff>1</span>
<span style=color:#ae81ff>3</span>
<span style=color:#ae81ff>6</span>
</code></pre></div><p>相比之下 golang 中真正的闭包显得简洁很多：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>adder</span>() <span style=color:#66d9ef>func</span>(<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
	<span style=color:#a6e22e>sum</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>num</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
		<span style=color:#a6e22e>sum</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>num</span>
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>sum</span>
	}
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>numAdder</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>adder</span>()
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>numAdder</span>(<span style=color:#ae81ff>1</span>))
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>numAdder</span>(<span style=color:#ae81ff>2</span>))
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>numAdder</span>(<span style=color:#ae81ff>3</span>))
}
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ go run main.go 
<span style=color:#ae81ff>1</span>
<span style=color:#ae81ff>3</span>
<span style=color:#ae81ff>6</span>
</code></pre></div><p>C++ 98 的标准库中提供了很多实用的函数，例如 <code>std::sort</code>，当我们需要定制其排序规则的时候，也可以定义一个简单的仿函数（或者普通的函数）作为参数传入 ，注意定义排序规则的时候要满足 <a href=https://www.boost.org/sgi/stl/StrictWeakOrdering.html>Strict Weak Ordering</a>：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Foo</span>
{
    <span style=color:#66d9ef>int</span> a_, b_;
    Foo(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) <span style=color:#f92672>:</span> a_(a), b_(b) {}
};

<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>FooComparatorGreater</span>
{
    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>operator</span>()(<span style=color:#66d9ef>const</span> Foo f1, <span style=color:#66d9ef>const</span> Foo f2)
    {
        <span style=color:#66d9ef>if</span> (f1.a_ <span style=color:#f92672>!=</span> f2.a_)
            <span style=color:#66d9ef>return</span> f1.a_ <span style=color:#f92672>&gt;</span> f2.a_;
        <span style=color:#66d9ef>return</span> f1.b_ <span style=color:#f92672>&gt;</span> f2.b_;
    }
};

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
{
    vector<span style=color:#f92672>&lt;</span>Foo<span style=color:#f92672>&gt;</span> foo{ Foo(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>6</span>), Foo(<span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>2</span>), Foo(<span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>8</span>) };
    sort(foo.begin(), foo.end(), FooComparatorGreater());
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> f : foo)
        cout <span style=color:#f92672>&lt;&lt;</span> f.a_ <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>&lt;&lt;</span> f.b_ <span style=color:#f92672>&lt;&lt;</span> endl;
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ g++ -std<span style=color:#f92672>=</span>c++11 -o sort-functor sort-functor.cpp 
$ ./sort-functor 
<span style=color:#ae81ff>9</span> <span style=color:#ae81ff>8</span>
<span style=color:#ae81ff>9</span> <span style=color:#ae81ff>2</span>
<span style=color:#ae81ff>3</span> <span style=color:#ae81ff>6</span>
</code></pre></div><h2 id=2-匿名函数>2 匿名函数<a hidden class=anchor aria-hidden=true href=#2-匿名函数>#</a></h2>
<p><strong>匿名函数</strong>（<a href=https://en.wikipedia.org/wiki/Anonymous_function>Anonymous Function</a>）起源于第一个<a href=https://en.wikipedia.org/wiki/Functional_programming>函数式编程</a>语言 <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)#:~:text=Lisp%20(historically%20LISP)%20is%20a,is%20older%2C%20by%20one%20year.">Lisp</a>，C++ 11 标准中正式引入了匿名函数，也叫做 lambda 表达式（<a href=https://en.cppreference.com/w/cpp/language/lambda>Lambda Expression</a>）；匿名函数是一种没有被绑定标识符的函数，可以用于很方便地定义一个临时的函数对象，或作为一个函数对象传递给更上层的函数（例如 <a href=https://en.cppreference.com/w/cpp/algorithm/sort><code>std::for_each</code></a>），其在 C++ 11 的语法上表现得非常轻量级，不需要像普通的<strong>具名函数</strong>一样单独在头文件中作出声明，且<strong>符合闭包的定义</strong>。</p>
<p>匿名函数可以替代掉复杂且冗余的仿函数，使得代码更易于理解和维护：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>sort(foo.begin(), foo.end(), [](<span style=color:#66d9ef>const</span> Foo<span style=color:#f92672>&amp;</span> f1, <span style=color:#66d9ef>const</span> Foo<span style=color:#f92672>&amp;</span> f2)
{
    <span style=color:#66d9ef>return</span> f1.a_ <span style=color:#f92672>!=</span> f2.a_ <span style=color:#f92672>?</span> f1.a_ <span style=color:#f92672>&gt;</span> f2.a_ : f1.b_ <span style=color:#f92672>&gt;</span> f2.b_;
});
</code></pre></div><p>匿名函数由以下几个部分组成，其中只有 1, 2, 6 三个部分是必须的，其余部分可以省略：</p>
<p><img loading=lazy src=https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/cpp/lambda-expression-syntax.png alt=lambda-expression-syntax>
</p>
<ol>
<li>捕获子句 capture clause / lambda introducer</li>
<li>参数列表 parameter list / lambda declarator</li>
<li>可变规格 mutable specification
<ul>
<li>被 mutable 修饰的匿名函数可以修改按值捕获的变量</li>
</ul>
</li>
<li>异常规格 exception specification</li>
<li>尾随返回类型 trailing-return-type</li>
<li>匿名函数体 lambda body</li>
</ol>
<h3 id=21-捕获子句>2.1 捕获子句<a hidden class=anchor aria-hidden=true href=#21-捕获子句>#</a></h3>
<p>捕获子句用于捕获外部变量，使得匿名函数体可以使用这些变量，捕获的方法分为引用捕获和值（拷贝）捕获两种，使用方法如下：</p>
<ol>
<li>
<p><code>[]</code> 不捕获任何变量；</p>
</li>
<li>
<p><code>[&]</code> 按引用捕获所有外部变量；</p>
</li>
<li>
<p><code>[=]</code> 按值捕获所有外部变量</p>
</li>
<li>
<p><code>[&, var]</code> 默认按引用捕获，仅按值捕获 var；</p>
</li>
<li>
<p><code>[=, &var]</code> 默认按值捕获，仅按引用捕获 var；</p>
</li>
<li>
<p><code>[y, y]</code> 重复按值捕获同一个变量，没有意义，会报 warning；</p>
</li>
<li>
<p><code>[&, &var]</code> 默认按引用捕获，并按引用捕获 var，没有意义，会报 warning；</p>
</li>
<li>
<p><code>[=, this]</code> 默认按值捕获，并按值捕获 this 指针，没有意义，同样会报 warning；</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>std<span style=color:#f92672>::</span>function<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span>()<span style=color:#f92672>&gt;</span> AnonyFunc <span style=color:#f92672>=</span> [<span style=color:#f92672>=</span>, <span style=color:#66d9ef>this</span>]() <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>void</span> {};<span style=color:#75715e>//  warning: explicit by-copy capture of ‘this’ redundant with by-copy capture default
</span></code></pre></div></li>
<li>
<p><code>[this]</code> 按值捕获 this 指针，this 指针虽然不能被修改，但其指向的对象可以被操作并修改，相当于按引用捕获了 this 指向的对象，即 <code>[&(*this)]</code>；</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Foo</span>
{
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>void</span> Func()
    {
        <span style=color:#66d9ef>int</span> y{ <span style=color:#ae81ff>0</span> };
        std<span style=color:#f92672>::</span>function<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span>()<span style=color:#f92672>&gt;</span> AnonyFunc <span style=color:#f92672>=</span> [<span style=color:#66d9ef>this</span>]() <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>void</span>
        {
            x_ <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; <span style=color:#75715e>// ok，x_ 是类的成员变量，可以被修改
</span><span style=color:#75715e></span>            y <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; <span style=color:#75715e>// error: ‘y’ is not captured，函数的局部变量并没有被捕获
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>this</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>; <span style=color:#75715e>// error: lvalue required as left operand of assignment，这里捕获的 this 指针是一个临时变量即右值，不能被修改
</span><span style=color:#75715e></span>        };
        AnonyFunc();
    }

<span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>int</span> x_ <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
};
</code></pre></div></li>
<li>
<p><code>[*this]</code> 在 C++ 11 中不能按值捕获 this 指针指向的对象；</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>std<span style=color:#f92672>::</span>function<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span>()<span style=color:#f92672>&gt;</span> AnonyFunc <span style=color:#f92672>=</span> [<span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>]() <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>void</span> {}; <span style=color:#75715e>// error: expected identifier before ‘*’ token
</span></code></pre></div></li>
</ol>
<p>在使用捕获子句的时候，需要注意一些问题：</p>
<ol>
<li>
<p>不建议使用 2，3 这两种方式进行捕获（对性能影响较大），应该明确地指出需要按引用捕获的变量；</p>
</li>
<li>
<p>按值捕获的变量是 read-only (const) 的，只有当匿名函数的可变规格被显式声明为 <code>mutable</code> 的时候才可以修改按值捕获的变量；</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>int</span> x{ <span style=color:#ae81ff>0</span> };

<span style=color:#66d9ef>auto</span> AnonyFunc <span style=color:#f92672>=</span> [<span style=color:#f92672>=</span>]() <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>void</span>
{
    x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// error: assignment of read-only variable ‘x’
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>auto</span> AnonyFunc <span style=color:#f92672>=</span> [<span style=color:#f92672>=</span>]() <span style=color:#66d9ef>mutable</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>void</span>
{
    x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// ok
</span><span style=color:#75715e></span>}
</code></pre></div></li>
<li>
<p>按值捕获的变量的值在匿名函数生成的时候就已经确定了，如果在匿名函数生成后修改外部变量的值，则不会影响到匿名函数内被捕获的变量值，因为它们是两个作用域不同的变量：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>int</span> i{ <span style=color:#ae81ff>0</span> };
<span style=color:#66d9ef>auto</span> AnonyFunc <span style=color:#f92672>=</span> [i]() <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>void</span>
{
    cout <span style=color:#f92672>&lt;&lt;</span> i <span style=color:#f92672>&lt;&lt;</span> endl;
    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>&amp;</span>i <span style=color:#f92672>&lt;&lt;</span> endl;
};
i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
cout <span style=color:#f92672>&lt;&lt;</span> i <span style=color:#f92672>&lt;&lt;</span> endl;
cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>&amp;</span>i <span style=color:#f92672>&lt;&lt;</span> endl;
AnonyFunc();
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ g++ -std<span style=color:#f92672>=</span>c++11 -o lambda-capture lambda-capture.cpp 
$ ./lambda-capture 
<span style=color:#ae81ff>1</span>
0x7ffe31fced8c
<span style=color:#ae81ff>0</span>
0x7ffe31fced80
</code></pre></div></li>
<li>
<p>对于按引用捕获的变量（或按值捕获的指针），如果该引用变量（或指针指向的对象）在外部被析构，那么匿名函数中的引用变量（或指针）则会成为<strong>悬空引用/指针</strong>（<a href=https://en.wikipedia.org/wiki/Dangling_pointer>Dangling Pointer</a>）：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> x <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[<span style=color:#ae81ff>1000000</span>];
x[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
<span style=color:#66d9ef>auto</span> AnonyFunc <span style=color:#f92672>=</span> [<span style=color:#f92672>&amp;</span>x]()
{
    x[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// Segmentation fault
</span><span style=color:#75715e></span>};
<span style=color:#66d9ef>delete</span>[] x;
AnonyFunc();
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Foo</span>
{
    <span style=color:#66d9ef>int</span> x_[<span style=color:#ae81ff>1000000</span>];
};

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
{
    Foo<span style=color:#f92672>*</span> f <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Foo();
    f<span style=color:#f92672>-&gt;</span>x_[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>auto</span> AnonyFunc <span style=color:#f92672>=</span> [f]() <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>void</span>
    {
        f<span style=color:#f92672>-&gt;</span>x_[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// Segmentation fault
</span><span style=color:#75715e></span>    };
    <span style=color:#66d9ef>delete</span> f;
    AnonyFunc();
}
</code></pre></div></li>
</ol>
<h3 id=22-匿名函数和闭包>2.2 匿名函数和闭包<a hidden class=anchor aria-hidden=true href=#22-匿名函数和闭包>#</a></h3>
<p><em>Scott Meyers</em> 对 lambda 表达式（匿名函数）与闭包之间的关系的解释是 <em>&ldquo;The distinction between a lambda and the corresponding closure is precisely equivalent to the distinction between a class and an instance of the class. A class exists only in source code; it doesn’t exist at runtime. What exists at runtime are objects of the class type. Closures are to lambdas as objects are to classes. This should not be a surprise, because each lambda expression causes a unique class to be generated (during compilation) and also causes an object of that class type–a closure–to be created (at runtime)."</em>；</p>
<p>这段解释可以拆分为两段：</p>
<ol>
<li>匿名函数和闭包的关系就如同类和类对象的关系，匿名函数和类的定义都只存在于源码（代码段）中，而闭包和类对象则是在运行时占用内存空间的实体；</li>
<li>对匿名函数的定义会生成一个独一无二的类，并在运行时生成其类对象；</li>
</ol>
<p>再结合 C++ 11 的标准说明：</p>
<ul>
<li><em>"[C++11: 5.1.2/3]: The type of the lambda-expression (which is also the type of the closure object) is a unique, unnamed non-union class type — called the closure type&mldr;"</em>，C++ 11 中的匿名函数实际上也是用类（closure type）来实现的；</li>
<li><em>“[C++11: 5.1.2/5]: The closure type for a lambda-expression has a public inline function call operator (13.5.4) whose parameters and return type are described by the lambda-expression’s parameter-declaration-clause and trailing-return-type respectively. [..]”</em>，匿名函数生成的类中也重载了 <code>operator()</code>，其参数与匿名函数的参数列表相同，返回值与匿名函数的尾随返回类型相同；</li>
<li><em>"[C++11: 5.1.2/6]: The closure type for a lambda-expression with no lambda-capture has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure type’s function call operator. The value returned by this conversion function shall be the address of a function that, when invoked, has the same effect as invoking the closure type’s function call operator."</em>，如果匿名函数没有任何参数，那么将会生成一个普通的函数，而不是闭包类型；</li>
</ul>
<p>可以知道实际上匿名函数也是用仿函数实现的，它实际上是 C++ 11 加入的语法糖，不过其语法特性是符合闭包定义的。</p>
<h2 id=3-匿名函数在-c-14-及之后的变化>3 匿名函数在 C++ 14 及之后的变化<a hidden class=anchor aria-hidden=true href=#3-匿名函数在-c-14-及之后的变化>#</a></h2>
<h3 id=c-14-广义捕获>C++ 14 广义捕获<a hidden class=anchor aria-hidden=true href=#c-14-广义捕获>#</a></h3>
<p>C++ 14 中引入了新的<strong>广义 lambda 捕获</strong>（<a href=https://en.wikipedia.org/wiki/C%2B%2B14#Generic_lambdas>Generalized Lambda Captures</a>），即可以在捕获列表中以任意方式初始化匿名函数中的变量，使得某些被禁用了拷贝构造函数的类型可以通过 <code>std::move</code> 的方式被捕获到匿名函数中：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>auto</span> ptr_0 <span style=color:#f92672>=</span> make_unique<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>( <span style=color:#ae81ff>0</span> );
<span style=color:#66d9ef>auto</span> AnonyFunc <span style=color:#f92672>=</span> [ptr_0 <span style=color:#f92672>=</span> move(ptr_0)]()
{
    <span style=color:#f92672>*</span>ptr_0 <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>ptr_0 <span style=color:#f92672>&lt;&lt;</span> endl;
};
AnonyFunc();
</code></pre></div><p>这里捕获列表中左边和右边的 <code>ptr_0</code> 不是同一个变量，它们的作用域分别是匿名函数内和匿名函数外；</p>
<p>除此之外广义 lambda 捕获还可以用来间接地捕获 <code>*this</code>，即在 C++ 11 中无法实现的按值捕获 this 指向的对象：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>auto</span> AnonyFunc <span style=color:#f92672>=</span> [this_copy <span style=color:#f92672>=</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>]() <span style=color:#66d9ef>mutable</span>
{
    this_copy.x_ <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
    cout <span style=color:#f92672>&lt;&lt;</span> this_copy.x_ <span style=color:#f92672>&lt;&lt;</span> endl;
};
AnonyFunc();
</code></pre></div><h3 id=c-17-捕获-this>C++ 17 捕获 <code>*this</code><a hidden class=anchor aria-hidden=true href=#c-17-捕获-this>#</a></h3>
<p>在 C++ 17 中，终于可以直接捕获 <code>*this</code> 了，<a href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0018r3.html>提案 P0018R3</a> 指出捕获 <code>*this</code> 可以用于需要进行异步操作的并发应用，因为 <code>this</code> 可能失效：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>auto</span> AnonyFunc <span style=color:#f92672>=</span> [<span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>]() <span style=color:#66d9ef>mutable</span>
{
    x_ <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
    cout <span style=color:#f92672>&lt;&lt;</span> x_ <span style=color:#f92672>&lt;&lt;</span> endl;
};
AnonyFunc();
cout <span style=color:#f92672>&lt;&lt;</span> x_ <span style=color:#f92672>&lt;&lt;</span> endl;
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ g++ -std<span style=color:#f92672>=</span>c++17 -o lambda lambda.cpp 
$ ./lambda 
<span style=color:#ae81ff>1</span>
<span style=color:#ae81ff>0</span>
</code></pre></div>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=http://example.org/tags/c++/>C++</a></li>
<li><a href=http://example.org/tags/pointer/>Pointer</a></li>
<li><a href=http://example.org/tags/c++11/>C++11</a></li>
</ul>
<nav class=paginav>
<a class=prev href=http://example.org/posts/reinforcement-learning/heuristic-search-and-reinforcement-learning/>
<span class=title>« Prev Page</span>
<br>
<span>启发式搜索和强化学习</span>
</a>
<a class=next href=http://example.org/posts/service-governance/load-balancing/>
<span class=title>Next Page »</span>
<br>
<span>负载均衡和一致性哈希</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share C++ 闭包和匿名函数 on twitter" href="https://twitter.com/intent/tweet/?text=C%2b%2b%20%e9%97%ad%e5%8c%85%e5%92%8c%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0&url=http%3a%2f%2fexample.org%2fposts%2fc%2b%2b%2fclosure-and-anonymous-function%2f&hashtags=C%2b%2b%2cPointer%2cC%2b%2b11"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share C++ 闭包和匿名函数 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fexample.org%2fposts%2fc%2b%2b%2fclosure-and-anonymous-function%2f&title=C%2b%2b%20%e9%97%ad%e5%8c%85%e5%92%8c%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0&summary=C%2b%2b%20%e9%97%ad%e5%8c%85%e5%92%8c%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0&source=http%3a%2f%2fexample.org%2fposts%2fc%2b%2b%2fclosure-and-anonymous-function%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share C++ 闭包和匿名函数 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fexample.org%2fposts%2fc%2b%2b%2fclosure-and-anonymous-function%2f&title=C%2b%2b%20%e9%97%ad%e5%8c%85%e5%92%8c%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share C++ 闭包和匿名函数 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fexample.org%2fposts%2fc%2b%2b%2fclosure-and-anonymous-function%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share C++ 闭包和匿名函数 on whatsapp" href="https://api.whatsapp.com/send?text=C%2b%2b%20%e9%97%ad%e5%8c%85%e5%92%8c%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0%20-%20http%3a%2f%2fexample.org%2fposts%2fc%2b%2b%2fclosure-and-anonymous-function%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share C++ 闭包和匿名函数 on telegram" href="https://telegram.me/share/url?text=C%2b%2b%20%e9%97%ad%e5%8c%85%e5%92%8c%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0&url=http%3a%2f%2fexample.org%2fposts%2fc%2b%2b%2fclosure-and-anonymous-function%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=http://example.org/>尾張</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>