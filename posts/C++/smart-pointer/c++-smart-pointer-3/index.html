<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>C++ 智能指针（3）：shared_ptr | 尾張</title>
<meta name=keywords content>
<meta name=description content="C++智能指针（3）：shared_ptr 分析 UniquePointer对象只能绑定单个指针，要实现指针的自动管理和销毁需要引入计数器
private: int *counter; T *pointer; D *deleter; 计数器的主要作用是标识当前指针被几个智能指针对象所引用，在析构当前对象时，使其计数器自减1。如果计数器等于0，则表示已经没有其他的对象在使用当前指针，此时则可以销毁指针，计数器和删除器。
template<typename T, typename D> void SharedPointer<T, D>::release() { if (pointer) { std::cout << &#34;SharedPointer &#34; << this << &#34; counter remains &#34; << *counter << std::endl; if (--(*counter) == 0) { std::cout << &#34;SharedPointer &#34; << this << &#34; destructor called.&#34; << std::endl; (*deleter)(pointer); (*deleter)(counter); (*deleter)(deleter); pointer = nullptr; counter = nullptr; deleter = nullptr; } } } reset函数将指针设为other的指针">
<meta name=author content="Providence">
<link rel=canonical href=http://example.org/posts/c++/smart-pointer/c++-smart-pointer-3/>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://example.org/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=http://example.org/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=http://example.org/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=http://example.org/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=http://example.org/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.0">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-132809676-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="C++ 智能指针（3）：shared_ptr">
<meta property="og:description" content="C++智能指针（3）：shared_ptr 分析 UniquePointer对象只能绑定单个指针，要实现指针的自动管理和销毁需要引入计数器
private: int *counter; T *pointer; D *deleter; 计数器的主要作用是标识当前指针被几个智能指针对象所引用，在析构当前对象时，使其计数器自减1。如果计数器等于0，则表示已经没有其他的对象在使用当前指针，此时则可以销毁指针，计数器和删除器。
template<typename T, typename D> void SharedPointer<T, D>::release() { if (pointer) { std::cout << &#34;SharedPointer &#34; << this << &#34; counter remains &#34; << *counter << std::endl; if (--(*counter) == 0) { std::cout << &#34;SharedPointer &#34; << this << &#34; destructor called.&#34; << std::endl; (*deleter)(pointer); (*deleter)(counter); (*deleter)(deleter); pointer = nullptr; counter = nullptr; deleter = nullptr; } } } reset函数将指针设为other的指针">
<meta property="og:type" content="article">
<meta property="og:url" content="http://example.org/posts/c++/smart-pointer/c++-smart-pointer-3/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2019-01-25T17:47:38+11:00">
<meta property="article:modified_time" content="2019-01-25T17:47:38+11:00"><meta property="og:site_name" content="尾張">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="C++ 智能指针（3）：shared_ptr">
<meta name=twitter:description content="C++智能指针（3）：shared_ptr 分析 UniquePointer对象只能绑定单个指针，要实现指针的自动管理和销毁需要引入计数器
private: int *counter; T *pointer; D *deleter; 计数器的主要作用是标识当前指针被几个智能指针对象所引用，在析构当前对象时，使其计数器自减1。如果计数器等于0，则表示已经没有其他的对象在使用当前指针，此时则可以销毁指针，计数器和删除器。
template<typename T, typename D> void SharedPointer<T, D>::release() { if (pointer) { std::cout << &#34;SharedPointer &#34; << this << &#34; counter remains &#34; << *counter << std::endl; if (--(*counter) == 0) { std::cout << &#34;SharedPointer &#34; << this << &#34; destructor called.&#34; << std::endl; (*deleter)(pointer); (*deleter)(counter); (*deleter)(deleter); pointer = nullptr; counter = nullptr; deleter = nullptr; } } } reset函数将指针设为other的指针">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://example.org/posts/"},{"@type":"ListItem","position":2,"name":"C++ 智能指针（3）：shared_ptr","item":"http://example.org/posts/c++/smart-pointer/c++-smart-pointer-3/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ 智能指针（3）：shared_ptr","name":"C\u002b\u002b 智能指针（3）：shared_ptr","description":"C++智能指针（3）：shared_ptr 分析 UniquePointer对象只能绑定单个指针，要实现指针的自动管理和销毁需要引入计数器\nprivate: int *counter; T *pointer; D *deleter; 计数器的主要作用是标识当前指针被几个智能指针对象所引用，在析构当前对象时，使\u0008其计数器自减1。\u0008如果计数器等于0，则表示已经没有其他的对象在使用当前指针，\u0008此时则可以销毁指针，计数器和删除器。\ntemplate\u0026lt;typename T, typename D\u0026gt; void SharedPointer\u0026lt;T, D\u0026gt;::release() { if (pointer) { std::cout \u0026lt;\u0026lt; \u0026quot;SharedPointer \u0026quot; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026quot; counter remains \u0026quot; \u0026lt;\u0026lt; *counter \u0026lt;\u0026lt; std::endl; if (--(*counter) == 0) { std::cout \u0026lt;\u0026lt; \u0026quot;SharedPointer \u0026quot; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026quot; destructor called.\u0026quot; \u0026lt;\u0026lt; std::endl; (*deleter)(pointer); (*deleter)(counter); (*deleter)(deleter); pointer = nullptr; counter = nullptr; deleter = nullptr; } } } reset函数将指针设为other的指针","keywords":[],"articleBody":"C++智能指针（3）：shared_ptr 分析 UniquePointer对象只能绑定单个指针，要实现指针的自动管理和销毁需要引入计数器\nprivate: int *counter; T *pointer; D *deleter; 计数器的主要作用是标识当前指针被几个智能指针对象所引用，在析构当前对象时，使\u0008其计数器自减1。\u0008如果计数器等于0，则表示已经没有其他的对象在使用当前指针，\u0008此时则可以销毁指针，计数器和删除器。\ntemplatevoid SharedPointer::release() { if (pointer) { std::cout reset函数将指针设为other的指针\ntemplatevoid SharedPointer::reset(const SharedPointer\u0026other) { pointer = other.pointer; counter = other.counter; deleter = other.deleter; if (pointer) ++(*counter); } 析构函数可以直接调用release函数\ntemplateSharedPointer::~SharedPointer() { release(); } 拷贝构造函数可以直接调用reset函数\ntemplateSharedPointer::SharedPointer(const SharedPointer\u0026other) { std::cout 使用赋值操作符时先调用release函数，再调用reset函数\ntemplateSharedPointer\u0026SharedPointer::operator=(const SharedPointer\u0026other) { std::cout 实现 根据shared_ptr的源码，能够大致实现SharedPointer类\ntemplateclass SharedPointer { public: explicit SharedPointer(T *t = nullptr, D *d = nullptr); ~SharedPointer(); T \u0026operator*(); T *operator-(); void reset(const SharedPointer \u0026other); void release(); SharedPointer(const SharedPointer \u0026other); SharedPointer \u0026operator=(const SharedPointer \u0026other); private: int *counter; T *pointer; D *deleter; }; templatevoid SharedPointer::reset(const SharedPointer\u0026other) { pointer = other.pointer; counter = other.counter; deleter = other.deleter; if (pointer) ++(*counter); } templatevoid SharedPointer::release() { if (pointer) { std::cout SharedPointer::SharedPointer(T *t, D *d): pointer(t), deleter(d) { if (pointer) counter = new int(1); else counter = nullptr; std::cout SharedPointer::SharedPointer(const SharedPointer\u0026other) { std::cout SharedPointer::~SharedPointer() { release(); } templateT \u0026SharedPointer::operator*() { return *pointer; } templateT *SharedPointer::operator-() { return pointer; } templateSharedPointer\u0026SharedPointer::operator=(const SharedPointer\u0026other) { std::cout 测试 尝试使用拷贝构造函数和赋值操作符使多个SharedPointer对象使用同一个指针，以及使用reset函数清空智能指针对象的指针\nint main() { Deleter *deleter = new Deleter(); Obj *o = new Obj(); SharedPointers1(o, deleter); SharedPointers2(s1); SharedPointers3; s3 = s1; return 0; } /* output: Construct SharedPointer 0x7ffeeebdda00 constructor called. SharedPointer 0x7ffeeebdd9e8 copy constructor called. SharedPointer 0x7ffeeebdd9d0 constructor called. SharedPointer 0x7ffeeebdd9d0 assignment operator called. SharedPointer 0x7ffeeebdd9d0 counter remains 3 SharedPointer 0x7ffeeebdd9e8 counter remains 2 SharedPointer 0x7ffeeebdda00 counter remains 1 SharedPointer 0x7ffeeebdda00 destructor called. Destruct */ 考虑如下一个类\nclass Object : public Obj { public: SharedPointerS; }; 创建两个Object类型的对象\nint main() { SharedPointers1(new Object()); SharedPointers2(new Object()); s1-S = s2; s2-S = s1; return 0; } /* output: Construct SharedPointer 0x7f88eac02ab0 constructor called. SharedPointer 0x7ffee0bfaa20 constructor called. Construct SharedPointer 0x7f88eac02ae0 constructor called. SharedPointer 0x7ffee0bfa9f8 constructor called. SharedPointer 0x7f88eac02ab0 assignment operator called. SharedPointer 0x7f88eac02ae0 assignment operator called. SharedPointer 0x7ffee0bfa9f8 counter remains 2 SharedPointer 0x7ffee0bfaa20 counter remains 2 */ 两个Object类型的指针都包含了一个SharedPointer类型的智能指针对象，但这两个指针又依赖于SharedPointer对象去进行销毁，导致最后s1和s2的计数器都不能减为0，从而不能正确地\u0008销毁指针，导致了内存泄漏。这种现象叫做交叉引用。\n总结 SharedPointer利用Reference counting（计数引用）解决了多个对象使用同一个指针时自动销毁指针的问题，但又会发生交叉引用时不能够正确销毁指针的问题。\u0008\nshared_pointer源码 templateclass _LIBCPP_TEMPLATE_VIS shared_ptr { public: typedef _Tp element_type; #if _LIBCPP_STD_VER  14 typedef weak_ptr weak_type; #endif private: element_type* __ptr_; __shared_weak_count* __cntrl_; struct __nat {int __for_bool_;}; public: _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT; _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT; templateexplicit shared_ptr(_Yp* __p, typename enable_if::value, __nat::type = __nat()); templateshared_ptr(_Yp* __p, _Dp __d, typename enable_if::value, __nat::type = __nat()); templateshared_ptr(_Yp* __p, _Dp __d, _Alloc __a, typename enable_if::value, __nat::type = __nat()); template shared_ptr(nullptr_t __p, _Dp __d); template shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a); template_LIBCPP_INLINE_VISIBILITY shared_ptr(const shared_ptr\u0026 __r, element_type* __p) _NOEXCEPT; _LIBCPP_INLINE_VISIBILITY shared_ptr(const shared_ptr\u0026 __r) _NOEXCEPT; template_LIBCPP_INLINE_VISIBILITY shared_ptr(const shared_ptr\u0026 __r, typename enable_if::value, __nat::type = __nat()) _NOEXCEPT; #ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES _LIBCPP_INLINE_VISIBILITY shared_ptr(shared_ptr\u0026\u0026 __r) _NOEXCEPT; template_LIBCPP_INLINE_VISIBILITY shared_ptr(shared_ptr\u0026\u0026 __r, typename enable_if::value, __nat::type = __nat()) _NOEXCEPT; #endif // _LIBCPP_HAS_NO_RVALUE_REFERENCES templateexplicit shared_ptr(const weak_ptr\u0026 __r, typename enable_if::value, __nat::type= __nat()); #if _LIBCPP_STD_VER shared_ptr(auto_ptr\u0026\u0026 __r, typename enable_if::value, __nat::type = __nat()); #else templateshared_ptr(auto_ptr __r, typename enable_if::value, __nat::type = __nat()); #endif #endif #ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES template shared_ptr(unique_ptr\u0026\u0026, typename enable_if ::value \u0026\u0026 !is_array::value \u0026\u0026 is_convertible::pointer, element_type*::value, __nat ::type = __nat()); template shared_ptr(unique_ptr\u0026\u0026, typename enable_if ::value \u0026\u0026 !is_array::value \u0026\u0026 is_convertible::pointer, element_type*::value, __nat ::type = __nat()); #else // _LIBCPP_HAS_NO_RVALUE_REFERENCES template shared_ptr(unique_ptr, typename enable_if ::value \u0026\u0026 !is_array::value \u0026\u0026 is_convertible::pointer, element_type*::value, __nat ::type = __nat()); template shared_ptr(unique_ptr, typename enable_if ::value \u0026\u0026 !is_array::value \u0026\u0026 is_convertible::pointer, element_type*::value, __nat ::type = __nat()); #endif // _LIBCPP_HAS_NO_RVALUE_REFERENCES ~shared_ptr(); _LIBCPP_INLINE_VISIBILITY shared_ptr\u0026 operator=(const shared_ptr\u0026 __r) _NOEXCEPT; templatetypename enable_if ::value, shared_ptr\u0026 ::type _LIBCPP_INLINE_VISIBILITY operator=(const shared_ptr\u0026 __r) _NOEXCEPT; #ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES _LIBCPP_INLINE_VISIBILITY shared_ptr\u0026 operator=(shared_ptr\u0026\u0026 __r) _NOEXCEPT; templatetypename enable_if ::value, shared_ptr\u0026 ::type _LIBCPP_INLINE_VISIBILITY operator=(shared_ptr\u0026\u0026 __r); #if _LIBCPP_STD_VER _LIBCPP_INLINE_VISIBILITY typename enable_if ::value \u0026\u0026 is_convertible::value, shared_ptr ::type\u0026 operator=(auto_ptr\u0026\u0026 __r); #endif #else // _LIBCPP_HAS_NO_RVALUE_REFERENCES #if _LIBCPP_STD_VER _LIBCPP_INLINE_VISIBILITY typename enable_if ::value \u0026\u0026 is_convertible::value, shared_ptr\u0026 ::type operator=(auto_ptr __r); #endif #endif template typename enable_if ::value \u0026\u0026 is_convertible::pointer, element_type*::value, shared_ptr\u0026 ::type #ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES _LIBCPP_INLINE_VISIBILITY operator=(unique_ptr\u0026\u0026 __r); #else // _LIBCPP_HAS_NO_RVALUE_REFERENCES _LIBCPP_INLINE_VISIBILITY operator=(unique_ptr__r); #endif _LIBCPP_INLINE_VISIBILITY void swap(shared_ptr\u0026 __r) _NOEXCEPT; _LIBCPP_INLINE_VISIBILITY void reset() _NOEXCEPT; templatetypename enable_if ::value, void ::type _LIBCPP_INLINE_VISIBILITY reset(_Yp* __p); templatetypename enable_if ::value, void ::type _LIBCPP_INLINE_VISIBILITY reset(_Yp* __p, _Dp __d); templatetypename enable_if ::value, void ::type _LIBCPP_INLINE_VISIBILITY reset(_Yp* __p, _Dp __d, _Alloc __a); _LIBCPP_INLINE_VISIBILITY element_type* get() const _NOEXCEPT {return __ptr_;} _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference::type operator*() const _NOEXCEPT {return *__ptr_;} _LIBCPP_INLINE_VISIBILITY element_type* operator-() const _NOEXCEPT {return __ptr_;} _LIBCPP_INLINE_VISIBILITY long use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_-use_count() : 0;} _LIBCPP_INLINE_VISIBILITY bool unique() const _NOEXCEPT {return use_count() == 1;} _LIBCPP_INLINE_VISIBILITY _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return get() != 0;} template _LIBCPP_INLINE_VISIBILITY bool owner_before(shared_ptr const\u0026 __p) const _NOEXCEPT {return __cntrl_ _LIBCPP_INLINE_VISIBILITY bool owner_before(weak_ptr const\u0026 __p) const _NOEXCEPT {return __cntrl_ _LIBCPP_INLINE_VISIBILITY _Dp* __get_deleter() const _NOEXCEPT {return static_cast(__cntrl_ ? const_cast(__cntrl_-__get_deleter(typeid(_Dp))) : nullptr);} #endif // _LIBCPP_NO_RTTI #ifndef _LIBCPP_HAS_NO_VARIADICS templatestatic shared_ptr make_shared(_Args\u0026\u0026 ...__args); templatestatic shared_ptr allocate_shared(const _Alloc\u0026 __a, _Args\u0026\u0026 ...__args); #else // _LIBCPP_HAS_NO_VARIADICS static shared_ptr make_shared(); templatestatic shared_ptr make_shared(_A0\u0026); templatestatic shared_ptr make_shared(_A0\u0026, _A1\u0026); templatestatic shared_ptr make_shared(_A0\u0026, _A1\u0026, _A2\u0026); templatestatic shared_ptr allocate_shared(const _Alloc\u0026 __a); templatestatic shared_ptr allocate_shared(const _Alloc\u0026 __a, _A0\u0026 __a0); templatestatic shared_ptr allocate_shared(const _Alloc\u0026 __a, _A0\u0026 __a0, _A1\u0026 __a1); templatestatic shared_ptr allocate_shared(const _Alloc\u0026 __a, _A0\u0026 __a0, _A1\u0026 __a1, _A2\u0026 __a2); #endif // _LIBCPP_HAS_NO_VARIADICS private: template ::value struct __shared_ptr_default_allocator { typedef allocator type; }; template struct __shared_ptr_default_allocator{ typedef allocator type; }; template _LIBCPP_INLINE_VISIBILITY typename enable_if* ::value, void::type __enable_weak_this(const enable_shared_from_this* __e, _OrigPtr* __ptr) _NOEXCEPT { typedef typename remove_cv::type _RawYp; if (__e \u0026\u0026 __e-__weak_this_.expired()) { __e-__weak_this_ = shared_ptr(*this, const_cast(static_cast(__ptr))); } } _LIBCPP_INLINE_VISIBILITY void __enable_weak_this(...) _NOEXCEPT {} template friend class _LIBCPP_TEMPLATE_VIS shared_ptr; template friend class _LIBCPP_TEMPLATE_VIS weak_ptr; }; ","wordCount":"1323","inLanguage":"en","datePublished":"2019-01-25T17:47:38+11:00","dateModified":"2019-01-25T17:47:38+11:00","author":{"@type":"Person","name":"Providence"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://example.org/posts/c++/smart-pointer/c++-smart-pointer-3/"},"publisher":{"@type":"Organization","name":"尾張","logo":{"@type":"ImageObject","url":"http://example.org/%3Clink%20/%20abs%20url%3E"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://example.org/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=http://example.org/archives/ title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=http://example.org/about/ title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=http://example.org/>Home</a>&nbsp;»&nbsp;<a href=http://example.org/posts/>Posts</a></div>
<h1 class=post-title>
C++ 智能指针（3）：shared_ptr
</h1>
<div class=post-meta><span title="2019-01-25 17:47:38 +1100 +1100">January 25, 2019</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Providence&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/C++/smart%20pointer/C++-Smart-Pointer-3.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header> <div class=toc>
<details open>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#c%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%883shared_ptr aria-label=C++智能指针（3）：shared_ptr>C++智能指针（3）：shared_ptr</a><ul>
<li>
<a href=#%e5%88%86%e6%9e%90 aria-label=分析>分析</a></li>
<li>
<a href=#%e5%ae%9e%e7%8e%b0 aria-label=实现>实现</a></li>
<li>
<a href=#%e6%b5%8b%e8%af%95 aria-label=测试>测试</a></li>
<li>
<a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li>
<li>
<a href=#shared_pointer%e6%ba%90%e7%a0%81 aria-label=shared_pointer源码>shared_pointer源码</a>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h1 id=c智能指针3shared_ptr>C++智能指针（3）：shared_ptr<a hidden class=anchor aria-hidden=true href=#c智能指针3shared_ptr>#</a></h1>
<h2 id=分析>分析<a hidden class=anchor aria-hidden=true href=#分析>#</a></h2>
<p>UniquePointer对象只能绑定单个指针，要实现指针的自动管理和销毁需要引入计数器</p>
<pre tabindex=0><code>private:
    int *counter;
    T *pointer;
    D *deleter;
</code></pre><p>计数器的主要作用是标识当前指针被几个智能指针对象所引用，在析构当前对象时，使其计数器自减1。如果计数器等于0，则表示已经没有其他的对象在使用当前指针，此时则可以销毁指针，计数器和删除器。</p>
<pre tabindex=0><code>template&lt;typename T, typename D&gt;
void SharedPointer&lt;T, D&gt;::release() {
    if (pointer) {
        std::cout &lt;&lt; &quot;SharedPointer &quot; &lt;&lt; this &lt;&lt; &quot; counter remains &quot; &lt;&lt; *counter &lt;&lt; std::endl;
        if (--(*counter) == 0) {
            std::cout &lt;&lt; &quot;SharedPointer &quot; &lt;&lt; this &lt;&lt; &quot; destructor called.&quot; &lt;&lt; std::endl;
            (*deleter)(pointer);
            (*deleter)(counter);
            (*deleter)(deleter);
            pointer = nullptr;
            counter = nullptr;
            deleter = nullptr;
        }
    }
}
</code></pre><p>reset函数将指针设为other的指针</p>
<pre tabindex=0><code>template&lt;typename T, typename D&gt;
void SharedPointer&lt;T, D&gt;::reset(const SharedPointer&lt;T, D&gt; &amp;other) {
    pointer = other.pointer;
    counter = other.counter;
    deleter = other.deleter;
    if (pointer)
        ++(*counter);
}
</code></pre><p>析构函数可以直接调用release函数</p>
<pre tabindex=0><code>template&lt;typename T, typename D&gt;
SharedPointer&lt;T, D&gt;::~SharedPointer() {
    release();
}
</code></pre><p>拷贝构造函数可以直接调用reset函数</p>
<pre tabindex=0><code>template&lt;typename T, typename D&gt;
SharedPointer&lt;T, D&gt;::SharedPointer(const SharedPointer&lt;T, D&gt; &amp;other) {
    std::cout &lt;&lt; &quot;SharedPointer &quot; &lt;&lt; this &lt;&lt; &quot; copy constructor called.&quot; &lt;&lt; std::endl;
    reset(other);
}
</code></pre><p>使用赋值操作符时先调用release函数，再调用reset函数</p>
<pre tabindex=0><code>template&lt;typename T, typename D&gt;
SharedPointer&lt;T, D&gt; &amp;SharedPointer&lt;T, D&gt;::operator=(const SharedPointer&lt;T, D&gt; &amp;other) {
    std::cout &lt;&lt; &quot;SharedPointer &quot; &lt;&lt; this &lt;&lt; &quot; assignment operator called.&quot; &lt;&lt; std::endl;
    if (this != &amp;other) {
        release();
        reset(other);
    }
    return *this;
}
</code></pre><h2 id=实现>实现<a hidden class=anchor aria-hidden=true href=#实现>#</a></h2>
<p>根据shared_ptr的源码，能够大致实现SharedPointer类</p>
<pre tabindex=0><code>template&lt;typename T, typename D&gt;
class SharedPointer {
public:
    explicit SharedPointer(T *t = nullptr, D *d = nullptr);

    ~SharedPointer();

    T &amp;operator*();

    T *operator-&gt;();

    void reset(const SharedPointer &amp;other);

    void release();

    SharedPointer(const SharedPointer &amp;other);

    SharedPointer &amp;operator=(const SharedPointer &amp;other);

private:

    int *counter;
    T *pointer;
    D *deleter;
};

template&lt;typename T, typename D&gt;
void SharedPointer&lt;T, D&gt;::reset(const SharedPointer&lt;T, D&gt; &amp;other) {
    pointer = other.pointer;
    counter = other.counter;
    deleter = other.deleter;
    if (pointer)
        ++(*counter);
}

template&lt;typename T, typename D&gt;
void SharedPointer&lt;T, D&gt;::release() {
    if (pointer) {
        std::cout &lt;&lt; &quot;SharedPointer &quot; &lt;&lt; this &lt;&lt; &quot; counter remains &quot; &lt;&lt; *counter &lt;&lt; std::endl;
        if (--(*counter) == 0) {
            std::cout &lt;&lt; &quot;SharedPointer &quot; &lt;&lt; this &lt;&lt; &quot; destructor called.&quot; &lt;&lt; std::endl;
            (*deleter)(pointer);
            (*deleter)(counter);
            (*deleter)(deleter);
            pointer = nullptr;
            counter = nullptr;
            deleter = nullptr;
        }
    }
}

template&lt;typename T, typename D&gt;
SharedPointer&lt;T, D&gt;::SharedPointer(T *t, D *d): pointer(t), deleter(d) {
    if (pointer)
        counter = new int(1);
    else
        counter = nullptr;
    std::cout &lt;&lt; &quot;SharedPointer &quot; &lt;&lt; this &lt;&lt; &quot; constructor called.&quot; &lt;&lt; std::endl;
}

template&lt;typename T, typename D&gt;
SharedPointer&lt;T, D&gt;::SharedPointer(const SharedPointer&lt;T, D&gt; &amp;other) {
    std::cout &lt;&lt; &quot;SharedPointer &quot; &lt;&lt; this &lt;&lt; &quot; copy constructor called.&quot; &lt;&lt; std::endl;
    reset(other);
}


template&lt;typename T, typename D&gt;
SharedPointer&lt;T, D&gt;::~SharedPointer() {
    release();
}

template&lt;typename T, typename D&gt;
T &amp;SharedPointer&lt;T, D&gt;::operator*() {
    return *pointer;
}

template&lt;typename T, typename D&gt;
T *SharedPointer&lt;T, D&gt;::operator-&gt;() {
    return pointer;
}

template&lt;typename T, typename D&gt;
SharedPointer&lt;T, D&gt; &amp;SharedPointer&lt;T, D&gt;::operator=(const SharedPointer&lt;T, D&gt; &amp;other) {
    std::cout &lt;&lt; &quot;SharedPointer &quot; &lt;&lt; this &lt;&lt; &quot; assignment operator called.&quot; &lt;&lt; std::endl;
    if (this != &amp;other) {
        release();
        reset(other);
    }
    return *this;
}
</code></pre><h2 id=测试>测试<a hidden class=anchor aria-hidden=true href=#测试>#</a></h2>
<p>尝试使用拷贝构造函数和赋值操作符使多个SharedPointer对象使用同一个指针，以及使用reset函数清空智能指针对象的指针</p>
<pre tabindex=0><code>int main() {
    Deleter *deleter = new Deleter();
    Obj *o = new Obj();
    SharedPointer&lt;Obj, Deleter&gt; s1(o, deleter);
    SharedPointer&lt;Obj, Deleter&gt; s2(s1);
    SharedPointer&lt;Obj, Deleter&gt; s3;
    s3 = s1;
    return 0;
}
/*
output:
Construct
SharedPointer 0x7ffeeebdda00 constructor called.
SharedPointer 0x7ffeeebdd9e8 copy constructor called.
SharedPointer 0x7ffeeebdd9d0 constructor called.
SharedPointer 0x7ffeeebdd9d0 assignment operator called.
SharedPointer 0x7ffeeebdd9d0 counter remains 3
SharedPointer 0x7ffeeebdd9e8 counter remains 2
SharedPointer 0x7ffeeebdda00 counter remains 1
SharedPointer 0x7ffeeebdda00 destructor called.
Destruct
*/
</code></pre><p>考虑如下一个类</p>
<pre tabindex=0><code>class Object : public Obj {
public:
    SharedPointer&lt;Object, Deleter&gt; S;
};
</code></pre><p>创建两个Object类型的对象</p>
<pre tabindex=0><code>int main() {
    SharedPointer&lt;Object, Deleter&gt; s1(new Object());
    SharedPointer&lt;Object, Deleter&gt; s2(new Object());
    s1-&gt;S = s2;
    s2-&gt;S = s1;
    return 0;
}
/*
output:
Construct
SharedPointer 0x7f88eac02ab0 constructor called.
SharedPointer 0x7ffee0bfaa20 constructor called.
Construct
SharedPointer 0x7f88eac02ae0 constructor called.
SharedPointer 0x7ffee0bfa9f8 constructor called.
SharedPointer 0x7f88eac02ab0 assignment operator called.
SharedPointer 0x7f88eac02ae0 assignment operator called.
SharedPointer 0x7ffee0bfa9f8 counter remains 2
SharedPointer 0x7ffee0bfaa20 counter remains 2
*/
</code></pre><p>两个Object类型的指针都包含了一个SharedPointer类型的智能指针对象，但这两个指针又依赖于SharedPointer对象去进行销毁，导致最后s1和s2的计数器都不能减为0，从而不能正确地销毁指针，导致了内存泄漏。这种现象叫做交叉引用。</p>
<h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2>
<p>SharedPointer利用<a href=https://en.wikipedia.org/wiki/Reference_counting>Reference counting</a>（计数引用）解决了多个对象使用同一个指针时自动销毁指针的问题，但又会发生交叉引用时不能够正确销毁指针的问题。</p>
<h2 id=shared_pointer源码>shared_pointer源码<a hidden class=anchor aria-hidden=true href=#shared_pointer源码>#</a></h2>
<pre tabindex=0><code>template&lt;class _Tp&gt;
class _LIBCPP_TEMPLATE_VIS shared_ptr
{
public:
    typedef _Tp element_type;

#if _LIBCPP_STD_VER &gt; 14
    typedef weak_ptr&lt;_Tp&gt; weak_type;
#endif
private:
    element_type*      __ptr_;
    __shared_weak_count* __cntrl_;

    struct __nat {int __for_bool_;};
public:
    _LIBCPP_INLINE_VISIBILITY
    _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT;
    _LIBCPP_INLINE_VISIBILITY
    _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT;
    template&lt;class _Yp&gt;
        explicit shared_ptr(_Yp* __p,
                            typename enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type = __nat());
    template&lt;class _Yp, class _Dp&gt;
        shared_ptr(_Yp* __p, _Dp __d,
                   typename enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type = __nat());
    template&lt;class _Yp, class _Dp, class _Alloc&gt;
        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,
                   typename enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type = __nat());
    template &lt;class _Dp&gt; shared_ptr(nullptr_t __p, _Dp __d);
    template &lt;class _Dp, class _Alloc&gt; shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);
    template&lt;class _Yp&gt; _LIBCPP_INLINE_VISIBILITY shared_ptr(const shared_ptr&lt;_Yp&gt;&amp; __r, element_type* __p) _NOEXCEPT;
    _LIBCPP_INLINE_VISIBILITY
    shared_ptr(const shared_ptr&amp; __r) _NOEXCEPT;
    template&lt;class _Yp&gt;
        _LIBCPP_INLINE_VISIBILITY
        shared_ptr(const shared_ptr&lt;_Yp&gt;&amp; __r,
                   typename enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type = __nat())
                       _NOEXCEPT;
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
    _LIBCPP_INLINE_VISIBILITY
    shared_ptr(shared_ptr&amp;&amp; __r) _NOEXCEPT;
    template&lt;class _Yp&gt; _LIBCPP_INLINE_VISIBILITY  shared_ptr(shared_ptr&lt;_Yp&gt;&amp;&amp; __r,
                   typename enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type = __nat())
                       _NOEXCEPT;
#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
    template&lt;class _Yp&gt; explicit shared_ptr(const weak_ptr&lt;_Yp&gt;&amp; __r,
                   typename enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type= __nat());
#if _LIBCPP_STD_VER &lt;= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
    template&lt;class _Yp&gt;
        shared_ptr(auto_ptr&lt;_Yp&gt;&amp;&amp; __r,
                   typename enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type = __nat());
#else
    template&lt;class _Yp&gt;
        shared_ptr(auto_ptr&lt;_Yp&gt; __r,
                   typename enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type = __nat());
#endif
#endif
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
    template &lt;class _Yp, class _Dp&gt;
        shared_ptr(unique_ptr&lt;_Yp, _Dp&gt;&amp;&amp;,
                   typename enable_if
                   &lt;
                       !is_lvalue_reference&lt;_Dp&gt;::value &amp;&amp;
                       !is_array&lt;_Yp&gt;::value &amp;&amp;
                       is_convertible&lt;typename unique_ptr&lt;_Yp, _Dp&gt;::pointer, element_type*&gt;::value,
                       __nat
                   &gt;::type = __nat());
    template &lt;class _Yp, class _Dp&gt;
        shared_ptr(unique_ptr&lt;_Yp, _Dp&gt;&amp;&amp;,
                   typename enable_if
                   &lt;
                       is_lvalue_reference&lt;_Dp&gt;::value &amp;&amp;
                       !is_array&lt;_Yp&gt;::value &amp;&amp;
                       is_convertible&lt;typename unique_ptr&lt;_Yp, _Dp&gt;::pointer, element_type*&gt;::value,
                       __nat
                   &gt;::type = __nat());
#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
    template &lt;class _Yp, class _Dp&gt;
        shared_ptr(unique_ptr&lt;_Yp, _Dp&gt;,
                   typename enable_if
                   &lt;
                       !is_lvalue_reference&lt;_Dp&gt;::value &amp;&amp;
                       !is_array&lt;_Yp&gt;::value &amp;&amp;
                       is_convertible&lt;typename unique_ptr&lt;_Yp, _Dp&gt;::pointer, element_type*&gt;::value,
                       __nat
                   &gt;::type = __nat());
    template &lt;class _Yp, class _Dp&gt;
        shared_ptr(unique_ptr&lt;_Yp, _Dp&gt;,
                   typename enable_if
                   &lt;
                       is_lvalue_reference&lt;_Dp&gt;::value &amp;&amp;
                       !is_array&lt;_Yp&gt;::value &amp;&amp;
                       is_convertible&lt;typename unique_ptr&lt;_Yp, _Dp&gt;::pointer, element_type*&gt;::value,
                       __nat
                   &gt;::type = __nat());
#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES

    ~shared_ptr();

    _LIBCPP_INLINE_VISIBILITY
    shared_ptr&amp; operator=(const shared_ptr&amp; __r) _NOEXCEPT;
    template&lt;class _Yp&gt;
        typename enable_if
        &lt;
            is_convertible&lt;_Yp*, element_type*&gt;::value,
            shared_ptr&amp;
        &gt;::type
        _LIBCPP_INLINE_VISIBILITY
        operator=(const shared_ptr&lt;_Yp&gt;&amp; __r) _NOEXCEPT;
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
    _LIBCPP_INLINE_VISIBILITY
    shared_ptr&amp; operator=(shared_ptr&amp;&amp; __r) _NOEXCEPT;
    template&lt;class _Yp&gt;
        typename enable_if
        &lt;
            is_convertible&lt;_Yp*, element_type*&gt;::value,
            shared_ptr&lt;_Tp&gt;&amp;
        &gt;::type
        _LIBCPP_INLINE_VISIBILITY
        operator=(shared_ptr&lt;_Yp&gt;&amp;&amp; __r);
#if _LIBCPP_STD_VER &lt;= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
    template&lt;class _Yp&gt;
        _LIBCPP_INLINE_VISIBILITY
        typename enable_if
        &lt;
            !is_array&lt;_Yp&gt;::value &amp;&amp;
            is_convertible&lt;_Yp*, element_type*&gt;::value,
            shared_ptr
        &gt;::type&amp;
        operator=(auto_ptr&lt;_Yp&gt;&amp;&amp; __r);
#endif
#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
#if _LIBCPP_STD_VER &lt;= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
    template&lt;class _Yp&gt;
        _LIBCPP_INLINE_VISIBILITY
        typename enable_if
        &lt;
            !is_array&lt;_Yp&gt;::value &amp;&amp;
            is_convertible&lt;_Yp*, element_type*&gt;::value,
            shared_ptr&amp;
        &gt;::type
        operator=(auto_ptr&lt;_Yp&gt; __r);
#endif
#endif
    template &lt;class _Yp, class _Dp&gt;
        typename enable_if
        &lt;
            !is_array&lt;_Yp&gt;::value &amp;&amp;
            is_convertible&lt;typename unique_ptr&lt;_Yp, _Dp&gt;::pointer, element_type*&gt;::value,
            shared_ptr&amp;
        &gt;::type
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        _LIBCPP_INLINE_VISIBILITY
        operator=(unique_ptr&lt;_Yp, _Dp&gt;&amp;&amp; __r);
#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        _LIBCPP_INLINE_VISIBILITY
        operator=(unique_ptr&lt;_Yp, _Dp&gt; __r);
#endif

    _LIBCPP_INLINE_VISIBILITY
    void swap(shared_ptr&amp; __r) _NOEXCEPT;
    _LIBCPP_INLINE_VISIBILITY
    void reset() _NOEXCEPT;
    template&lt;class _Yp&gt;
        typename enable_if
        &lt;
            is_convertible&lt;_Yp*, element_type*&gt;::value,
            void
        &gt;::type
        _LIBCPP_INLINE_VISIBILITY
        reset(_Yp* __p);
    template&lt;class _Yp, class _Dp&gt;
        typename enable_if
        &lt;
            is_convertible&lt;_Yp*, element_type*&gt;::value,
            void
        &gt;::type
        _LIBCPP_INLINE_VISIBILITY
        reset(_Yp* __p, _Dp __d);
    template&lt;class _Yp, class _Dp, class _Alloc&gt;
        typename enable_if
        &lt;
            is_convertible&lt;_Yp*, element_type*&gt;::value,
            void
        &gt;::type
        _LIBCPP_INLINE_VISIBILITY
        reset(_Yp* __p, _Dp __d, _Alloc __a);

    _LIBCPP_INLINE_VISIBILITY
    element_type* get() const _NOEXCEPT {return __ptr_;}
    _LIBCPP_INLINE_VISIBILITY
    typename add_lvalue_reference&lt;element_type&gt;::type operator*() const _NOEXCEPT
        {return *__ptr_;}
    _LIBCPP_INLINE_VISIBILITY
    element_type* operator-&gt;() const _NOEXCEPT {return __ptr_;}
    _LIBCPP_INLINE_VISIBILITY
    long use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_-&gt;use_count() : 0;}
    _LIBCPP_INLINE_VISIBILITY
    bool unique() const _NOEXCEPT {return use_count() == 1;}
    _LIBCPP_INLINE_VISIBILITY
    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return get() != 0;}
    template &lt;class _Up&gt;
        _LIBCPP_INLINE_VISIBILITY
        bool owner_before(shared_ptr&lt;_Up&gt; const&amp; __p) const _NOEXCEPT
        {return __cntrl_ &lt; __p.__cntrl_;}
    template &lt;class _Up&gt;
        _LIBCPP_INLINE_VISIBILITY
        bool owner_before(weak_ptr&lt;_Up&gt; const&amp; __p) const _NOEXCEPT
        {return __cntrl_ &lt; __p.__cntrl_;}
    _LIBCPP_INLINE_VISIBILITY
    bool
    __owner_equivalent(const shared_ptr&amp; __p) const
        {return __cntrl_ == __p.__cntrl_;}

#ifndef _LIBCPP_NO_RTTI
    template &lt;class _Dp&gt;
        _LIBCPP_INLINE_VISIBILITY
        _Dp* __get_deleter() const _NOEXCEPT
            {return static_cast&lt;_Dp*&gt;(__cntrl_
                    ? const_cast&lt;void *&gt;(__cntrl_-&gt;__get_deleter(typeid(_Dp)))
                      : nullptr);}
#endif  // _LIBCPP_NO_RTTI

#ifndef _LIBCPP_HAS_NO_VARIADICS

    template&lt;class ..._Args&gt;
        static
        shared_ptr&lt;_Tp&gt;
        make_shared(_Args&amp;&amp; ...__args);

    template&lt;class _Alloc, class ..._Args&gt;
        static
        shared_ptr&lt;_Tp&gt;
        allocate_shared(const _Alloc&amp; __a, _Args&amp;&amp; ...__args);

#else  // _LIBCPP_HAS_NO_VARIADICS

    static shared_ptr&lt;_Tp&gt; make_shared();

    template&lt;class _A0&gt;
        static shared_ptr&lt;_Tp&gt; make_shared(_A0&amp;);

    template&lt;class _A0, class _A1&gt;
        static shared_ptr&lt;_Tp&gt; make_shared(_A0&amp;, _A1&amp;);

    template&lt;class _A0, class _A1, class _A2&gt;
        static shared_ptr&lt;_Tp&gt; make_shared(_A0&amp;, _A1&amp;, _A2&amp;);

    template&lt;class _Alloc&gt;
        static shared_ptr&lt;_Tp&gt;
        allocate_shared(const _Alloc&amp; __a);

    template&lt;class _Alloc, class _A0&gt;
        static shared_ptr&lt;_Tp&gt;
        allocate_shared(const _Alloc&amp; __a, _A0&amp; __a0);

    template&lt;class _Alloc, class _A0, class _A1&gt;
        static shared_ptr&lt;_Tp&gt;
        allocate_shared(const _Alloc&amp; __a, _A0&amp; __a0, _A1&amp; __a1);

    template&lt;class _Alloc, class _A0, class _A1, class _A2&gt;
        static shared_ptr&lt;_Tp&gt;
        allocate_shared(const _Alloc&amp; __a, _A0&amp; __a0, _A1&amp; __a1, _A2&amp; __a2);

#endif  // _LIBCPP_HAS_NO_VARIADICS

private:
    template &lt;class _Yp, bool = is_function&lt;_Yp&gt;::value&gt;
        struct __shared_ptr_default_allocator
        {
            typedef allocator&lt;_Yp&gt; type;
        };

    template &lt;class _Yp&gt;
        struct __shared_ptr_default_allocator&lt;_Yp, true&gt;
        {
            typedef allocator&lt;__shared_ptr_dummy_rebind_allocator_type&gt; type;
        };

    template &lt;class _Yp, class _OrigPtr&gt;
        _LIBCPP_INLINE_VISIBILITY
        typename enable_if&lt;is_convertible&lt;_OrigPtr*,
                                          const enable_shared_from_this&lt;_Yp&gt;*
        &gt;::value,
            void&gt;::type
        __enable_weak_this(const enable_shared_from_this&lt;_Yp&gt;* __e,
                           _OrigPtr* __ptr) _NOEXCEPT
        {
            typedef typename remove_cv&lt;_Yp&gt;::type _RawYp;
            if (__e &amp;&amp; __e-&gt;__weak_this_.expired())
            {
                __e-&gt;__weak_this_ = shared_ptr&lt;_RawYp&gt;(*this,
                    const_cast&lt;_RawYp*&gt;(static_cast&lt;const _Yp*&gt;(__ptr)));
            }
        }

    _LIBCPP_INLINE_VISIBILITY void __enable_weak_this(...) _NOEXCEPT {}

    template &lt;class _Up&gt; friend class _LIBCPP_TEMPLATE_VIS shared_ptr;
    template &lt;class _Up&gt; friend class _LIBCPP_TEMPLATE_VIS weak_ptr;
};
</code></pre>
</div>
<footer class=post-footer>
<nav class=paginav>
<a class=prev href=http://example.org/posts/deep-learning/methods-to-prevent-overfitting-in-deep-learning/>
<span class=title>« Prev Page</span>
<br>
<span>Methods to Prevent Overfitting in Deep Learning</span>
</a>
<a class=next href=http://example.org/posts/c++/smart-pointer/c++-smart-pointer-2/>
<span class=title>Next Page »</span>
<br>
<span>C++ 智能指针（2）：unique_ptr</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share C++ 智能指针（3）：shared_ptr on twitter" href="https://twitter.com/intent/tweet/?text=C%2b%2b%20%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88%ef%bc%883%ef%bc%89%ef%bc%9ashared_ptr&url=http%3a%2f%2fexample.org%2fposts%2fc%2b%2b%2fsmart-pointer%2fc%2b%2b-smart-pointer-3%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share C++ 智能指针（3）：shared_ptr on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fexample.org%2fposts%2fc%2b%2b%2fsmart-pointer%2fc%2b%2b-smart-pointer-3%2f&title=C%2b%2b%20%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88%ef%bc%883%ef%bc%89%ef%bc%9ashared_ptr&summary=C%2b%2b%20%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88%ef%bc%883%ef%bc%89%ef%bc%9ashared_ptr&source=http%3a%2f%2fexample.org%2fposts%2fc%2b%2b%2fsmart-pointer%2fc%2b%2b-smart-pointer-3%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share C++ 智能指针（3）：shared_ptr on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fexample.org%2fposts%2fc%2b%2b%2fsmart-pointer%2fc%2b%2b-smart-pointer-3%2f&title=C%2b%2b%20%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88%ef%bc%883%ef%bc%89%ef%bc%9ashared_ptr"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share C++ 智能指针（3）：shared_ptr on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fexample.org%2fposts%2fc%2b%2b%2fsmart-pointer%2fc%2b%2b-smart-pointer-3%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share C++ 智能指针（3）：shared_ptr on whatsapp" href="https://api.whatsapp.com/send?text=C%2b%2b%20%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88%ef%bc%883%ef%bc%89%ef%bc%9ashared_ptr%20-%20http%3a%2f%2fexample.org%2fposts%2fc%2b%2b%2fsmart-pointer%2fc%2b%2b-smart-pointer-3%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share C++ 智能指针（3）：shared_ptr on telegram" href="https://telegram.me/share/url?text=C%2b%2b%20%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88%ef%bc%883%ef%bc%89%ef%bc%9ashared_ptr&url=http%3a%2f%2fexample.org%2fposts%2fc%2b%2b%2fsmart-pointer%2fc%2b%2b-smart-pointer-3%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=http://example.org/>尾張</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>