<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 尾張</title>
    <link>https://zintrulcre.vip/posts/</link>
    <description>Recent content in Posts on 尾張</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Thu, 24 Sep 2020 16:43:27 +0800</lastBuildDate><atom:link href="https://zintrulcre.vip/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Effective C&#43;&#43; notes</title>
      <link>https://zintrulcre.vip/posts/c&#43;&#43;/%E5%9F%BA%E7%A1%80/effective-cpp/</link>
      <pubDate>Thu, 24 Sep 2020 16:43:27 +0800</pubDate>
      
      <guid>https://zintrulcre.vip/posts/c&#43;&#43;/%E5%9F%BA%E7%A1%80/effective-cpp/</guid>
      <description>Effective C++ 笔记 [TOC] 0 导言 1 构造函数 default 构造函数：可被调用而不带任何实参的构造函数，这样的构造函数要么没有参数，要么每个参数都带有默认值，例如 class Bar { public: //</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 单例模式的模板实现</title>
      <link>https://zintrulcre.vip/posts/design-pattern/c&#43;&#43;-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Thu, 10 Sep 2020 21:25:43 +0800</pubDate>
      
      <guid>https://zintrulcre.vip/posts/design-pattern/c&#43;&#43;-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0/</guid>
      <description>C++ 单例模式的模板实现 单例模式是一种创建型的设计模式（creational design patterns），使用单例模式进行设计的类在程序中只拥有一个实例</description>
    </item>
    
    <item>
      <title>并行计算入门</title>
      <link>https://zintrulcre.vip/posts/parallel-computing/parallel-computing/</link>
      <pubDate>Wed, 12 Aug 2020 18:32:52 +0800</pubDate>
      
      <guid>https://zintrulcre.vip/posts/parallel-computing/parallel-computing/</guid>
      <description>并行计算入门 [TOC] 1 概述 1.1 并行计算 高性能计算（High Performance Computing）是计算机科学中的一个领域，其目的可以概括为优化性能，它包括了缓存技术</description>
    </item>
    
    <item>
      <title>boost::typeIndex 的相关探究</title>
      <link>https://zintrulcre.vip/posts/c&#43;&#43;/boost/boost.typeindex-%E7%9A%84%E7%9B%B8%E5%85%B3%E6%8E%A2%E7%A9%B6/</link>
      <pubDate>Fri, 31 Jul 2020 20:31:06 +0800</pubDate>
      
      <guid>https://zintrulcre.vip/posts/c&#43;&#43;/boost/boost.typeindex-%E7%9A%84%E7%9B%B8%E5%85%B3%E6%8E%A2%E7%A9%B6/</guid>
      <description>boost::typeIndex 的相关探究 Effective Modern C++ 的 Item 4: Know how to view deduced types. 中提到了 Boost::typeindex 的使用，但并没有讲到其实现原理。 1. typeid 操作符 typeid 是 C++ 中的一个操作符，可以用于获取类型的信息，常常用</description>
    </item>
    
    <item>
      <title>CMake 入门</title>
      <link>https://zintrulcre.vip/posts/c&#43;&#43;/%E7%BC%96%E8%AF%91/cmake/</link>
      <pubDate>Sun, 21 Jun 2020 15:46:06 +0800</pubDate>
      
      <guid>https://zintrulcre.vip/posts/c&#43;&#43;/%E7%BC%96%E8%AF%91/cmake/</guid>
      <description>CMake 入门 0. 序 CMake 是一个跨平台的开源构建工具，使用 CMake 能够方便地管理依赖多个库的目录层次结构并生成 makefile 和使用 GNU make 来编译和连接程序。 1. 构建单个文件 1.1 使用</description>
    </item>
    
    <item>
      <title>GDB 调试入门</title>
      <link>https://zintrulcre.vip/posts/c&#43;&#43;/%E7%BC%96%E8%AF%91/gdb/</link>
      <pubDate>Wed, 22 Apr 2020 17:46:06 +0800</pubDate>
      
      <guid>https://zintrulcre.vip/posts/c&#43;&#43;/%E7%BC%96%E8%AF%91/gdb/</guid>
      <description>GDB 调试入门 0. 序 调试程序是开发过程中必不可少的一环，在 Windows 或 MacOS 上开发时，可以使用 VS 和 CLion 等 IDE 上自带的调试功能来打断点或查看变量和堆栈，但 Linux 并没有图</description>
    </item>
    
    <item>
      <title>coverity 的 WRAPPER_ESCAPE 告警</title>
      <link>https://zintrulcre.vip/posts/c&#43;&#43;/%E5%9F%BA%E7%A1%80/wrapper_escape-in-coverity/</link>
      <pubDate>Sun, 15 Mar 2020 17:24:27 +0800</pubDate>
      
      <guid>https://zintrulcre.vip/posts/c&#43;&#43;/%E5%9F%BA%E7%A1%80/wrapper_escape-in-coverity/</guid>
      <description>coverity 的 WRAPPER_ESCAPE 告警 const char* Foo() { std::string str_msg(&amp;#34;test&amp;#34;); return str_msg.c_str(); } int main() { const char *p_msg = Foo(); printf(&amp;#34;%s\n&amp;#34;, p_msg); return 0; } // output:（为空，或乱码） D? 上面代码中的 Foo 函数会被 coverity 报告 WRAPPER_ESCA</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 协程（1）：函数和协程</title>
      <link>https://zintrulcre.vip/posts/c&#43;&#43;/%E5%8D%8F%E7%A8%8B/c&#43;&#43;-%E5%8D%8F%E7%A8%8B1%E5%87%BD%E6%95%B0%E5%92%8C%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Mon, 20 Jan 2020 20:15:05 +0800</pubDate>
      
      <guid>https://zintrulcre.vip/posts/c&#43;&#43;/%E5%8D%8F%E7%A8%8B/c&#43;&#43;-%E5%8D%8F%E7%A8%8B1%E5%87%BD%E6%95%B0%E5%92%8C%E5%8D%8F%E7%A8%8B/</guid>
      <description>C++ 协程（1）：函数和协程 这篇文章的目的是探究 C++ 中协程的机制和用法，以及怎样利用协程的特性来构建上层的库和应用。 1. 栈帧和函数 栈帧是一个函数执行</description>
    </item>
    
    <item>
      <title>LeetCode 树（3）</title>
      <link>https://zintrulcre.vip/posts/leetcode/tree-3/</link>
      <pubDate>Sat, 24 Aug 2019 19:12:25 +1000</pubDate>
      
      <guid>https://zintrulcre.vip/posts/leetcode/tree-3/</guid>
      <description>LeetCode 树（3） 题目 4. 递归求解 617 合并二叉树 合并两个二叉树。 判断各个节点是否存在，全部合并到一棵树上即可。 class Solution { public: TreeNode *mergeTrees(TreeNode *t1, TreeNode *t2) { if (!t1 &amp;amp;&amp;amp; !t2) return nullptr; else if (!t1) return t2;</description>
    </item>
    
    <item>
      <title>LeetCode 排序</title>
      <link>https://zintrulcre.vip/posts/leetcode/sort/</link>
      <pubDate>Sat, 17 Aug 2019 19:12:25 +1000</pubDate>
      
      <guid>https://zintrulcre.vip/posts/leetcode/sort/</guid>
      <description>LeetCode 排序 题目 56 合并区间 按照间隔的起始进行排序，判断下一个间隔的起始是否大于前一个间隔的末尾，如果大于的话就把之前的间隔加入结果数组，否则继续扩</description>
    </item>
    
  </channel>
</rss>
