<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 尾張</title>
    <link>https://zintrulcre.vip/posts/</link>
    <description>Recent content in Posts on 尾張</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Mon, 26 Apr 2021 21:44:52 +0800</lastBuildDate><atom:link href="https://zintrulcre.vip/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ProtoBuf 语法和编码原理入门</title>
      <link>https://zintrulcre.vip/posts/serialization/protocol-buffer/</link>
      <pubDate>Mon, 26 Apr 2021 21:44:52 +0800</pubDate>
      
      <guid>https://zintrulcre.vip/posts/serialization/protocol-buffer/</guid>
      <description>ProtoBuf 语法和编码原理入门 [toc] 序列化是指将结构化数据转换成易于存储或发送的数据格式的过程，Protocol Buffer 简称 ProtoBuf，是一种语言无关，平</description>
    </item>
    
    <item>
      <title>Python 源码学习（2）：int 类型</title>
      <link>https://zintrulcre.vip/posts/python/source-code-2/</link>
      <pubDate>Wed, 31 Mar 2021 15:37:52 +0800</pubDate>
      
      <guid>https://zintrulcre.vip/posts/python/source-code-2/</guid>
      <description>Python 源码学习（2）：int 类型 [TOC] Python 中的标准数据类型有六种，分别是 number, string, list, tuple, set, dictionary，前文已经阐述过它们的对象类型都是继承了 PyBaseObject_Type 类型的</description>
    </item>
    
    <item>
      <title>Python 源码学习（1）：类型和对象</title>
      <link>https://zintrulcre.vip/posts/python/source-code-1/</link>
      <pubDate>Sun, 14 Mar 2021 16:05:52 +0800</pubDate>
      
      <guid>https://zintrulcre.vip/posts/python/source-code-1/</guid>
      <description>Python 源码学习（1）：类型和对象 [TOC] Python 是一门解释型，动态类型，多范式的编程语言，当我们从 python.org 下载并安装运行 Python 的某个分发版本时，我们实际上是在运行由 C</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 智能指针的简单实现</title>
      <link>https://zintrulcre.vip/posts/c&#43;&#43;/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart-pointer/</link>
      <pubDate>Sun, 21 Feb 2021 21:20:18 +0800</pubDate>
      
      <guid>https://zintrulcre.vip/posts/c&#43;&#43;/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/smart-pointer/</guid>
      <description>C++ 智能指针的简单实现 [TOC] 1 std::auto_ptr C++ 中经常会出现因为没有 delete 指针而造成的内存泄漏，例如有一个 Object 模板类： template&amp;lt;typename T&amp;gt; class Object { public: // constructor Object() : t_() { cout &amp;lt;&amp;lt; &amp;#34;Object::Constructor &amp;#34; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; endl; } Object(T t) :</description>
    </item>
    
    <item>
      <title>负载均衡和一致性哈希</title>
      <link>https://zintrulcre.vip/posts/service-governance/load-balancing/</link>
      <pubDate>Sun, 25 Oct 2020 23:06:52 +0800</pubDate>
      
      <guid>https://zintrulcre.vip/posts/service-governance/load-balancing/</guid>
      <description>负载均衡和一致性哈希 [TOC] 反向代理 reverse proxy 是指以代理服务器来接收由客户端发送来的请求，并通过一定的策略将其转变发给实际处理请求的后端服务器；主要应用</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 并发入门：以 LeetCode 1114 为例</title>
      <link>https://zintrulcre.vip/posts/c&#43;&#43;/concurrency/introduction-to-concurrency/</link>
      <pubDate>Wed, 30 Sep 2020 16:20:25 +0800</pubDate>
      
      <guid>https://zintrulcre.vip/posts/c&#43;&#43;/concurrency/introduction-to-concurrency/</guid>
      <description>C++ 并发入门：以 LeetCode 1114 为例 [toc] 题目 直接做题：1114 按序打印 解法 1. std::mutex 如果你对 c++ 11 略为熟悉的话，应该能够想到用 std::mutex 来解这道题，在函数构造时（主线程）对</description>
    </item>
    
    <item>
      <title>Effective C&#43;&#43; notes</title>
      <link>https://zintrulcre.vip/posts/c&#43;&#43;/%E5%9F%BA%E7%A1%80/effective-cpp/</link>
      <pubDate>Thu, 24 Sep 2020 16:43:27 +0800</pubDate>
      
      <guid>https://zintrulcre.vip/posts/c&#43;&#43;/%E5%9F%BA%E7%A1%80/effective-cpp/</guid>
      <description>Effective C++ 笔记 [TOC] 0 导言 1 构造函数 default 构造函数：可被调用而不带任何实参的构造函数，这样的构造函数要么没有参数，要么每个参数都带有默认值，例如 class Bar { public: //</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 单例模式的模板实现</title>
      <link>https://zintrulcre.vip/posts/design-pattern/c&#43;&#43;-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Thu, 10 Sep 2020 21:25:43 +0800</pubDate>
      
      <guid>https://zintrulcre.vip/posts/design-pattern/c&#43;&#43;-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0/</guid>
      <description>C++ 单例模式的模板实现 单例模式是一种创建型的设计模式（creational design patterns），使用单例模式进行设计的类在程序中只拥有一个实例</description>
    </item>
    
    <item>
      <title>并行计算入门</title>
      <link>https://zintrulcre.vip/posts/parallel-computing/parallel-computing/</link>
      <pubDate>Wed, 12 Aug 2020 18:32:52 +0800</pubDate>
      
      <guid>https://zintrulcre.vip/posts/parallel-computing/parallel-computing/</guid>
      <description>并行计算入门 [TOC] 1 概述 1.1 并行计算 高性能计算（High Performance Computing）是计算机科学中的一个领域，其目的可以概括为优化性能，它包括了缓存技术</description>
    </item>
    
    <item>
      <title>boost::typeIndex 的相关探究</title>
      <link>https://zintrulcre.vip/posts/c&#43;&#43;/boost/boost.typeindex-%E7%9A%84%E7%9B%B8%E5%85%B3%E6%8E%A2%E7%A9%B6/</link>
      <pubDate>Fri, 31 Jul 2020 20:31:06 +0800</pubDate>
      
      <guid>https://zintrulcre.vip/posts/c&#43;&#43;/boost/boost.typeindex-%E7%9A%84%E7%9B%B8%E5%85%B3%E6%8E%A2%E7%A9%B6/</guid>
      <description>boost::typeIndex 的相关探究 Effective Modern C++ 的 Item 4: Know how to view deduced types. 中提到了 Boost::typeindex 的使用，但并没有讲到其实现原理。 1. typeid 操作符 typeid 是 C++ 中的一个操作符，可以用于获取类型的信息，常常用</description>
    </item>
    
  </channel>
</rss>
