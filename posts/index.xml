<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on ZintrulCre</title>
		<link>http://zintrulcre.vip/posts/</link>
		<description>Recent content in Posts on ZintrulCre</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Fri, 25 Jan 2019 01:02:02 +1100</lastBuildDate>
		<atom:link href="http://zintrulcre.vip/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>C&#43;&#43;智能指针（2）：unique_ptr</title>
			<link>http://zintrulcre.vip/posts/c&#43;&#43;-smart-pointer-2/</link>
			<pubDate>Fri, 25 Jan 2019 01:02:02 +1100</pubDate>
			
			<guid>http://zintrulcre.vip/posts/c&#43;&#43;-smart-pointer-2/</guid>
			<description>分析 在使用auto_ptr的时候会发生所有权转移和内存泄漏的问题，所以我们可以对AutoPointer类稍加修改，修复这两个问题。 所有权转</description>
			<content type="html"><![CDATA[

<h2 id="分析">分析</h2>

<p>在使用auto_ptr的时候会发生所有权转移和内存泄漏的问题，所以我们可以对AutoPointer类稍加修改，修复这两个问题。</p>

<h3 id="所有权转移">所有权转移</h3>

<p>为了规避可能发生所有权转移的情况，我们可以禁止它使用拷贝构造函数和赋值操作符。</p>

<pre><code>    UniquePointer(UniquePointer&lt;T&gt; &amp;other) = delete;

    UniquePointer&lt;T&gt; &amp;operator=(const UniquePointer&lt;T&gt; &amp;other) = delete;
</code></pre>

<p>但很多时候我们都需要使用到传递指针的操作，如果只是使用deleted函数禁止拷贝构造函数和赋值操作符，那么这个智能指针存在的意义就不大了，我们可以实现移动构造函数和移动赋值操作符，从而在使用UniquePointer的时候可以通过move语义，在特定情况下进行所有权转移。</p>

<pre><code>    UniquePointer(UniquePointer&lt;T&gt; &amp;&amp;other) noexcept;

    UniquePointer &amp;operator=(UniquePointer &amp;&amp;other) noexcept;
</code></pre>

<h3 id="内存泄漏">内存泄漏</h3>

<p>为了防止发生内存泄漏，我们可以在UniquePointer的私有成员中增加一个删除器，并根据当前指针对象的类型指定删除器，从而防止发生内存泄漏。</p>

<pre><code>class Deleter {
    template&lt;typename T&gt;
    void operator()(T *p) {
        if (p)
            delete p;
    }
};

template&lt;typename T, typename D&gt;
class UniquePointer {
  ...
private:
    T *pointer;
    Deleter deleter;
};
</code></pre>

<h2 id="实现">实现</h2>

<p>根据unique_ptr的源码，能够大致实现UniquePointer类</p>

<pre><code>class Deleter {
public:
    template&lt;typename T&gt;
    void operator()(T *p) {
        if (p)
            delete p;
    }
};

template&lt;typename T, typename D&gt;
class UniquePointer {
public:
    explicit UniquePointer(T *t, const D &amp;d);

    ~UniquePointer();

    T &amp;operator*();

    T *operator-&gt;();

    T *release();

    void reset(T *p);

    UniquePointer(UniquePointer &amp;&amp;other) noexcept;

    UniquePointer &amp;operator=(UniquePointer &amp;&amp;other) noexcept;

    UniquePointer(const UniquePointer &amp;other) = delete;

    UniquePointer &amp;operator=(const UniquePointer &amp;other) = delete;

private:
    T *pointer;
    D deleter;
};

template&lt;typename T, typename D&gt;
UniquePointer&lt;T, D&gt;::UniquePointer(T *t, const D &amp;d):pointer(t), deleter(d) {
    std::cout &lt;&lt; &quot;UniquePointer &quot; &lt;&lt; this &lt;&lt; &quot; constructor called.&quot; &lt;&lt; std::endl;
}

template&lt;typename T, typename D&gt;
UniquePointer&lt;T, D&gt;::~UniquePointer() {
    std::cout &lt;&lt; &quot;UniquePointer &quot; &lt;&lt; this &lt;&lt; &quot; destructor called.&quot; &lt;&lt; std::endl;
    deleter(pointer);
}

template&lt;typename T, typename D&gt;
T &amp;UniquePointer&lt;T, D&gt;::operator*() {
    return *pointer;
}

template&lt;typename T, typename D&gt;
T *UniquePointer&lt;T, D&gt;::operator-&gt;() {
    return pointer;
}

template&lt;typename T, typename D&gt;
T *UniquePointer&lt;T, D&gt;::release() {
    T *new_pointer = pointer;
    pointer = nullptr;
    return new_pointer;
}

template&lt;typename T, typename D&gt;
void UniquePointer&lt;T, D&gt;::reset(T *p) {
    if (pointer != p) {
        deleter(pointer);
        pointer = p;
    }
}

template&lt;typename T, typename D&gt;
UniquePointer&lt;T, D&gt;::UniquePointer(UniquePointer&lt;T, D&gt; &amp;&amp;other) noexcept: pointer(other.release()),
                                                                          deleter(std::move(other.deleter)) {
    std::cout &lt;&lt; &quot;UniquePointer &quot; &lt;&lt; this &lt;&lt; &quot; move constructor called.&quot; &lt;&lt; std::endl;
}

template&lt;typename T, typename D&gt;
UniquePointer&lt;T, D&gt; &amp;UniquePointer&lt;T, D&gt;::operator=(UniquePointer&lt;T, D&gt; &amp;&amp;other) noexcept {
    std::cout &lt;&lt; &quot;UniquePointer &quot; &lt;&lt; this &lt;&lt; &quot; assignment operator called.&quot; &lt;&lt; std::endl;
    if (pointer != other.pointer) {
        reset(other.release());
        deleter = std::move(other.deleter);
    }
    return *this;
}
</code></pre>

<h2 id="测试">测试</h2>

<p>尝试使用移动构造函数</p>

<pre><code>int main() {
    Deleter deleter;
    Obj *o = new Obj();
    UniquePointer&lt;Obj, Deleter&gt; u1(o, deleter);
    UniquePointer&lt;Obj, Deleter&gt; u2(move(u1));
    return 0;
}
/*
output:
Construct
UniquePointer 0x7ffee7dada08 constructor called.
UniquePointer 0x7ffee7dad9f8 move constructor called.
UniquePointer 0x7ffee7dad9f8 destructor called.
Destruct
UniquePointer 0x7ffee7dada08 destructor called.
*/
</code></pre>

<p>尝试使用移动赋值操作符</p>

<pre><code>int main() {
    Deleter deleter;
    Obj *o = new Obj();
    UniquePointer&lt;Obj, Deleter&gt; u1(o, deleter);
    UniquePointer&lt;Obj, Deleter&gt; u2(nullptr, deleter);
    u2 = move(u1);
    return 0;
}
/*
output:
Construct
UniquePointer 0x7ffee915da08 constructor called.
UniquePointer 0x7ffee915d9f8 constructor called.
UniquePointer 0x7ffee915d9f8 assignment operator called.
UniquePointer 0x7ffee915d9f8 destructor called.
Destruct
UniquePointer 0x7ffee915da08 destructor called.
*/
</code></pre>

<p>定义一个数组删除器，尝试以数组指针初始化UniquePointer类对象</p>

<pre><code>class ArrayDeleter {
public:
    template&lt;typename T&gt;
    void operator()(T *p) {
        if (p)
            delete[] p;
    }
};

int main() {
    ArrayDeleter array_deleter;
    Obj *o = new Obj[3];
    UniquePointer&lt;Obj, ArrayDeleter&gt; u(o, array_deleter);
    return 0;
}
/*
output:
Construct
Construct
Construct
UniquePointer 0x7ffeed926a08 constructor called.
UniquePointer 0x7ffeed926a08 destructor called.
Destruct
Destruct
Destruct
*/
</code></pre>

<p>作为对比，如果使用默认删除器作为数组指针的删除器</p>

<pre><code>int main() {
    Deleter deleter;
    Obj *o = new Obj[3];
    UniquePointer&lt;Obj, Deleter&gt; u(o, deleter);
    return 0;
}
/*
output:
Construct
Construct
Construct
UniquePointer 0x7ffee8f85a10 constructor called.
UniquePointer 0x7ffee8f85a10 destructor called.
Destruct
*/
</code></pre>

<p>说明删除器能够正确地修复内存泄漏的问题。</p>

<p>尝试将两个UniquePointer的对象指向同一个指针</p>

<pre><code>int main() {
    Deleter deleter;
    Obj *o = new Obj();
    UniquePointer&lt;Obj, Deleter&gt; u1(o, deleter);
    UniquePointer&lt;Obj, Deleter&gt; u2(o, deleter);
    return 0;
}
/*
output:
(19576,0x10e00a5c0) malloc: *** error for object 0x7fcfe8c02ab0: pointer being freed was not allocated
(19576,0x10e00a5c0) malloc: *** set a breakpoint in malloc_error_break to debug
Construct
UniquePointer 0x7ffee28a9a10 constructor called.
UniquePointer 0x7ffee28a9a00 constructor called.
UniquePointer 0x7ffee28a9a00 destructor called.
Destruct
UniquePointer 0x7ffee28a9a10 destructor called.
Destruct
*/
</code></pre>

<p>还是产生调用两次析构函数的错误。</p>

<h2 id="总结">总结</h2>

<p>UniquePointer成功地解决了所有权转移和内存泄漏的问题，但还有诸如重复析构的问题存在。</p>

<h2 id="源码">源码</h2>

<pre><code>template &lt;class _Tp, class _Dp = default_delete&lt;_Tp&gt; &gt;
class _LIBCPP_TEMPLATE_VIS unique_ptr {
public:
  typedef _Tp element_type;
  typedef _Dp deleter_type;
  typedef typename __pointer_type&lt;_Tp, deleter_type&gt;::type pointer;

  static_assert(!is_rvalue_reference&lt;deleter_type&gt;::value,
                &quot;the specified deleter type cannot be an rvalue reference&quot;);

private:
  __compressed_pair&lt;pointer, deleter_type&gt; __ptr_;

  struct __nat { int __for_bool_; };

#ifndef _LIBCPP_CXX03_LANG
  typedef __unique_ptr_deleter_sfinae&lt;_Dp&gt; _DeleterSFINAE;

  template &lt;bool _Dummy&gt;
  using _LValRefType =
      typename __dependent_type&lt;_DeleterSFINAE, _Dummy&gt;::__lval_ref_type;

  template &lt;bool _Dummy&gt;
  using _GoodRValRefType =
      typename __dependent_type&lt;_DeleterSFINAE, _Dummy&gt;::__good_rval_ref_type;

  template &lt;bool _Dummy&gt;
  using _BadRValRefType =
      typename __dependent_type&lt;_DeleterSFINAE, _Dummy&gt;::__bad_rval_ref_type;

  template &lt;bool _Dummy, class _Deleter = typename __dependent_type&lt;
                             __identity&lt;deleter_type&gt;, _Dummy&gt;::type&gt;
  using _EnableIfDeleterDefaultConstructible =
      typename enable_if&lt;is_default_constructible&lt;_Deleter&gt;::value &amp;&amp;
                         !is_pointer&lt;_Deleter&gt;::value&gt;::type;

  template &lt;class _ArgType&gt;
  using _EnableIfDeleterConstructible =
      typename enable_if&lt;is_constructible&lt;deleter_type, _ArgType&gt;::value&gt;::type;

  template &lt;class _UPtr, class _Up&gt;
  using _EnableIfMoveConvertible = typename enable_if&lt;
      is_convertible&lt;typename _UPtr::pointer, pointer&gt;::value &amp;&amp;
      !is_array&lt;_Up&gt;::value
  &gt;::type;

  template &lt;class _UDel&gt;
  using _EnableIfDeleterConvertible = typename enable_if&lt;
      (is_reference&lt;_Dp&gt;::value &amp;&amp; is_same&lt;_Dp, _UDel&gt;::value) ||
      (!is_reference&lt;_Dp&gt;::value &amp;&amp; is_convertible&lt;_UDel, _Dp&gt;::value)
    &gt;::type;

  template &lt;class _UDel&gt;
  using _EnableIfDeleterAssignable = typename enable_if&lt;
      is_assignable&lt;_Dp&amp;, _UDel&amp;&amp;&gt;::value
    &gt;::type;

public:
  template &lt;bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible&lt;_Dummy&gt;&gt;
  _LIBCPP_INLINE_VISIBILITY
  constexpr unique_ptr() noexcept : __ptr_(pointer()) {}

  template &lt;bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible&lt;_Dummy&gt;&gt;
  _LIBCPP_INLINE_VISIBILITY
  constexpr unique_ptr(nullptr_t) noexcept : __ptr_(pointer()) {}

  template &lt;bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible&lt;_Dummy&gt;&gt;
  _LIBCPP_INLINE_VISIBILITY
  explicit unique_ptr(pointer __p) noexcept : __ptr_(__p) {}

  template &lt;bool _Dummy = true,
            class = _EnableIfDeleterConstructible&lt;_LValRefType&lt;_Dummy&gt;&gt;&gt;
  _LIBCPP_INLINE_VISIBILITY
  unique_ptr(pointer __p, _LValRefType&lt;_Dummy&gt; __d) noexcept
      : __ptr_(__p, __d) {}

  template &lt;bool _Dummy = true,
            class = _EnableIfDeleterConstructible&lt;_GoodRValRefType&lt;_Dummy&gt;&gt;&gt;
  _LIBCPP_INLINE_VISIBILITY
  unique_ptr(pointer __p, _GoodRValRefType&lt;_Dummy&gt; __d) noexcept
      : __ptr_(__p, _VSTD::move(__d)) {
    static_assert(!is_reference&lt;deleter_type&gt;::value,
                  &quot;rvalue deleter bound to reference&quot;);
  }

  template &lt;bool _Dummy = true,
            class = _EnableIfDeleterConstructible&lt;_BadRValRefType&lt;_Dummy&gt;&gt;&gt;
  _LIBCPP_INLINE_VISIBILITY
  unique_ptr(pointer __p, _BadRValRefType&lt;_Dummy&gt; __d) = delete;

  _LIBCPP_INLINE_VISIBILITY
  unique_ptr(unique_ptr&amp;&amp; __u) noexcept
      : __ptr_(__u.release(), _VSTD::forward&lt;deleter_type&gt;(__u.get_deleter())) {
  }

  template &lt;class _Up, class _Ep,
      class = _EnableIfMoveConvertible&lt;unique_ptr&lt;_Up, _Ep&gt;, _Up&gt;,
      class = _EnableIfDeleterConvertible&lt;_Ep&gt;
  &gt;
  _LIBCPP_INLINE_VISIBILITY
  unique_ptr(unique_ptr&lt;_Up, _Ep&gt;&amp;&amp; __u) _NOEXCEPT
      : __ptr_(__u.release(), _VSTD::forward&lt;_Ep&gt;(__u.get_deleter())) {}

#if _LIBCPP_STD_VER &lt;= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
  template &lt;class _Up&gt;
  _LIBCPP_INLINE_VISIBILITY
  unique_ptr(auto_ptr&lt;_Up&gt;&amp;&amp; __p,
             typename enable_if&lt;is_convertible&lt;_Up*, _Tp*&gt;::value &amp;&amp;
                                    is_same&lt;_Dp, default_delete&lt;_Tp&gt;&gt;::value,
                                __nat&gt;::type = __nat()) _NOEXCEPT
      : __ptr_(__p.release()) {}
#endif

  _LIBCPP_INLINE_VISIBILITY
  unique_ptr&amp; operator=(unique_ptr&amp;&amp; __u) _NOEXCEPT {
    reset(__u.release());
    __ptr_.second() = _VSTD::forward&lt;deleter_type&gt;(__u.get_deleter());
    return *this;
  }

  template &lt;class _Up, class _Ep,
      class = _EnableIfMoveConvertible&lt;unique_ptr&lt;_Up, _Ep&gt;, _Up&gt;,
      class = _EnableIfDeleterAssignable&lt;_Ep&gt;
  &gt;
  _LIBCPP_INLINE_VISIBILITY
  unique_ptr&amp; operator=(unique_ptr&lt;_Up, _Ep&gt;&amp;&amp; __u) _NOEXCEPT {
    reset(__u.release());
    __ptr_.second() = _VSTD::forward&lt;_Ep&gt;(__u.get_deleter());
    return *this;
  }

#else  // _LIBCPP_CXX03_LANG
private:
  unique_ptr(unique_ptr&amp;);
  template &lt;class _Up, class _Ep&gt; unique_ptr(unique_ptr&lt;_Up, _Ep&gt;&amp;);

  unique_ptr&amp; operator=(unique_ptr&amp;);
  template &lt;class _Up, class _Ep&gt; unique_ptr&amp; operator=(unique_ptr&lt;_Up, _Ep&gt;&amp;);

public:
  _LIBCPP_INLINE_VISIBILITY
  unique_ptr() : __ptr_(pointer())
  {
    static_assert(!is_pointer&lt;deleter_type&gt;::value,
                  &quot;unique_ptr constructed with null function pointer deleter&quot;);
    static_assert(is_default_constructible&lt;deleter_type&gt;::value,
                  &quot;unique_ptr::deleter_type is not default constructible&quot;);
  }
  _LIBCPP_INLINE_VISIBILITY
  unique_ptr(nullptr_t) : __ptr_(pointer())
  {
    static_assert(!is_pointer&lt;deleter_type&gt;::value,
                  &quot;unique_ptr constructed with null function pointer deleter&quot;);
  }
  _LIBCPP_INLINE_VISIBILITY
  explicit unique_ptr(pointer __p)
      : __ptr_(_VSTD::move(__p)) {
    static_assert(!is_pointer&lt;deleter_type&gt;::value,
                  &quot;unique_ptr constructed with null function pointer deleter&quot;);
  }

  _LIBCPP_INLINE_VISIBILITY
  operator __rv&lt;unique_ptr&gt;() {
    return __rv&lt;unique_ptr&gt;(*this);
  }

  _LIBCPP_INLINE_VISIBILITY
  unique_ptr(__rv&lt;unique_ptr&gt; __u)
      : __ptr_(__u-&gt;release(),
               _VSTD::forward&lt;deleter_type&gt;(__u-&gt;get_deleter())) {}

  template &lt;class _Up, class _Ep&gt;
  _LIBCPP_INLINE_VISIBILITY
  typename enable_if&lt;
      !is_array&lt;_Up&gt;::value &amp;&amp;
          is_convertible&lt;typename unique_ptr&lt;_Up, _Ep&gt;::pointer,
                         pointer&gt;::value &amp;&amp;
          is_assignable&lt;deleter_type&amp;, _Ep&amp;&gt;::value,
      unique_ptr&amp;&gt;::type
  operator=(unique_ptr&lt;_Up, _Ep&gt; __u) {
    reset(__u.release());
    __ptr_.second() = _VSTD::forward&lt;_Ep&gt;(__u.get_deleter());
    return *this;
  }

  _LIBCPP_INLINE_VISIBILITY
  unique_ptr(pointer __p, deleter_type __d)
      : __ptr_(_VSTD::move(__p), _VSTD::move(__d)) {}
#endif // _LIBCPP_CXX03_LANG

#if _LIBCPP_STD_VER &lt;= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
  template &lt;class _Up&gt;
  _LIBCPP_INLINE_VISIBILITY
      typename enable_if&lt;is_convertible&lt;_Up*, _Tp*&gt;::value &amp;&amp;
                             is_same&lt;_Dp, default_delete&lt;_Tp&gt; &gt;::value,
                         unique_ptr&amp;&gt;::type
      operator=(auto_ptr&lt;_Up&gt; __p) {
    reset(__p.release());
    return *this;
  }
#endif

  _LIBCPP_INLINE_VISIBILITY
  ~unique_ptr() { reset(); }

  _LIBCPP_INLINE_VISIBILITY
  unique_ptr&amp; operator=(nullptr_t) _NOEXCEPT {
    reset();
    return *this;
  }

  _LIBCPP_INLINE_VISIBILITY
  typename add_lvalue_reference&lt;_Tp&gt;::type
  operator*() const {
    return *__ptr_.first();
  }
  _LIBCPP_INLINE_VISIBILITY
  pointer operator-&gt;() const _NOEXCEPT {
    return __ptr_.first();
  }
  _LIBCPP_INLINE_VISIBILITY
  pointer get() const _NOEXCEPT {
    return __ptr_.first();
  }
  _LIBCPP_INLINE_VISIBILITY
  deleter_type&amp; get_deleter() _NOEXCEPT {
    return __ptr_.second();
  }
  _LIBCPP_INLINE_VISIBILITY
  const deleter_type&amp; get_deleter() const _NOEXCEPT {
    return __ptr_.second();
  }
  _LIBCPP_INLINE_VISIBILITY
  _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {
    return __ptr_.first() != nullptr;
  }

  _LIBCPP_INLINE_VISIBILITY
  pointer release() _NOEXCEPT {
    pointer __t = __ptr_.first();
    __ptr_.first() = pointer();
    return __t;
  }

  _LIBCPP_INLINE_VISIBILITY
  void reset(pointer __p = pointer()) _NOEXCEPT {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = __p;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  _LIBCPP_INLINE_VISIBILITY
  void swap(unique_ptr&amp; __u) _NOEXCEPT {
    __ptr_.swap(__u.__ptr_);
  }
};
</code></pre>
]]></content>
		</item>
		
		<item>
			<title>使用Scrapy爬取LeetCode（3）：登录</title>
			<link>http://zintrulcre.vip/posts/use-scrapy-to-crawl-leetcode-3/</link>
			<pubDate>Mon, 21 Jan 2019 13:15:17 +1100</pubDate>
			
			<guid>http://zintrulcre.vip/posts/use-scrapy-to-crawl-leetcode-3/</guid>
			<description>本项目ZintrulCre/LeetCode_Crawler已完成，并正在维护中，欢迎在GitHub上star和fork。 Cookie和Se</description>
			<content type="html"><![CDATA[

<p>本项目<a href="https://github.com/ZintrulCre/LeetCode_Crawler" target="_blank">ZintrulCre/LeetCode_Crawler</a>已完成，并正在维护中，欢迎在GitHub上star和fork。</p>

<h2 id="cookie和session">Cookie和Session</h2>

<p>为了获取我们自己的提交记录，我们首先要进行登录的操作。但我们都知道HTTP是一种无状态的协议，它的每个请求都是独立的。无论是GET还是POST请求，都包含了处理当前这一条请求的所有信息，但它并不会涉及到状态的变化。因此，为了在无状态的HTTP协议上维护一个持久的状态，引入了Cookie和Session的概念，两者都是为了辨识用户相关信息而储存在内存或硬盘上的加密数据。</p>

<p>Cookie是由客户端浏览器维护的。客户端浏览器会在需要时把Cookie保存在内存中，当其再次向该域名相关的网站发出request时，浏览器会把url和Cookie一起作为request的一部分发送给服务器。服务器通过解析该Cookie来确认用户的状态，并对Cookie的内容作出相应的修改。一般来说，如果不设置过期时间，非持久Cookie会保存在内存中，浏览器关闭后就被删除了。</p>

<p>Session是由服务器维护的。当客户端第一次向服务器发出request后，服务器会为该客户端创建一个Session。当该客户端再次访问服务器时，服务器会根据该Session来获取相关信息。一般来说，服务器会为Seesion设置一个失效时间，当距离接收到客户端上一次发送request的时间超过这个失效时间后，服务器会主动删除Session。</p>

<p>两种方法都可以用来维护登录的状态。为了简便起见，本项目目前使用Session作为维护登录状态的方法。</p>

<h2 id="获取数据">获取数据</h2>

<h3 id="分析">分析</h3>

<p>首先我们进入<a href="https://leetcode.com/accounts/login/" target="_blank">登录页面</a>，打开开发者工具，勾选Preserve log。为了知道在登录时浏览器向服务器提交了哪些数据，我们可以先输入一个错误的用户名和密码，便于抓包。</p>

<p><img src="https://raw.githubusercontent.com/ZintrulCre/zintrulcre.github.io/master/data/Use-Scrapy-to-Crawl-LeetCode/7.png" alt="7" /></p>

<p>通过分析&rdquo;login/&ldquo;这条request，我们可以知道我们所需要的一些关键信息，例如headers中的user-agent和referer，表单数据（form data）中的csrfmiddlewaretoken，login和password。显然，user-agent和referer我们可以直接复制下来，login和password是我们填写的用户名和密码。还有一个很陌生的csrfmiddlewaretoken。这是CSRF的中间件token，CSRF是Cross-Site Request Forgery，相关知识可以查询<a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0" target="_blank">跨站请求伪造的维基百科</a>。那么现在我们就要分析这个token是从何而来。</p>

<h4 id="获取csrfmiddlewaretoken">获取csrfmiddlewaretoken</h4>

<p>我们将刚才获取到的csrfmiddlewaretoken复制下来，在开发者工具中使用搜索功能，可以发现这个csrfmiddlewaretoken出现在了登录之前的一些request对应的response中。例如在刚才打开登录页面，发送GET请求时，response的headers的set-cookie中出现了&rdquo;csrftoken=&hellip;&ldquo;，而这里csrftoken的值与我们需要在登录表单中提交的值完全相同。因此，我们可以通过获取刚才的response中的Cookies来获取csrfmiddlewaretoken的值。</p>

<p><img src="https://raw.githubusercontent.com/ZintrulCre/zintrulcre.github.io/master/data/Use-Scrapy-to-Crawl-LeetCode/8.png" alt="8" /></p>

<p>首先我们通过发送GET请求来分析一下Cookies的构成</p>

<pre><code>login_url = &quot;https://leetcode.com/accounts/login/&quot;
session = requests.session()
result = session.get(login_url)
print(result)
print(type(result.cookies))
for cookie in result.cookies:
    print(type(cookie))
    print(cookie)
</code></pre>

<p>得到的结果是</p>

<ul>
<li><code>&lt;Response [200]&gt;</code> 状态码200，表示请求成功</li>
<li><code>&lt;class 'requests.cookies.RequestsCookieJar'&gt;</code> cookies的类型是CookieJar</li>
<li><code>&lt;class 'http.cookiejar.Cookie'&gt;</code> 第一条cookie的类型是Cookie</li>
<li><code>&lt;Cookie__cfduid=d3e02d4309b848f9369e21671fabbce571548041181 for .leetcode.com/&gt;</code> 第一条cookie的信息</li>
<li><code>&lt;class 'http.cookiejar.Cookie'&gt;</code> 第二条cookie的类型是Cookie</li>
<li><code>&lt;Cookie csrftoken=13mQWE9tYN6g2IrlKY8oMLRc4VhVNoet4j328YdDapW2WC2nf93y5iCuzorovTDl for leetcode.com/&gt;</code> 第二条cookie的信息，也就是我们所需要的csrftoken</li>
</ul>

<p>这样一来我们便获取到了在提交表单信息时所需要的csrfmiddlewaretoken，之后我们便可以开始着手写登录的相关代码了。顺便一提，在使用Django进行后端开发的时候自动生成的csrf token的键也叫csrfmiddlewaretoken，不知道LeetCode是不是用Django作为后端开发框架的。</p>

<h3 id="实现">实现</h3>

<p>首先我们需要在爬虫开始运行之前获取登录信息，将Session作为类的成员变量保存下来，方便在获取submissions时使用。同时我们需要在与爬虫文件相同的目录下新建config.json，将自己的用户名和密码保存在该json文件里，这样就能顺利登陆了。</p>

<pre><code>    def start_requests(self):
        self.Login()    # 登录
        questionset_url = &quot;https://leetcode.com/api/problems/all/&quot;
        yield scrapy.Request(url=questionset_url, callback=self.ParseQuestionSet)

    def Login(self):
    login_url = &quot;https://leetcode.com/accounts/login/&quot;
    login_headers = {
        &quot;user_agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36'&quot;,
        &quot;referer&quot;: &quot;https://leetcode.com/accounts/login/&quot;,
        # &quot;content-type&quot;: &quot;multipart/form-data; boundary=----WebKitFormBoundary70YlQBtroATwu9Jx&quot;
    }
    self.session = requests.session()
    result = self.session.get(login_url)
    file = open('./config.json', 'r')
    info = json.load(file)
    data = {&quot;login&quot;: info[&quot;username&quot;], &quot;password&quot;: inf[&quot;password&quot;],
            &quot;csrfmiddlewaretoken&quot;: self.session.cookies['csrftoken']}
    self.session.post(login_url, data=data,headers=login_headers)
    print(&quot;login info: &quot; + str(result))
</code></pre>

<p>注意如果在headers中填写了content-type的值，可能会产生一些奇怪的错误信息，并且后续不能正确地获取自己的submissions，只需要user_agent和refere的信息即可。</p>

<p>如果看到输出<code>login info: &lt;Response [200]&gt;</code>就代表登录成功了！</p>

<h2 id="参考资料">参考资料</h2>

<p><a href="https://scrapy-chs.readthedocs.io/zh_CN/0.24/" target="_blank">Scrapy官方文档</a></p>
]]></content>
		</item>
		
		<item>
			<title>使用Scrapy爬取LeetCode（2）：爬取题目信息</title>
			<link>http://zintrulcre.vip/posts/use-scrapy-to-crawl-leetcode-2/</link>
			<pubDate>Fri, 18 Jan 2019 15:06:01 +1100</pubDate>
			
			<guid>http://zintrulcre.vip/posts/use-scrapy-to-crawl-leetcode-2/</guid>
			<description>本项目ZintrulCre/LeetCode_Crawler已完成，并正在维护中，欢迎在GitHub上star和fork。 创建爬虫 在新建好项</description>
			<content type="html"><![CDATA[

<p>本项目<a href="https://github.com/ZintrulCre/LeetCode_Crawler" target="_blank">ZintrulCre/LeetCode_Crawler</a>已完成，并正在维护中，欢迎在GitHub上star和fork。</p>

<h2 id="创建爬虫">创建爬虫</h2>

<p>在新建好项目后，用PyCharm或其他IDE打开该项目。进入该项目文件夹，使用<code>genspider</code>命令新建一个爬虫：</p>

<pre><code>cd scrapy_project
scrapy genspider QuestionSetSpider leetcode.com
</code></pre>

<p>其中QuestionSetSpider是爬虫的名字，leetcode.com是我们打算爬取的网站的域名。</p>

<p>新建好爬虫之后可以看到在项目的spiders文件夹下新增了一个名为 QuestionSetSpider.py的文件，这就是我们刚才新建的爬虫文件。这个爬虫文件会自动生成以下代码</p>

<pre><code># -*- coding: utf-8 -*-
import scrapy

class QuestionSetSpider(scrapy.Spider):
    name = 'QuestionSetSpider'
    allowed_domains = ['leetcode.com']
    start_urls = ['http://leetcode.com/']

    def parse(self, response):
        pass

</code></pre>

<ul>
<li>QuestionSetSpider类继承自scrapy.Spider，也就是scrapy框架中所有爬虫的基类；</li>
<li>self.name属性是该爬虫的名字，在该爬虫文件的外部可以通过这个属性获取当前爬虫；</li>
<li>self.allowed_domains是当前爬虫文件可以访问的域名列表，如果在爬取页面时进入了一个该域名以外的url会抛出错误；</li>
<li>self.start_urls是一个url列表，基类中定义了start_requests函数，它会遍历self.start_urls，并对每一个url调用scrapy.Request(url, dont_filter=True)，为了实现爬取题目的需求，我们需要重写self.start_urls函数</li>
</ul>

<h2 id="获取题目详细信息">获取题目详细信息</h2>

<h3 id="分析">分析</h3>

<p>LeetCode使用了GraphQL进行数据的查询和传输，大部分页面都是通过JS渲染生成的动态页面，所以无法直接从页面上获取标签，即使使用提供JavaScript渲染服务的库（例如Splash）也无法获取全部的数据，所以只能通过发送请求来获取数据。</p>

<p>为了爬取题目的详细信息，我们首先要从题目列表进入每个题目对应的链接。</p>

<p>首先打开leetcode的<a href="https://leetcode.com/problemset/all/" target="_blank">problem</a>列表，按F12打开Chrome的开发者工具，进入Network标签栏，勾选上Preserve log，刷新该页面。</p>

<p><img src="https://raw.githubusercontent.com/ZintrulCre/zintrulcre.github.io/master/data/Use-Scrapy-to-Crawl-LeetCode/1.png" alt="1" /></p>

<p>可以看到，网页向 <a href="https://leetcode.com/api/problems/all/" target="_blank">https://leetcode.com/api/problems/all/</a> 发送了一个名为&rdquo;all/&ldquo;的GET类型的Request，这就是获取所有题目链接和相关信息的请求。如果此时已经安装了Toggle JavaScript插件，我们可以直接右键点击“Open in new tab”，查看该请求返回的Response。</p>

<p><img src="https://raw.githubusercontent.com/ZintrulCre/zintrulcre.github.io/master/data/Use-Scrapy-to-Crawl-LeetCode/2.png" alt="2" /></p>

<p>更方便的方法是使用postman向服务器发送一个相同的Request，并将其保存下来，这样如果我们下次需要查看相应的Response的时候就不需要再使用开发者工具了。</p>

<p><img src="https://raw.githubusercontent.com/ZintrulCre/zintrulcre.github.io/master/data/Use-Scrapy-to-Crawl-LeetCode/3.png" alt="3" /></p>

<p>返回的Response是一个json对象，其中的&rdquo;stat_status_pairs&rdquo;键所对应的值是所有包含题目信息的list，而列表中的[&ldquo;stat&rdquo;][&ldquo;question__title_slug&rdquo;]就是题目所在的页面。以Largest Perimeter Triangle为例，将其title_slug拼接到<a href="https://leetcode.com/problems/" target="_blank">https://leetcode.com/problems/</a> 后，进入页面<a href="https://leetcode.com/problems/largest-perimeter-triangle/" target="_blank">https://leetcode.com/problems/largest-perimeter-triangle/</a> 。同样地，打开开发者工具，刷新页面，可以看到服务器返回了很多项graphql的查询数据，通过查看Request Payload可以找到其中operationName为&rdquo;questionData&rdquo;的一项，这就是当前题目的详细信息。</p>

<p><img src="https://raw.githubusercontent.com/ZintrulCre/zintrulcre.github.io/master/data/Use-Scrapy-to-Crawl-LeetCode/4.png" alt="4" /></p>

<p>将Payload复制粘贴到postman的Body中，在Headers中设置Content-Type为application/json，发送请求，可以看到返回的是一个json对象，包含了该题目所对应的所有信息。</p>

<p><img src="https://raw.githubusercontent.com/ZintrulCre/zintrulcre.github.io/master/data/Use-Scrapy-to-Crawl-LeetCode/5.png" alt="5" /></p>

<p>接下来我们就可以对该题目的信息进行处理了。</p>

<h3 id="实现">实现</h3>

<p>为了获取题目列表的json对象，我们需要先重写start_requests函数。</p>

<pre><code>def start_requests(self):
        self.Login() # 用户登录，后续会用到
        questionset_url = &quot;https://leetcode.com/api/problems/all/&quot;
        yield scrapy.Request(url=questionset_url, callback=self.ParseQuestionSet)
</code></pre>

<p>Request是scrapy的一个类对象，功能类似于requests库中的get函数，可以让scrapy框架中的Downloader向url发送一个get请求，并将获取的response交给指定的爬虫文件中的回调函数进行相应的处理，其构造函数如下</p>

<pre><code>class Request(object_ref):

    def __init__(self, url, callback=None, method='GET', headers=None, body=None, cookies=None, meta=None, encoding='utf-8', priority=0, dont_filter=False, errback=None, flags=None):
    ...
</code></pre>

<p>在获取到json对象之后，可以通过遍历&rdquo;stat_status_pairs&rdquo;键所对应的列表，并取出[&ldquo;stat&rdquo;][&ldquo;question__title_slug&rdquo;]的值，得到题目的title_slug。此时我们不再需要进行打开题目相关页面的操作，直接向GraphQL发送查询详细信息的request即可。</p>

<p>我们可以从postman直接获取到发送请求相关的代码。因为每个题目的title_slug不同，我们可以将Payload中titleSlug后的字段改为一个不会重复的独特的字符串，在每一次获取到新的title_slug之后用replace函数替换它，发送新的请求，然后再将其替换回独特的字符串。</p>

<p><img src="https://raw.githubusercontent.com/ZintrulCre/zintrulcre.github.io/master/data/Use-Scrapy-to-Crawl-LeetCode/6.png" alt="6" /></p>

<p>准备好Payload和Headers之后，我们可以使用FormRequest发送POST请求向GraphQL查询数据。FormRequest是scrapy的一个类对象，功能类似于requests库中的post函数，让scrapy框架中的Downloader向url发送一个post请求，并将获取的response交给指定的爬虫文件中的回调函数进行相应的处理。此处在发送POST请求之后response被交给ParseQuestionData函数进行处理。</p>

<pre><code>    question_payload = &quot;{\n    \&quot;operationName\&quot;: \&quot;questionData\&quot;,\n    \&quot;variables\&quot;: {\n        \&quot;titleSlug\&quot;: \&quot;QuestionName\&quot;\n    },\n    \&quot;query\&quot;: \&quot;query questionData($titleSlug: String!) {\\n  question(titleSlug: $titleSlug) {\\n    questionId\\n    questionFrontendId\\n    boundTopicId\\n    title\\n    titleSlug\\n    content\\n    translatedTitle\\n    translatedContent\\n    isPaidOnly\\n    difficulty\\n    likes\\n    dislikes\\n    isLiked\\n    similarQuestions\\n    contributors {\\n      username\\n      profileUrl\\n      avatarUrl\\n      __typename\\n    }\\n    langToValidPlayground\\n    topicTags {\\n      name\\n      slug\\n      translatedName\\n      __typename\\n    }\\n    companyTagStats\\n    codeSnippets {\\n      lang\\n      langSlug\\n      code\\n      __typename\\n    }\\n    stats\\n    hints\\n    solution {\\n      id\\n      canSeeDetail\\n      __typename\\n    }\\n    status\\n    sampleTestCase\\n    metaData\\n    judgerAvailable\\n    judgeType\\n    mysqlSchemas\\n    enableRunCode\\n    enableTestMode\\n    envInfo\\n    __typename\\n  }\\n}\\n\&quot;\n}\n&quot;

    graphql_url = &quot;https://leetcode.com/graphql&quot;

    def ParseQuestionSet(self, response):
        headers = {
            &quot;user_agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36'&quot;,
            &quot;content-type&quot;: &quot;application/json&quot;  # necessary
        }
        questionSet = json.loads(response.text)
        questionSet = questionSet[&quot;stat_status_pairs&quot;]
        for question in questionSet:
            title_slug = question[&quot;stat&quot;][&quot;question__title_slug&quot;]
            self.question_payload = self.question_payload.replace(&quot;QuestionName&quot;, title_slug)
            yield scrapy.FormRequest(url=self.graphql_url, callback=self.ParseQuestionData,
                                     headers=headers, body=self.question_payload)
            self.question_payload = self.question_payload.replace(title_slug, &quot;QuestionName&quot;)
</code></pre>

<p>现在数据已经获取到了，我们需要在items.py文件中定义一个类用来存储题目的详细信息。items.py文件中的类继承自scrapy.Item类，是提供给scrapy框架中的组件Item Pipeline进行处理的统一的的数据结构。</p>

<pre><code>import scrapy

class QuestionDataItem(scrapy.Item):
    # define the fields for your item here like:
    # name = scrapy.Field()
    id = scrapy.Field()
    title = scrapy.Field()
    content = scrapy.Field()
    submission_list = scrapy.Field()
    topics = scrapy.Field()
    difficulty = scrapy.Field()
    ac_rate = scrapy.Field()
    likes = scrapy.Field()
    dislikes = scrapy.Field()
    slug = scrapy.Field()
</code></pre>

<p>定义了QuestionDataItem类之后可以进入ParseQuestionData函数开始对题目详细信息的提取，我们可以根据需求提取出题目的id，title，content，topics，difficulty等信息，用一个QuestionDataItem对象来存储这些数据，然后进行yield questionDataItem操作，将这个对象交给Item Pipeline进行处理。</p>

<pre><code>    def ParseQuestionData(self, response):
        questionData = json.loads(response.text)[&quot;data&quot;][&quot;question&quot;]
        questionDataItem = QuestionDataItem()
        questionDataItem[&quot;id&quot;] = questionData[&quot;questionFrontendId&quot;]
        questionDataItem[&quot;title&quot;] = questionData[&quot;title&quot;]
        questionDataItem[&quot;content&quot;] = questionData[&quot;content&quot;]
        topics = []
        for topic in questionData[&quot;topicTags&quot;]:
            topics.append(topic[&quot;name&quot;])
        if len(topics) == 0:
            topics.append(&quot;None&quot;)
        questionDataItem[&quot;topics&quot;] = topics
        questionDataItem[&quot;difficulty&quot;] = questionData[&quot;difficulty&quot;]
        stats = json.loads(questionData[&quot;stats&quot;])
        questionDataItem[&quot;ac_rate&quot;] = stats[&quot;acRate&quot;]
        questionDataItem[&quot;likes&quot;] = questionData[&quot;likes&quot;]
        questionDataItem[&quot;dislikes&quot;] = questionData[&quot;dislikes&quot;]
        questionDataItem[&quot;slug&quot;] = questionData[&quot;titleSlug&quot;]
        submission_list = self.GetSubmissionList(questionDataItem[&quot;slug&quot;])
        questionDataItem[&quot;submission_list&quot;] = submission_list

        yield questionDataItem
</code></pre>

<p>至此题目信息的爬取就完成了。</p>

<h2 id="参考资料">参考资料</h2>

<p><a href="https://scrapy-chs.readthedocs.io/zh_CN/0.24/" target="_blank">Scrapy官方文档</a></p>

<p><a href="https://learning.getpostman.com/docs/postman/launching_postman/installation_and_updates/">Postman官方文档</a></p>
]]></content>
		</item>
		
		<item>
			<title>C&#43;&#43;智能指针（1.5）：move语义</title>
			<link>http://zintrulcre.vip/posts/c&#43;&#43;-smart-pointer-1.5/</link>
			<pubDate>Tue, 15 Jan 2019 09:55:05 +1100</pubDate>
			
			<guid>http://zintrulcre.vip/posts/c&#43;&#43;-smart-pointer-1.5/</guid>
			<description>move语义 定义 右值引用（Rvalue Referene）是 C++ 11中引入的新特性，它实现了转移语义（Move Sementics）和精确传递（P</description>
			<content type="html"><![CDATA[

<h2 id="move语义">move语义</h2>

<h3 id="定义">定义</h3>

<p>右值引用（Rvalue Referene）是 C++ 11中引入的新特性，它实现了转移语义（Move Sementics）和精确传递（Perfect Forwarding），其主要目的有
- 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
- 能够更简洁明确地定义泛型函数。</p>

<h3 id="实现">实现</h3>

<p>move语义的实现如下</p>

<pre><code>template &lt;class _Tp&gt;
typename remove_reference&lt;_Tp&gt;::type&amp;&amp;
move(_Tp&amp;&amp; __t) _NOEXCEPT
{
    typedef typename remove_reference&lt;_Tp&gt;::type _Up;
    return static_cast&lt;_Up&amp;&amp;&gt;(__t);
}
</code></pre>

<p>可以看到其实move语义的实现非常简单，它将传入的参数（__t）强制类型转换（static_cast）成了对应类型的右值（&lt;_Up&amp;&amp;&gt;）。也就是说，使用move语义之后，编译器窃取（一般会在移动构造函数和移动赋值操作符里将原有对象指向nullptr）了原有对象的右值，并延长了这个右值的生命周期，而没有对右值做任何拷贝操作，这个右值将被用来赋值给其他的对象。</p>

<h3 id="测试">测试</h3>

<p>定义一个obj类</p>

<pre><code>class Obj {
public:
    Obj() { std::cout &lt;&lt; &quot;Construct&quot; &lt;&lt; std::endl; }

    Obj(const Obj &amp;other) { std::cout &lt;&lt; &quot;Copy&quot; &lt;&lt; std::endl; }

    Obj(Obj &amp;&amp;other) noexcept { std::cout &lt;&lt; &quot;Move&quot; &lt;&lt; std::endl; }

    ~Obj() { std::cout &lt;&lt; &quot;Destruct&quot; &lt;&lt; std::endl; }

    void Print() { std::cout &lt;&lt; &quot;Print&quot; &lt;&lt; std::endl; }
};

</code></pre>

<p>定义一个Function函数，使用move语义返回</p>

<pre><code>Obj Function() {
    Obj obj;
    return move(obj);
}

int main() {
    Obj obj = Function();
    return 0;
}
/*
output:
Construct
Move
Destruct
Destruct
*/
</code></pre>

<p>可以看到在Function函数返回右值后，obj对象调用了移动构造函数，而不是拷贝构造函数。</p>

<h3 id="rvo-return-value-optimisation">RVO (return value optimisation)</h3>

<p>RVO（返回值优化）是一种编译器优化技术，允许编译器在调用点（<a href="https://en.wikipedia.org/wiki/Call_site" target="_blank">call site</a>）直接构造函数的返回值。</p>

<p>在Function函数中返回一个Obj对象</p>

<pre><code>Obj Function() {
    Obj obj;
    return obj; // NRVO (named return value optimisation)
}

int main() {
    Obj obj = Function();

    return 0;
}
/*
output:
Construct
Destruct
 */
</code></pre>

<p>原本Function函数在返回时应该会进行一次拷贝，然而调试结果却告诉我们obj只在Function函数中被构造了一次，在程序结束时被析构了一次。这是因为编译器使用了RVO机制。这里Function函数返回的是一个左值，所以又称NRVO（命名返回值优化）。这项技术在C++ 11里被称为Copy Elision（拷贝省略）。</p>

<p>如果我们在返回时使用move语义</p>

<pre><code>Obj Function() {
    Obj obj;
    return move(obj);
}

int main() {
    Obj obj = Function();
    return 0;
}
/*
output:
Construct
Move
Destruct
Destruct
*/
</code></pre>

<p>可以看到，因为使用了move语义，函数实际返回的是一个右值引用（Obj&amp;&amp;），而不是函数定义中的对象（Obj），没有触发RVO。也就是说，要触发RVO机制，必须保证函数实际的返回值类型和函数定义中的返回值类型一致。</p>

<p>如果我们把函数返回值类型改为右值引用</p>

<pre><code>Obj &amp;&amp;Function() {
    Obj obj;
    return move(obj);
}

int main() {
    Obj obj = Function();
    return 0;
}
/*
output:
Construct
Destruct
Move
Destruct
*/
</code></pre>

<p>可以看到main函数中的obj对象使用了移动构造函数，触发了RVO机制。</p>

<p>现在对函数稍加修改，再次运行</p>

<pre><code>Obj Function(bool flag) {
    Obj obj1, obj2;
    if(flag)
        return obj1;
    return obj2;
}

int main() {
    Obj obj = Function(true);
    return 0;
}
/*
output:
Construct
Construct
Move
Destruct
Destruct
Destruct
*/
</code></pre>

<p>这一次Function函数使用了两次默认构造函数构造了两个Obj对象，返回时又调用了一次移动构造函数（左值返回时编译器会优先使用移动构造函数，不支持移动构造时才调用拷贝构造函数），没有触发RVO机制。这是因为编译器使用了parent stack frame（父堆栈帧）来避免返回值拷贝，但如果在返回时使用了判断语句，编译器在编译时将不能确定将哪一个作为返回值，</p>

<h2 id="参考">参考</h2>

<p><a href="https://www.ibm.com/developerworks/community/blogs/5894415f-be62-4bc0-81c5-3956e82276f3/entry/RVO_V_S_std_move?lang=en" target="_blank">RVO V.S. std::move</a></p>

<p><a href="https://www.ibm.com/developerworks/cn/aix/library/1307_lisl_c11/index.html" target="_blank">右值引用与转移语义</a></p>
]]></content>
		</item>
		
		<item>
			<title>在Google Cloud Platform上运行Jupyter Notebook</title>
			<link>http://zintrulcre.vip/posts/run-jupyter-notebook-on-gcp/</link>
			<pubDate>Sat, 12 Jan 2019 17:03:12 +1100</pubDate>
			
			<guid>http://zintrulcre.vip/posts/run-jupyter-notebook-on-gcp/</guid>
			<description>简介 本文取材自 Amulya Aankul 发布在 Medium 的 Running Jupyter Notebook on Google Cloud Platform in 15 min，主要介绍如何在Google Cloud Platform上搭建服务器，并在服务器上安装和运行Jup</description>
			<content type="html"><![CDATA[

<h2 id="简介">简介</h2>

<p>本文取材自 <a href="https://towardsdatascience.com/@aankul.a" target="_blank">Amulya Aankul</a> 发布在 <a href="https://medium.com/" target="_blank">Medium</a> 的 <a href="https://towardsdatascience.com/running-jupyter-notebook-in-google-cloud-platform-in-15-min-61e16da34d52" target="_blank">Running Jupyter Notebook on Google Cloud Platform in 15 min</a>，主要介绍如何在Google Cloud Platform上搭建服务器，并在服务器上安装和运行Jupyter Notebook。</p>

<h2 id="服务器搭建">服务器搭建</h2>

<h3 id="创建账号">创建账号</h3>

<p>首先在<a href="https://cloud.google.com/" target="_blank">Google Cloud Platform</a>上创建一个账号。</p>

<h3 id="创建新项目">创建新项目</h3>

<p>点击左上角&rdquo;Google Cloud Platform&rdquo;右边的三个点，点击&rdquo;NEW PROJECT&rdquo;创建新项目。</p>

<p><img src="https://raw.githubusercontent.com/ZintrulCre/zintrulcre.github.io/master/data/Run-Jupyter-Notebook-on-GCP/1.png" alt="1" /></p>

<p><img src="https://raw.githubusercontent.com/ZintrulCre/zintrulcre.github.io/master/data/Run-Jupyter-Notebook-on-GCP/2.png" alt="2" /></p>

<h3 id="创建虚拟机">创建虚拟机</h3>

<p>进入刚才创建的项目，从左侧边栏点击 Compute Engine -&gt; VM instances 进入虚拟机页面。点击Create创建一个新的虚拟机实例（VM instance）</p>

<p><img src="https://raw.githubusercontent.com/ZintrulCre/zintrulcre.github.io/master/data/Run-Jupyter-Notebook-on-GCP/3.png" alt="3" />)</p>

<p>根据需求填写和选择 Name, Region, Zone, Machine Type和Boot Disk。在 Firewall 选项中选中 Allow HTTP traffic 和 Allow HTTPS traffic, 在下方的 Disks 选项卡中取消勾选 Delete boot disk when instance is deleted。最后点击 Create，虚拟机实例就创建好了。</p>

<p><img src="https://raw.githubusercontent.com/ZintrulCre/zintrulcre.github.io/master/data/Run-Jupyter-Notebook-on-GCP/4.png" alt="4" /></p>

<h3 id="设置静态ip">设置静态IP</h3>

<p>默认情况下，外网IP是动态变化的，为了方便访问服务器，我们可以将其设置为静态的。</p>

<p><img src="https://raw.githubusercontent.com/ZintrulCre/zintrulcre.github.io/master/data/Run-Jupyter-Notebook-on-GCP/5.png" alt="5" /></p>

<p>从左侧边栏点击 VPC Network -&gt; External IP Address，可以看到当前项目下的所有虚拟机，点击虚拟机实例对应的 Type 标签，点击 Ephemeral，将外网IP设置为静态的。</p>

<p><img src="https://raw.githubusercontent.com/ZintrulCre/zintrulcre.github.io/master/data/Run-Jupyter-Notebook-on-GCP/6.png" alt="6" /></p>

<h3 id="设置防火墙">设置防火墙</h3>

<p>从左侧边栏点击 VPC Network -&gt; Firewall rules，点击上方的 CREATE FIREWALL RULE，创建一个新的防火墙规则。</p>

<p><img src="https://raw.githubusercontent.com/ZintrulCre/zintrulcre.github.io/master/data/Run-Jupyter-Notebook-on-GCP/7.png" alt="7" /></p>

<p>根据需求填写 Name，将 Targets 勾选为 All instances in the network，在 Source IP ranges 中填写 0.0.0.0/0，在 Protocols and ports 中勾选 tcp，填写一个端口范围，用于之后访问 Jupyter Notebook。</p>

<p><img src="https://raw.githubusercontent.com/ZintrulCre/zintrulcre.github.io/master/data/Run-Jupyter-Notebook-on-GCP/8.png" alt="8" /></p>

<h3 id="连接虚拟机">连接虚拟机</h3>

<p>回到 VM instances，根据外网IP连接上刚才创建的虚拟机。可以直接从谷歌提供的 web 端终端连接，也可以通过其他途径连接。Windows 下可以使用Putty，Linux 和 Unix 系统可以直接使用SSH连接。</p>

<p><img src="https://raw.githubusercontent.com/ZintrulCre/zintrulcre.github.io/master/data/Run-Jupyter-Notebook-on-GCP/9.png" alt="9" /></p>

<h2 id="配置-jupyter-notebook">配置 Jupyter Notebook</h2>

<h3 id="安装-jupyter-notebook">安装 Jupyter Notebook</h3>

<p>在终端中输入<code>wget http://repo.continuum.io/archive/Anaconda3-4.0.0-Linux-x86_64.sh</code>
获取 Anaconda 3 的安装文件</p>

<p>接下来输入<code>bash Anaconda3-4.0.0-Linux-x86_64.sh</code>
运行该文件，并根据屏幕提示安装 Anaconda 3。</p>

<p>安装好之后读取启动文件<code>source ~/.bashrc</code>
以使用 Anaconda 3</p>

<h3 id="修改配置文件">修改配置文件</h3>

<p>创建 Jupyter Notebook 的配置文件<code>jupyter notebook --generate-config</code></p>

<p>使用Vim或其他编辑器打开该配置文件<code>vi ~/.jupyter/jupyter_notebook_config.py</code></p>

<p>在该文件中加入相应的设置</p>

<pre><code>c = get_config()
c.NotebookApp.ip = '*'
c.NotebookApp.open_browser = False
c.NotebookApp.port = &lt;Port Number&gt;
</code></pre>

<p>在 &lt;Port Number&gt; 处填写 Jupyter Notebook 使用的端口号，该端口号应该是在防火墙规则的端口范围之内的，否则将不能够通过外网IP和端口号访问 Jupyter Notebook。填写完之后使用<code>:wq</code>命令保存该文件。</p>

<p><img src="https://raw.githubusercontent.com/ZintrulCre/zintrulcre.github.io/master/data/Run-Jupyter-Notebook-on-GCP/10.png" alt="10" /></p>

<h3 id="启动-jupyter-notebook">启动 Jupyter Notebook</h3>

<p>最后，在浏览器中输入
<code>jupyter-notebook --no-browser --port=&lt;Port Number&gt;</code>
来启动 Jupyter Notebook，当然也可以使用
<code>nohup jupyter-notebook --no-browser --port=&lt;Port Number&gt; &gt; jupyter.log &amp;</code>
指令忽略挂起信号，让 Jupyter Notebook 一直在后台运行，并将控制台信息输出到 jupyter.log 文件中。</p>

<p>最后在浏览器中输入 IP 地址和端口号（例如156.73.83.51:4813）就能打开 Jupyter Notebook 了！</p>

<p><img src="https://raw.githubusercontent.com/ZintrulCre/zintrulcre.github.io/master/data/Run-Jupyter-Notebook-on-GCP/11.png" alt="11" /></p>

<h2 id="参考资料">参考资料</h2>

<p><a href="https://towardsdatascience.com/running-jupyter-notebook-in-google-cloud-platform-in-15-min-61e16da34d52" target="_blank">Running Jupyter Notebook on Google Cloud Platform in 15 min</a></p>
]]></content>
		</item>
		
		<item>
			<title>C&#43;&#43;智能指针（1）：auto_ptr</title>
			<link>http://zintrulcre.vip/posts/c&#43;&#43;-smart-pointer-1/</link>
			<pubDate>Mon, 07 Jan 2019 15:21:35 +1100</pubDate>
			
			<guid>http://zintrulcre.vip/posts/c&#43;&#43;-smart-pointer-1/</guid>
			<description>分析 C++中经常会出现因为没有delete指针而造成的内存泄漏，例如有下面一个类 class Obj { public: Obj() { std::cout &amp;lt;&amp;lt; &amp;quot;Construct&amp;quot; &amp;lt;&amp;lt; std::endl; } Obj(const Obj &amp;amp;other) { std::cout &amp;lt;&amp;lt; &amp;quot;Copy&amp;quot; &amp;lt;&amp;lt; std::endl; } Obj(Obj &amp;amp;&amp;amp;other) noexcept { std::cout &amp;lt;&amp;lt; &amp;quot;Move&amp;quot; &amp;lt;&amp;lt;</description>
			<content type="html"><![CDATA[

<h2 id="分析">分析</h2>

<p>C++中经常会出现因为没有delete指针而造成的内存泄漏，例如有下面一个类</p>

<pre><code>class Obj {
public:
    Obj() { std::cout &lt;&lt; &quot;Construct&quot; &lt;&lt; std::endl; }

    Obj(const Obj &amp;other) { std::cout &lt;&lt; &quot;Copy&quot; &lt;&lt; std::endl; }

    Obj(Obj &amp;&amp;other) noexcept { std::cout &lt;&lt; &quot;Move&quot; &lt;&lt; std::endl; }

    ~Obj() { std::cout &lt;&lt; &quot;Destruct&quot; &lt;&lt; std::endl; }

    void Print() { std::cout &lt;&lt; &quot;Print&quot; &lt;&lt; std::endl; }
};
</code></pre>

<p>创建一个指向Obj类型的指针</p>

<pre><code>int main() {
    Obj *o = new Obj();
    o-&gt;Print();
    return 0;
}
/*
output:
Construct
Print
*/
</code></pre>

<p>我们没有进行delete o的操作，导致o没有被正确地析构，造成了内存泄漏。作为对比，创建一个Obj类型的对象</p>

<pre><code>int main() {
    Obj *o1 = new Obj();
    o1-&gt;Print();
    Obj o2 = Obj();
    o2.Print();
    return 0;
}
/*
output:
Construct
Print
Construct
Print
Destruct
*/
</code></pre>

<p>产生这样的结果是因为对象创建在栈（<a href="https://isocpp.org/blog/2015/09/stack-heap-pool-tony-bulldozer00-bd00-dasilva" target="_blank">stack</a>）上，编译器会自动进行对象的创建和销毁，而指针是创建在堆（heap）上，需要手动进行创建和销毁。为了规避这样的问题，我们可以封装一个智能指针类，用类来管理指针，防止造成内存泄漏，并且尽可能的模仿指针的用法。</p>

<h2 id="实现">实现</h2>

<p>根据auto_ptr的源码，能够大致实现AutoPointer类</p>

<pre><code>template&lt;typename T&gt;
class AutoPointer {
public:
    explicit AutoPointer(T *t);

    ~AutoPointer();

    T &amp;operator*();

    T *operator-&gt;();

    T *release();

    void reset(T *p);

    AutoPointer(AutoPointer&lt;T&gt; &amp;other);

    AutoPointer&lt;T&gt; &amp;operator=(AutoPointer&lt;T&gt; &amp;other);

private:
    T *pointer;
};

template&lt;typename T&gt;
AutoPointer&lt;T&gt;::AutoPointer(T *t):pointer(t) {
    std::cout &lt;&lt; &quot;AutoPointer &quot; &lt;&lt; this &lt;&lt; &quot; constructor called.&quot; &lt;&lt; std::endl;
}

template&lt;typename T&gt;
AutoPointer&lt;T&gt;::~AutoPointer() {
    std::cout &lt;&lt; &quot;AutoPointer &quot; &lt;&lt; this &lt;&lt; &quot; destructor called.&quot; &lt;&lt; std::endl;
    delete pointer;
}

template&lt;typename T&gt;
T &amp;AutoPointer&lt;T&gt;::operator*() {
    return *pointer;
}

template&lt;typename T&gt;
T *AutoPointer&lt;T&gt;::operator-&gt;() {
    return pointer;
}

template&lt;typename T&gt;
T *AutoPointer&lt;T&gt;::release() {
    T *new_pointer = pointer;
    pointer = nullptr;
    return new_pointer;
}

template&lt;typename T&gt;
void AutoPointer&lt;T&gt;::reset(T *p) {
    if (pointer != p) {
        delete pointer;
        pointer = p;
    }
}

template&lt;typename T&gt;
AutoPointer&lt;T&gt;::AutoPointer(AutoPointer&lt;T&gt; &amp;other): pointer(other.release()) {
    std::cout &lt;&lt; &quot;AutoPointer &quot; &lt;&lt; this &lt;&lt; &quot; copy constructor called.&quot; &lt;&lt; std::endl;
}

template&lt;typename T&gt;
AutoPointer&lt;T&gt; &amp;AutoPointer&lt;T&gt;::operator=(AutoPointer&lt;T&gt; &amp;other) {
    std::cout &lt;&lt; &quot;AutoPointer &quot; &lt;&lt; this &lt;&lt; &quot; assignment operator called.&quot; &lt;&lt; std::endl;
    if (pointer != other.pointer)
        reset(other.release());
    return *this;
}
</code></pre>

<p>我们在进行拷贝构造时对参数对象的指针进行了release操作，也就是将参数对象的私有成员pointer指针置为了nullptr；在进行=操作时不仅对参数对象的指针进行了release操作，还delete掉了当前对象的pointer，再将pointer置为参数对象的pointer。这样的实现非常有效地规避了<a href="https://zh.wikipedia.org/wiki/%E8%BF%B7%E9%80%94%E6%8C%87%E9%92%88" target="_blank">迷途指针</a>（也称悬空指针或野指针）。</p>

<h2 id="测试">测试</h2>

<p>现在创建一个AutoPointer智能指针类试验一下</p>

<pre><code>int main() {
    Obj *o = new Obj();
    AutoPointer&lt;Obj&gt; a1(o);
    (*a1).Print();
    a1-&gt;Print();
    return 0;
}
/*
output:
Construct
AutoPointer 0x7fe680c02ab0 constructor called.
Print
Print
AutoPointer 0x7fe680c02ab0 destructor called.
Destruct
*/
</code></pre>

<p>在创建单个对象的时候能够正常地使用，现在创建两个AutoPointer类对象，用同一个Obj对象初始化</p>

<pre><code>int main() {
    Obj *o = new Obj();
    AutoPointer&lt;Obj&gt; a1(o);
    AutoPointer&lt;Obj&gt; a2(o);
    return 0;
}
</code></pre>

<p>输出结果是</p>

<pre><code>(7855,0x111b135c0) malloc: *** error for object 0x7fbe9fc02ab0: pointer being freed was not allocated
(7855,0x111b135c0) malloc: *** set a breakpoint in malloc_error_break to debug
</code></pre>

<p>s1, s2两个AutoPointer对象会各自调用一次析构函数，Obj对象的指针o被析构了两次，显然是有问题的。</p>

<p>再尝试使用拷贝构造函数</p>

<pre><code>int main() {
    Obj *o = new Obj();
    AutoPointer&lt;Obj&gt; a1(o);
    AutoPointer&lt;Obj&gt; a2(a1);
    return 0;
}
/*
output:
Construct
AutoPointer 0x7fd15bc02ab0 constructor called.
AutoPointer 0x7fd15bc02ab0 copy constructor called.
AutoPointer 0x7fd15bc02ab0 destructor called.
Destruct
AutoPointer 0x0 destructor called.
*/
</code></pre>

<p>看上去没有问题。但是o对象原本是属于s1的，在s2调用拷贝构造函数之后，s1的pointer变成了空指针，o对象属于了s2，这叫做所有权转换。</p>

<p>再尝试使用=操作符</p>

<pre><code>int main() {
    Obj *o = new Obj();
    AutoPointer&lt;Obj&gt; a1(o);
    AutoPointer&lt;Obj&gt; a2 = a1;
    return 0;
}
/*
output:
Construct
AutoPointer 0x7ff5d5402ab0 constructor called.
AutoPointer 0x7ff5d5402ab0 copy constructor called.
AutoPointer 0x7ff5d5402ab0 destructor called.
Destruct
AutoPointer 0x0 destructor called.
*/
</code></pre>

<p>同样的会发生所有权转移。
</p>

<h2 id="总结">总结</h2>

<p>AutoPointer虽然非常有效地解决了野指针问题，但又引入一些其他的问题，例如</p>

<p>1. 所有权转移</p>

<ul>
<li>应用于容器时可能会产生临时对象进行拷贝和赋值</li>
<li>将AutoPointer作为参数进行值传递时会进行拷贝构造</li>
</ul>

<p>2. 内存泄漏</p>

<ul>
<li>在析构函数中使用了delete进行指针的销毁，如果以数组指针进行初始化
<code>AutoPointer&lt;int&gt; s1(new int[10])</code>会因为没有销毁数组的其他元素发生内存泄漏</li>
</ul>

<h2 id="auto-ptr源码">auto_ptr源码</h2>

<pre><code>template&lt;class _Tp&gt;
class _LIBCPP_TEMPLATE_VIS auto_ptr
{
private:
    _Tp* __ptr_;
public:
    typedef _Tp element_type;

    _LIBCPP_INLINE_VISIBILITY explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}
    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr&amp; __p) throw() : __ptr_(__p.release()) {}
    template&lt;class _Up&gt; _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr&lt;_Up&gt;&amp; __p) throw()
        : __ptr_(__p.release()) {}
    _LIBCPP_INLINE_VISIBILITY auto_ptr&amp; operator=(auto_ptr&amp; __p) throw()
        {reset(__p.release()); return *this;}
    template&lt;class _Up&gt; _LIBCPP_INLINE_VISIBILITY auto_ptr&amp; operator=(auto_ptr&lt;_Up&gt;&amp; __p) throw()
        {reset(__p.release()); return *this;}
    _LIBCPP_INLINE_VISIBILITY auto_ptr&amp; operator=(auto_ptr_ref&lt;_Tp&gt; __p) throw()
        {reset(__p.__ptr_); return *this;}
    _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;}

    _LIBCPP_INLINE_VISIBILITY _Tp&amp; operator*() const throw()
        {return *__ptr_;}
    _LIBCPP_INLINE_VISIBILITY _Tp* operator-&gt;() const throw() {return __ptr_;}
    _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() {return __ptr_;}
    _LIBCPP_INLINE_VISIBILITY _Tp* release() throw()
    {
        _Tp* __t = __ptr_;
        __ptr_ = 0;
        return __t;
    }
    _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw()
    {
        if (__ptr_ != __p)
            delete __ptr_;
        __ptr_ = __p;
    }

    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_ref&lt;_Tp&gt; __p) throw() : __ptr_(__p.__ptr_) {}
    template&lt;class _Up&gt; _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref&lt;_Up&gt;() throw()
        {auto_ptr_ref&lt;_Up&gt; __t; __t.__ptr_ = release(); return __t;}
    template&lt;class _Up&gt; _LIBCPP_INLINE_VISIBILITY operator auto_ptr&lt;_Up&gt;() throw()
        {return auto_ptr&lt;_Up&gt;(release());}
};
</code></pre>
]]></content>
		</item>
		
		<item>
			<title>使用Scrapy爬取LeetCode（1）：Scrapy框架入门</title>
			<link>http://zintrulcre.vip/posts/use-scrapy-to-crawl-leetcode-1/</link>
			<pubDate>Thu, 03 Jan 2019 11:25:15 +1100</pubDate>
			
			<guid>http://zintrulcre.vip/posts/use-scrapy-to-crawl-leetcode-1/</guid>
			<description>本项目ZintrulCre/LeetCode_Crawler已完成，并正在维护中，欢迎在GitHub上star和fork。 简介 Scrapy官</description>
			<content type="html"><![CDATA[

<p>本项目<a href="https://github.com/ZintrulCre/LeetCode_Crawler" target="_blank">ZintrulCre/LeetCode_Crawler</a>已完成，并正在维护中，欢迎在GitHub上star和fork。</p>

<h2 id="简介">简介</h2>

<p>Scrapy官方文档对Scrapy的介绍如下：</p>

<p>Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。<br>其最初是为了页面抓取（更确切来说, 网络抓取）所设计的，也可以应用在获取API所返回的数据（例如 Amazon Associates Web Services ）或者通用的网络爬虫。</p>

<p>简而言之，Scrapy是基于Twisted库开发的，封装了http请求、代理信息、数据存储等功能的Python爬虫框架。</p>

<h2 id="组件和数据流">组件和数据流</h2>

<p>下图是Scrapy官方文档中的架构概览图：</p>

<p><img src="https://scrapy-chs.readthedocs.io/zh_CN/0.24/_images/scrapy_architecture.png" alt="Architecture" /></p>

<p>图中绿色箭头表示<a href="#head">数据流</a>，其他均为组件。</p>

<h3 id="scrapy-engine-引擎">Scrapy Engine（引擎）</h3>

<p>引擎负责控制数据流在系统的组件中流动，并在相应动作发生时触发事件。</p>

<h3 id="scheduler-调度器">Scheduler（调度器）</h3>

<p>调度器从引擎接收request并将其保存，以便在引擎请求时提供给引擎。</p>

<h3 id="downloader-下载器">Downloader（下载器）</h3>

<p>下载器负责下载页面数据，并将其提供给引擎，而后再由引擎提供给爬虫。</p>

<h3 id="spiders-爬虫">Spiders（爬虫）</h3>

<p>Spider是由用户编写的用于<strong>分析response</strong>并<strong>提取item</strong>或额外<strong>跟进url</strong>的类。一个Scrapy项目中可以有很多Spider，他们分别被用于爬取不同的页面和网站。</p>

<h3 id="item-pipeline-管道">Item Pipeline（管道）</h3>

<p>Item Pipeline负责处理被爬虫<strong>提取出来的item</strong>。可以对其进行数据清洗，验证和持久化（例如存储到数据库中）。</p>

<h3 id="downloader-middlewares-下载器中间件">Downloader middlewares（下载器中间件）</h3>

<p>下载器中间件是在引擎及下载器之间的组件，用于处理下载器传递给引擎的response。更多内容请参考<a href="https://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/downloader-middleware.html#topics-downloader-middleware" target="_blank">下载器中间件</a>。</p>

<h3 id="spider-middlewares-爬虫中间件">Spider middlewares（爬虫中间件）</h3>

<p>Spider中间件是在引擎及Spider之间的组件，用于处理爬虫的输入（response）和输出（items和requests）。更多内容请参考<a href="https://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/spider-middleware.html#topics-spider-middleware" target="_blank">爬虫中间件</a>。</p>

<h3 id="a-id-head-data-flow-数据流-a"><a id="head"/> Data flow（数据流）</a></h3>

<p>Scrapy中的数据流由引擎控制，其过程如下:<br>
1.引擎打开一个网站，找到处理该网站的爬虫并向该爬虫请求要爬取的url。<br>
2.引擎从爬虫中获取到要爬取的url并将其作为request发送给调度器。<br>
3.引擎向调度器请求下一个要爬取的url。<br>
4.调度器返回下一个要爬取的url给引擎，引擎将url通过下载器中间件发送给下载器。<br>
5.下载器下载页面成功后，生成一个该页面的response对象，并将其通过下载器中间件发送给引擎。<br>
6.引擎接收从下载器中间件发送过来的response，并将其通过爬虫中间件发送给爬虫处理。<br>
7.爬虫处理response，并将爬取到的item及跟进的新的request发送给引擎。<br>
8.引擎将爬虫返回的item发送给管道，将爬虫返回的新的request发送给调度器。<br>
9.管道对item进行相应的处理。<br>
10.重复第二步，直到调度器中没有更多的request，此时引擎关闭该网站。<br></p>

<h2 id="安装">安装</h2>

<p>1.下载安装最新版的<a href="https://www.python.org/downloads/" target="_blank">Python3</a></p>

<p>2.使用pip指令安装Scrapy</p>

<pre><code>pip3 install scrapy
</code></pre>

<h2 id="创建项目">创建项目</h2>

<p>首先进入你的代码存储目录，在命令行中输入以下命令：</p>

<pre><code>scrapy startproject LeetCode_Crawler
</code></pre>

<p>注意项目名称是不能包含连字符 &lsquo;-&rsquo; 的</p>

<p>新建成功后，可以看到在当前目录下新建了一个名为LeetCode_Crawler的Scrapy项目，进入该目录，其项目结构如下：</p>

<pre><code>scrapy.cfg              #该项目的配置文件
scrapy_project          #该项目的Python模块
    __init__.py
    items.py            #可自定义的item类文件
    middlewares.py      #中间件文件
    pipelines.py        #管道文件
    settings.py         #设置文件
    __pycache__
    spiders             #爬虫文件夹，所有爬虫文件都应在该文件夹下
        __init__.py
        __pycache__
</code></pre>

<p>至此Scrapy项目的创建就完成了。</p>

<h2 id="参考资料">参考资料</h2>

<p><a href="https://scrapy-chs.readthedocs.io/zh_CN/0.24/" target="_blank">Scrapy官方文档</a></p>
]]></content>
		</item>
		
	</channel>
</rss>
