<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on ZinBlog</title>
    <link>http://zintrulcre.vip/posts/</link>
    <description>Recent content in Posts on ZinBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Wed, 20 Mar 2019 09:55:04 +1100</lastBuildDate>
    
	<atom:link href="http://zintrulcre.vip/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Methods to Prevent Overfitting in Deep Learning</title>
      <link>http://zintrulcre.vip/posts/deep-learning/methods-to-prevent-overfitting-in-deep-learning/</link>
      <pubDate>Wed, 20 Mar 2019 09:55:04 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/posts/deep-learning/methods-to-prevent-overfitting-in-deep-learning/</guid>
      <description>Methods to Prevent Overfitting in Deep Learning Overfitting Overfitting refers to that when a model fits the training data well but cannot predict the test data correctly, we may say that the model lacks the ability of generalization. It is important to figure out how it happens, and how we can prevent overfitting from the very beginning.
Detect Overfitting The simplest way to detect overfitting is to split the dataset into two parts: the training set for training the model, and the test set for testing the accuracy of the model on a dataset that it has never seen before.</description>
    </item>
    
    <item>
      <title>LeetCode 208 实现 Trie (前缀树)</title>
      <link>http://zintrulcre.vip/posts/leetcode/208/</link>
      <pubDate>Fri, 15 Mar 2019 10:56:12 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/posts/leetcode/208/</guid>
      <description>LeetCode 208 实现 Trie (前缀树) 实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。 示例: Trie trie = new Trie(); trie.insert(&amp;#34;apple&amp;#34;); trie.search(&amp;#34;apple&amp;#34;); // 返回 true trie.search(&amp;#34;app&amp;#34;); // 返回 false trie.startsWith(&amp;#34;app&amp;#34;); // 返回 true trie.insert(&amp;#34;app&amp;#34;); trie.search(&amp;#34;app&amp;#34;); // 返回 true 说明: 你可以假</description>
    </item>
    
    <item>
      <title>LeetCode 98 验证二叉搜索树</title>
      <link>http://zintrulcre.vip/posts/leetcode/98/</link>
      <pubDate>Tue, 12 Feb 2019 21:44:35 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/posts/leetcode/98/</guid>
      <description>LeetCode 98 验证二叉搜索树 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点</description>
    </item>
    
    <item>
      <title>LeetCode 560 和为K的子数组</title>
      <link>http://zintrulcre.vip/posts/leetcode/560/</link>
      <pubDate>Wed, 06 Feb 2019 22:11:18 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/posts/leetcode/560/</guid>
      <description>LeetCode 560 和为K的子数组 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例 1: 输入:nums = [1,1,1], k = 2 输出: 2 , [1,1] 与 [1,1]</description>
    </item>
    
    <item>
      <title>C&#43;&#43;智能指针（3）：shared_ptr</title>
      <link>http://zintrulcre.vip/posts/c&#43;&#43;-smart-pointer/c&#43;&#43;-smart-pointer-3/</link>
      <pubDate>Fri, 25 Jan 2019 17:47:38 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/posts/c&#43;&#43;-smart-pointer/c&#43;&#43;-smart-pointer-3/</guid>
      <description>分析 UniquePointer对象只能绑定单个指针，要实现指针的自动管理和销毁需要引入计数器 private: int *counter; T *pointer; D *deleter; 计数器的主要作用是标识当前指针被几</description>
    </item>
    
    <item>
      <title>C&#43;&#43;智能指针（2）：unique_ptr</title>
      <link>http://zintrulcre.vip/posts/c&#43;&#43;-smart-pointer/c&#43;&#43;-smart-pointer-2/</link>
      <pubDate>Sat, 19 Jan 2019 01:02:02 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/posts/c&#43;&#43;-smart-pointer/c&#43;&#43;-smart-pointer-2/</guid>
      <description>分析 在使用auto_ptr的时候会发生所有权转移和内存泄漏的问题，所以我们可以对AutoPointer类稍加修改，修复这两个问题。 所有权转</description>
    </item>
    
    <item>
      <title>LeetCode Archiver(3): 登录</title>
      <link>http://zintrulcre.vip/posts/use-scrapy-to-crawl-leetcode/use-scrapy-to-crawl-leetcode-3/</link>
      <pubDate>Fri, 11 Jan 2019 13:15:17 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/posts/use-scrapy-to-crawl-leetcode/use-scrapy-to-crawl-leetcode-3/</guid>
      <description>Cookie和Session 为了获取我们自己的提交记录，我们首先要进行登录的操作。但我们都知道HTTP是一种无状态的协议，它的每个请求都是独</description>
    </item>
    
    <item>
      <title>C&#43;&#43;智能指针（1.5）：move语义</title>
      <link>http://zintrulcre.vip/posts/c&#43;&#43;-smart-pointer/c&#43;&#43;-smart-pointer-1.5/</link>
      <pubDate>Wed, 02 Jan 2019 09:55:05 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/posts/c&#43;&#43;-smart-pointer/c&#43;&#43;-smart-pointer-1.5/</guid>
      <description>move语义 定义 右值引用（Rvalue Referene）是 C++ 11中引入的新特性，它实现了转移语义（Move Sementics）和精确传递（P</description>
    </item>
    
    <item>
      <title>C&#43;&#43;智能指针（1）：auto_ptr</title>
      <link>http://zintrulcre.vip/posts/c&#43;&#43;-smart-pointer/c&#43;&#43;-smart-pointer-1/</link>
      <pubDate>Thu, 27 Dec 2018 15:21:35 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/posts/c&#43;&#43;-smart-pointer/c&#43;&#43;-smart-pointer-1/</guid>
      <description>分析 C++中经常会出现因为没有delete指针而造成的内存泄漏，例如有下面一个类 class Obj { public: Obj() { std::cout &amp;lt;&amp;lt; &amp;#34;Construct&amp;#34; &amp;lt;&amp;lt; std::endl; } Obj(const Obj &amp;amp;other) { std::cout &amp;lt;&amp;lt; &amp;#34;Copy&amp;#34; &amp;lt;&amp;lt; std::endl; } Obj(Obj &amp;amp;&amp;amp;other) noexcept { std::cout &amp;lt;&amp;lt; &amp;#34;Move&amp;#34; &amp;lt;&amp;lt;</description>
    </item>
    
    <item>
      <title>LeetCode Archiver(2): 获取题目信息</title>
      <link>http://zintrulcre.vip/posts/use-scrapy-to-crawl-leetcode/use-scrapy-to-crawl-leetcode-2/</link>
      <pubDate>Fri, 21 Dec 2018 15:06:01 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/posts/use-scrapy-to-crawl-leetcode/use-scrapy-to-crawl-leetcode-2/</guid>
      <description>创建爬虫 在新建好项目后，用PyCharm或其他IDE打开该项目。进入该项目文件夹，使用genspider命令新建一个爬虫： cd scrapy_project scrapy genspider QuestionSetSpider leetcode.com 其中Q</description>
    </item>
    
  </channel>
</rss>