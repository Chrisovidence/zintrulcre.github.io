<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on ZintrulCre</title>
    <link>https://zintrulcre.vip/posts/</link>
    <description>Recent content in Posts on ZintrulCre</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Sat, 13 Apr 2019 15:28:11 +1000</lastBuildDate>
    
	<atom:link href="https://zintrulcre.vip/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Code Jam 2019 Qualification Round</title>
      <link>https://zintrulcre.vip/posts/code-jam/2019-round-1a/</link>
      <pubDate>Sat, 13 Apr 2019 15:28:11 +1000</pubDate>
      
      <guid>https://zintrulcre.vip/posts/code-jam/2019-round-1a/</guid>
      <description>Code Jam 2019 Round 1A Pylons (8pts, 23pts) 在m*n的网格里移动，每次移动后的位置不能与之前的位置在同一行/列/对角线上。 Solution: BackTracking 类似于八皇后问题，不过每次的限制条件只和上</description>
    </item>
    
    <item>
      <title>Code Jam 2019 Qualification Round</title>
      <link>https://zintrulcre.vip/posts/code-jam/2019-qualification-round/</link>
      <pubDate>Sat, 06 Apr 2019 13:40:27 +1000</pubDate>
      
      <guid>https://zintrulcre.vip/posts/code-jam/2019-qualification-round/</guid>
      <description>Code Jam 2019 Qualification Round Foregone Solution (6pts, 10pts, 1pts) 将一个带有数字4的数拆分为两个不带数字4的数。 Solution: Construction 输入的数一定带有数字4，对于每一位上的数字4，我们可以将其拆分为2+2</description>
    </item>
    
    <item>
      <title>Kick Start 2019 Round A</title>
      <link>https://zintrulcre.vip/posts/kick-start/2019-round-a/</link>
      <pubDate>Tue, 26 Mar 2019 14:25:36 +1100</pubDate>
      
      <guid>https://zintrulcre.vip/posts/kick-start/2019-round-a/</guid>
      <description>Kick Start 2019 Round A Training (7pts, 13pts) 一共有N个人，从中选P个人，计算这P个人中 skill rating 的最大值与其他人的 skill rating 的差值之和。 \[ \sum_{i}^{j} max(rating) - rating[i] \] Solution: Sort + Prefix Sum 先对数组排序，然后在长</description>
    </item>
    
    <item>
      <title>Methods to Prevent Overfitting in Deep Learning</title>
      <link>https://zintrulcre.vip/posts/deep-learning/methods-to-prevent-overfitting-in-deep-learning/</link>
      <pubDate>Wed, 20 Mar 2019 09:55:04 +1100</pubDate>
      
      <guid>https://zintrulcre.vip/posts/deep-learning/methods-to-prevent-overfitting-in-deep-learning/</guid>
      <description>Methods to Prevent Overfitting in Deep Learning Overfitting Overfitting refers to that when a model fits the training data well but cannot predict the test data correctly, we may say that the model lacks the ability of generalization. It is important to figure out how it happens, and how we can prevent overfitting from the very beginning.
Detect Overfitting The simplest way to detect overfitting is to split the dataset into two parts: the training set for training the model, and the test set for testing the accuracy of the model on a dataset that it has never seen before.</description>
    </item>
    
    <item>
      <title>LeetCode 208 实现 Trie (前缀树)</title>
      <link>https://zintrulcre.vip/posts/leetcode/208/</link>
      <pubDate>Fri, 15 Mar 2019 10:56:12 +1100</pubDate>
      
      <guid>https://zintrulcre.vip/posts/leetcode/208/</guid>
      <description>LeetCode 208 实现 Trie (前缀树) 实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。 示例: Trie trie = new Trie(); trie.insert(&amp;#34;apple&amp;#34;); trie.search(&amp;#34;apple&amp;#34;); // 返回 true trie.search(&amp;#34;app&amp;#34;); // 返回 false trie.startsWith(&amp;#34;app&amp;#34;); // 返回 true trie.insert(&amp;#34;app&amp;#34;); trie.search(&amp;#34;app&amp;#34;); // 返回 true 说明: 你可以假</description>
    </item>
    
    <item>
      <title>LeetCode 98 验证二叉搜索树</title>
      <link>https://zintrulcre.vip/posts/leetcode/98/</link>
      <pubDate>Tue, 12 Feb 2019 21:44:35 +1100</pubDate>
      
      <guid>https://zintrulcre.vip/posts/leetcode/98/</guid>
      <description>LeetCode 98 验证二叉搜索树 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点</description>
    </item>
    
    <item>
      <title>LeetCode 560 和为K的子数组</title>
      <link>https://zintrulcre.vip/posts/leetcode/560/</link>
      <pubDate>Wed, 06 Feb 2019 22:11:18 +1100</pubDate>
      
      <guid>https://zintrulcre.vip/posts/leetcode/560/</guid>
      <description>LeetCode 560 和为K的子数组 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例 1: 输入:nums = [1,1,1], k = 2 输出: 2 , [1,1] 与 [1,1]</description>
    </item>
    
    <item>
      <title>C&#43;&#43;智能指针（3）：shared_ptr</title>
      <link>https://zintrulcre.vip/posts/c&#43;&#43;/c&#43;&#43;-smart-pointer-3/</link>
      <pubDate>Fri, 25 Jan 2019 17:47:38 +1100</pubDate>
      
      <guid>https://zintrulcre.vip/posts/c&#43;&#43;/c&#43;&#43;-smart-pointer-3/</guid>
      <description>C++智能指针（3）：shared_ptr 分析 UniquePointer对象只能绑定单个指针，要实现指针的自动管理和销毁需要引入计数器 private: int *counter;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;智能指针（2）：unique_ptr</title>
      <link>https://zintrulcre.vip/posts/c&#43;&#43;/c&#43;&#43;-smart-pointer-2/</link>
      <pubDate>Sat, 19 Jan 2019 01:02:02 +1100</pubDate>
      
      <guid>https://zintrulcre.vip/posts/c&#43;&#43;/c&#43;&#43;-smart-pointer-2/</guid>
      <description>C++智能指针（2）：unique_ptr 分析 在使用auto_ptr的时候会发生所有权转移和内存泄漏的问题，所以我们可以对AutoPoint</description>
    </item>
    
    <item>
      <title>LeetCode Archiver(3)： 登录</title>
      <link>https://zintrulcre.vip/posts/leetcode-archiver/leetcode-archiver3/</link>
      <pubDate>Fri, 11 Jan 2019 13:15:17 +1100</pubDate>
      
      <guid>https://zintrulcre.vip/posts/leetcode-archiver/leetcode-archiver3/</guid>
      <description>Cookie和Session 为了获取我们自己的提交记录，我们首先要进行登录的操作。但我们都知道HTTP是一种无状态的协议，它的每个请求都是独</description>
    </item>
    
  </channel>
</rss>