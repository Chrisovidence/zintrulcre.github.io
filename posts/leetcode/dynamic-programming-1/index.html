<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Zhengyu Chen">
    <meta name="description" content="ZintrulCre&#39;s Personal Website">
    <meta name="keywords" content="ZintrulCre, Personal Website">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="LeetCode 动态规划（1）"/>
<meta name="twitter:description" content="LeetCode 动态规划 题目 1. 丑数 丑数是质因数只有 2, 3, 5 的正整数。丑数类的题目用暴力法一般都会 TLE，可以用 DP 来将时间复杂度优化到 O(m * n)，其中 m 是质因数"/>

    <meta property="og:title" content="LeetCode 动态规划（1）" />
<meta property="og:description" content="LeetCode 动态规划 题目 1. 丑数 丑数是质因数只有 2, 3, 5 的正整数。丑数类的题目用暴力法一般都会 TLE，可以用 DP 来将时间复杂度优化到 O(m * n)，其中 m 是质因数" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zintrulcre.vip/posts/leetcode/dynamic-programming-1/" />
<meta property="article:published_time" content="2019-06-26T18:08:10&#43;10:00"/>
<meta property="article:modified_time" content="2019-06-26T18:08:10&#43;10:00"/>


    
      <base href="https://zintrulcre.vip/posts/leetcode/dynamic-programming-1/">
    
    <title>
  LeetCode 动态规划（1） · ZintrulCre
</title>

    
      <link rel="canonical" href="https://zintrulcre.vip/posts/leetcode/dynamic-programming-1/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="https://zintrulcre.vip/css/coder.min.28d751104f30c16da1aa1bb04015cbe662cacfe0d1b01af4f2240ad58580069c.css" integrity="sha256-KNdREE8wwW2hqhuwQBXL5mLKz&#43;DRsBr08iQK1YWABpw=" crossorigin="anonymous" media="screen" />
    

    

    

    

    <link rel="icon" type="image/png" href="https://zintrulcre.vip/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://zintrulcre.vip/images/favicon-16x16.png" sizes="16x16">

    <meta name="generator" content="Hugo 0.55.2" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://zintrulcre.vip">
      ZintrulCre
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://zintrulcre.vip/posts/">Posts</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://zintrulcre.vip/about/">About</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">LeetCode 动态规划（1）</h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fas fa-calendar"></i>
              <time datetime='2019-06-26T18:08:10&#43;10:00'>
                June 26, 2019
              </time>
            </span>
            
          </div>
          <div class="categories">
  <i class="fas fa-folder"></i>
    <a href="https://zintrulcre.vip/categories/leetcode/">LeetCode</a></div>

          
        </div>
      </header>

      <div>
        

<h1 id="leetcode-动态规划-https-leetcode-cn-com-problemset-all-search-e4-b8-91-e6-95-b0"><a href="https://leetcode-cn.com/problemset/all/?search=%E4%B8%91%E6%95%B0">LeetCode 动态规划</a></h1>

<h2 id="题目">题目</h2>

<h3 id="1-丑数">1. 丑数</h3>

<p>丑数是质因数只有 2, 3, 5 的正整数。丑数类的题目用暴力法一般都会 TLE，可以用 DP 来将时间复杂度优化到 O(m * n)，其中 m 是质因数的个数，n 是要找的第n个丑数。</p>

<h4 id="263-丑数-https-leetcode-cn-com-problems-ugly-number"><a href="https://leetcode-cn.com/problems/ugly-number/">263 丑数</a></h4>

<p>判断一个数 num 是否是丑数。</p>

<p>通用的方法是用 DP 自底向上求出大于等于 num 的第一个数来判断 num 是否是丑数。但这道题已经给出了数 num，直接通过模运算就能得到结果了。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">bool</span> isUgly(<span style="color:#fff;font-weight:bold">int</span> num) {
        <span style="color:#fff;font-weight:bold">if</span> (num &lt; <span style="color:#ff0;font-weight:bold">1</span>)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">false</span>;
        <span style="color:#fff;font-weight:bold">while</span> (num % <span style="color:#ff0;font-weight:bold">2</span> == <span style="color:#ff0;font-weight:bold">0</span>)
            num /= <span style="color:#ff0;font-weight:bold">2</span>;
        <span style="color:#fff;font-weight:bold">while</span> (num % <span style="color:#ff0;font-weight:bold">3</span> == <span style="color:#ff0;font-weight:bold">0</span>)
            num /= <span style="color:#ff0;font-weight:bold">3</span>;
        <span style="color:#fff;font-weight:bold">while</span> (num % <span style="color:#ff0;font-weight:bold">5</span> == <span style="color:#ff0;font-weight:bold">0</span>)
            num /= <span style="color:#ff0;font-weight:bold">5</span>;
        <span style="color:#fff;font-weight:bold">return</span> num == <span style="color:#ff0;font-weight:bold">1</span>;
    }
};
</code></pre></div>
<h4 id="264-丑数-ii-https-leetcode-cn-com-problems-ugly-number-ii-comments"><a href="https://leetcode-cn.com/problems/ugly-number-ii/comments/">264 丑数 II</a></h4>

<p>求第 n 个丑数。</p>

<p>用一个数组 ugly 来保存前 m 个丑数，用三个质因数 2，3，5 乘以其当前系数对应的丑数，得到新的丑数，最小的一个就是第 m + 1 个丑数。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> nthUglyNumber(<span style="color:#fff;font-weight:bold">int</span> n) {
        vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; ugly(n, <span style="color:#ff0;font-weight:bold">1</span>);
        <span style="color:#fff;font-weight:bold">int</span> base_2 = <span style="color:#ff0;font-weight:bold">0</span>, base_3 = <span style="color:#ff0;font-weight:bold">0</span>, base_5 = <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">int</span> m = INT_MAX;
        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">1</span>; i &lt; n; ++i) {
            ugly[i] = min({<span style="color:#ff0;font-weight:bold">2</span> * ugly[base_2], <span style="color:#ff0;font-weight:bold">3</span> * ugly[base_3], <span style="color:#ff0;font-weight:bold">5</span> * ugly[base_5]});
            <span style="color:#fff;font-weight:bold">if</span> (<span style="color:#ff0;font-weight:bold">2</span> * ugly[base_2] == ugly[i])
                ++base_2;
            <span style="color:#fff;font-weight:bold">if</span> (<span style="color:#ff0;font-weight:bold">3</span> * ugly[base_3] == ugly[i])
                ++base_3;
            <span style="color:#fff;font-weight:bold">if</span> (<span style="color:#ff0;font-weight:bold">5</span> * ugly[base_5] == ugly[i])
                ++base_5;
            cout &lt;&lt; ugly[i] &lt;&lt; endl;
        }
        <span style="color:#fff;font-weight:bold">return</span> ugly[n - <span style="color:#ff0;font-weight:bold">1</span>];
    }
};
</code></pre></div>
<h4 id="313-超级丑数-https-leetcode-cn-com-problems-super-ugly-number-submissions"><a href="https://leetcode-cn.com/problems/super-ugly-number/submissions/">313 超级丑数</a></h4>

<p>给定质因数数组 primes，求第 n 个丑数。</p>

<p>跟上一题完全相同，只是把原有的三个质因数 2，3，5 换成了一个数组。时间复杂度是 O(n * m)，其中 n 是第 n 个丑数，m 是数组的长度。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> nthSuperUglyNumber(<span style="color:#fff;font-weight:bold">int</span> N, vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;&amp; primes) {
        <span style="color:#fff;font-weight:bold">int</span> n = primes.size(), m = INT_MAX;;
        vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; ugly(N, <span style="color:#ff0;font-weight:bold">1</span>), base(n, <span style="color:#ff0;font-weight:bold">0</span>);
        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">1</span>; i &lt; N; ++i) {
            m = INT_MAX;
            <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> j = <span style="color:#ff0;font-weight:bold">0</span>; j &lt; n; ++j)
                m = min(m, primes[j] * ugly[base[j]]);
            ugly[i] = m;
            <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> j = <span style="color:#ff0;font-weight:bold">0</span>; j &lt; n; ++j)
                <span style="color:#fff;font-weight:bold">if</span> (primes[j] * ugly[base[j]] == m)
                    ++base[j];
        }
        <span style="color:#fff;font-weight:bold">return</span> ugly[N - <span style="color:#ff0;font-weight:bold">1</span>];
    }
};
</code></pre></div>
<h3 id="2-买卖股票">2. 买卖股票</h3>

<h4 id="121-买卖股票的最佳时机-https-leetcode-cn-com-problems-best-time-to-buy-and-sell-stock"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121 买卖股票的最佳时机</a></h4>

<p>给一个股票数组，只能进行一次交易，求最大利润。</p>

<p>最大化当前值与之前的最小值之差。时间复杂度是 O(n)。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> maxProfit(vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;&amp; prices) {
        <span style="color:#fff;font-weight:bold">int</span> min_val = INT_MAX, res = <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">auto</span> &amp;p:prices) {
            min_val = min(min_val, p);
            res = max(res, p - min_val);
        }
        <span style="color:#fff;font-weight:bold">return</span> res;
    }
};
</code></pre></div>
<h4 id="122-买卖股票的最佳时机-ii-https-leetcode-cn-com-problems-best-time-to-buy-and-sell-stock-ii"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122 买卖股票的最佳时机 II</a></h4>

<p>给一个股票数组，不限制交易次数，求最大利润。</p>

<p>每一个严格递增的区间都是交易的时机，所以将严格递增区间内的差值全部加上即可。时间复杂度是 O(n)。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> maxProfit(vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; &amp;prices) {
        <span style="color:#fff;font-weight:bold">int</span> res = <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">1</span>; i &lt; prices.size(); ++i)
            res += max(prices[i] - prices[i - <span style="color:#ff0;font-weight:bold">1</span>], <span style="color:#ff0;font-weight:bold">0</span>);
        <span style="color:#fff;font-weight:bold">return</span> res;
    }
};
</code></pre></div>
<h4 id="123-买卖股票的最佳时机-iii-https-leetcode-cn-com-problems-best-time-to-buy-and-sell-stock-iii"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123 买卖股票的最佳时机 III</a></h4>

<p>给一个股票数组，只能进行两笔交易，求最大利润。</p>

<p>因为要进行两笔交易，所以需要最大化两个值：一个是到第 i 天为止的最大收益，一个是第 i 天之后的最大收益。第一种方法是两次遍历，第一次计算到第 i 天为止的最大收益，第二次反向遍历计算第 i 天之后的最大收益，方法跟第一题相同，注意第二次买入操作必须在第一次卖出操作之后，不能发生在同一天。时间复杂度是 O(n)。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> maxProfit(vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; &amp;prices) {
        <span style="color:#fff;font-weight:bold">int</span> n = prices.size(), pre_min = INT_MAX, post_max = <span style="color:#ff0;font-weight:bold">0</span>, res = <span style="color:#ff0;font-weight:bold">0</span>;
        vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; pre(n, <span style="color:#ff0;font-weight:bold">0</span>), post(n, <span style="color:#ff0;font-weight:bold">0</span>);
        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; n - <span style="color:#ff0;font-weight:bold">1</span>; ++i) {
            pre_min = min(pre_min, prices[i]);
            pre[i] = max(pre[max(<span style="color:#ff0;font-weight:bold">0</span>, i - <span style="color:#ff0;font-weight:bold">1</span>)], prices[i] - pre_min);
        }
        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = n - <span style="color:#ff0;font-weight:bold">1</span>; i &gt;= <span style="color:#ff0;font-weight:bold">0</span>; --i) {
            post_max = max(post_max, prices[i]);
            post[i] = max(post[min(n - <span style="color:#ff0;font-weight:bold">1</span>, i + <span style="color:#ff0;font-weight:bold">1</span>)], post_max - prices[i]);
        }
        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; n; ++i)
            res = max(res, pre[i] + post[i]);
        <span style="color:#fff;font-weight:bold">return</span> res;
    }
};
</code></pre></div>
<p>第二种方法则是基于每天只有四种可能的操作：第一次买入，第一次卖出 res1，第二次买入，和第二次卖出 res2。第一次买入需要最大化之前买入股票的最小花费，第一次卖出需要最大化到第 i 天为止的股票价格与第一次买入的差值，第二次买入需要最大化在第 i 天买入股票并减去第一次卖出的收益，最后第二次卖出需要最大化到第 i 天为止的股票价格与第二次买入的差值。最后得到第二次卖出的最优值。时间复杂度是 O(n)。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> maxProfit(vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; &amp;prices) {
        <span style="color:#fff;font-weight:bold">int</span> buy1 = INT_MIN, sell1 = <span style="color:#ff0;font-weight:bold">0</span>, buy2 = INT_MIN, sell2 = <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">auto</span> &amp;p:prices) {
            buy1 = max(buy1, -p);
            sell1 = max(sell1, p + buy1);
            buy2 = max(buy2, sell1 - p);
            sell2 = max(sell2, p + buy2);
            cout &lt;&lt; buy1 &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39; &#39;</span> &lt;&lt; sell1 &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39; &#39;</span> &lt;&lt; buy2 &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39; &#39;</span> &lt;&lt; sell2 &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39; &#39;</span> &lt;&lt; endl;
        }
        <span style="color:#fff;font-weight:bold">return</span> sell2;
    }
};
</code></pre></div>
<h4 id="309-最佳买卖股票时机含冷冻期-https-leetcode-cn-com-problems-best-time-to-buy-and-sell-stock-with-cooldown"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309 最佳买卖股票时机含冷冻期</a></h4>

<p>给一个股票数组，不限制交易次数，卖出和买入之间需要隔一天，求最大利润。</p>

<p>和上一题的第二种方法类似，我们可以用两个数组 buy 和 sell 分别表示买入和卖出操作，对于买入操作，需要最大化两天前卖出的最优值于今天买入的差值，对于卖出操作，需要最大化当天价格与前一天买入的最优值的差值。时间复杂度是 O(n)。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> maxProfit(vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;&amp; prices) {
        <span style="color:#fff;font-weight:bold">int</span> n = prices.size();
        <span style="color:#fff;font-weight:bold">if</span> (n &lt; <span style="color:#ff0;font-weight:bold">2</span>)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
        vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; buy(n, <span style="color:#ff0;font-weight:bold">0</span>), sell(n, <span style="color:#ff0;font-weight:bold">0</span>);
        buy[<span style="color:#ff0;font-weight:bold">0</span>] = -prices[<span style="color:#ff0;font-weight:bold">0</span>], sell[<span style="color:#ff0;font-weight:bold">0</span>] = <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">1</span>; i &lt; n; ++i) {
            buy[i] = max(buy[i - <span style="color:#ff0;font-weight:bold">1</span>], sell[max(<span style="color:#ff0;font-weight:bold">0</span>, i - <span style="color:#ff0;font-weight:bold">2</span>)] - prices[i]);
            sell[i] = max(sell[i - <span style="color:#ff0;font-weight:bold">1</span>], buy[i - <span style="color:#ff0;font-weight:bold">1</span>] + prices[i]);
        }
        <span style="color:#fff;font-weight:bold">return</span> sell[n - <span style="color:#ff0;font-weight:bold">1</span>];
    }
};
</code></pre></div>
<h4 id="714-买卖股票的最佳时机含手续费-https-leetcode-cn-com-problems-best-time-to-buy-and-sell-stock-with-transaction-fee"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714 买卖股票的最佳时机含手续费</a></h4>

<p>给一个股票数组，不限制交易次数，每次卖出有一定手续费，求最大利润。</p>

<p>和上一题类似，区别在于没有了交易间隔，以及每次进行 sell 操作的时候需要减去手续费。时间复杂度是 O(n)。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> maxProfit(vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;&amp; prices, <span style="color:#fff;font-weight:bold">int</span> fee) {
        <span style="color:#fff;font-weight:bold">int</span> n = prices.size();
        <span style="color:#fff;font-weight:bold">if</span> (n &lt; <span style="color:#ff0;font-weight:bold">2</span>)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
        vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; buy(n, <span style="color:#ff0;font-weight:bold">0</span>), sell(n, <span style="color:#ff0;font-weight:bold">0</span>);
        buy[<span style="color:#ff0;font-weight:bold">0</span>] = -prices[<span style="color:#ff0;font-weight:bold">0</span>];
        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">1</span>; i &lt; n; ++i) {
            buy[i] = max(buy[i - <span style="color:#ff0;font-weight:bold">1</span>], sell[i - <span style="color:#ff0;font-weight:bold">1</span>] - prices[i]);
            sell[i] = max(sell[i - <span style="color:#ff0;font-weight:bold">1</span>], buy[i - <span style="color:#ff0;font-weight:bold">1</span>] + prices[i] - fee);
        }
        <span style="color:#fff;font-weight:bold">return</span> sell[n - <span style="color:#ff0;font-weight:bold">1</span>];
    }
};
</code></pre></div>
<h4 id="188-买卖股票的最佳时机-iv-https-leetcode-cn-com-problems-best-time-to-buy-and-sell-stock-iv"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">188 买卖股票的最佳时机 IV</a></h4>

<p>给一个股票数组，最多能进行 k 笔交易，求最大利润。</p>

<p>把上面五道题都做完之后这道题就很简单了。相比于第二题，因为这道题的 k 是未知的，所以要用一个循环将所有可能的 k 笔交易的最优值都计算出来，因此用一个三维数组 dp[n][k][2]，或是分开成两个二维数组 buy[n][k] 和 sell[n][k]，来表示前 n 天进行 k 笔交易的最优的买入和卖出值。同样的，买入和卖出操作都是在之前一次的卖出和买入的基础上进行的，使用 buy[i][j] = max({buy[i][j - 1], buy[i - 1][j], sell[i - 1][j - 1] - prices[i]}) 来表示前 i 天进行了 j 次交易的最优的买入值，第一项在 j &lt;= i / 2 时会填充为 buy[i][j - 1]的值，防止后面操作时不会取到空值或默认值造成错误，第二项是当前买入操作不能取得最优值的结果，第三项则是当前买入操作能取得最优值的结果；对应的卖出操作则是 sell[i][j] = max({sell[i][j - 1], sell[i - 1][j], buy[i - 1][j] + prices[i]})。</p>

<p>值得注意的是，当 k 远大于数组长度的两倍，或 k 非常大时，构造二维数组会造成MLE，此时可以直接用第二题的思路解决。时间复杂度是 O(n * k)，空间复杂度是 O(n * k)。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> maxProfit(<span style="color:#fff;font-weight:bold">int</span> k, vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; &amp;prices) {
        <span style="color:#fff;font-weight:bold">int</span> n = prices.size(), res = <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">if</span> (n &lt; <span style="color:#ff0;font-weight:bold">2</span> || k == <span style="color:#ff0;font-weight:bold">0</span>)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">if</span> (k &gt;= n * <span style="color:#ff0;font-weight:bold">2</span>) {
            <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">1</span>; i &lt; n; ++i)
                res += max(<span style="color:#ff0;font-weight:bold">0</span>, prices[i] - prices[i - <span style="color:#ff0;font-weight:bold">1</span>]);
            <span style="color:#fff;font-weight:bold">return</span> res;
        }
        vector&lt;vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;&gt; buy(n, vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;(k, INT_MIN)), sell(n, vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;(k, <span style="color:#ff0;font-weight:bold">0</span>));
        buy[<span style="color:#ff0;font-weight:bold">0</span>][<span style="color:#ff0;font-weight:bold">0</span>] = -prices[<span style="color:#ff0;font-weight:bold">0</span>], sell[<span style="color:#ff0;font-weight:bold">0</span>][<span style="color:#ff0;font-weight:bold">0</span>] = <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">1</span>; i &lt; n; ++i) {
            buy[i][<span style="color:#ff0;font-weight:bold">0</span>] = max(buy[i - <span style="color:#ff0;font-weight:bold">1</span>][<span style="color:#ff0;font-weight:bold">0</span>], -prices[i]);
            sell[i][<span style="color:#ff0;font-weight:bold">0</span>] = max(sell[i - <span style="color:#ff0;font-weight:bold">1</span>][<span style="color:#ff0;font-weight:bold">0</span>], buy[i - <span style="color:#ff0;font-weight:bold">1</span>][<span style="color:#ff0;font-weight:bold">0</span>] + prices[i]);
            <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> j = <span style="color:#ff0;font-weight:bold">1</span>; j &lt; k; ++j) {
                buy[i][j] = max({buy[i][j - <span style="color:#ff0;font-weight:bold">1</span>], buy[i - <span style="color:#ff0;font-weight:bold">1</span>][j], sell[i - <span style="color:#ff0;font-weight:bold">1</span>][j - <span style="color:#ff0;font-weight:bold">1</span>] - prices[i]});
                sell[i][j] = max({sell[i][j - <span style="color:#ff0;font-weight:bold">1</span>], sell[i - <span style="color:#ff0;font-weight:bold">1</span>][j], buy[i - <span style="color:#ff0;font-weight:bold">1</span>][j] + prices[i]});
            }
        }
        <span style="color:#fff;font-weight:bold">return</span> sell[n - <span style="color:#ff0;font-weight:bold">1</span>][k - <span style="color:#ff0;font-weight:bold">1</span>];
    }
};
</code></pre></div>
      </div>

      <footer>
        


        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "zintrulcre" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </footer>
    </article>

    
  </section>

      </div>

      <footer class="footer">
  <section class="container">
    
    
    
    
      
      <a href="https://github.com/luizdepra/hugo-coder/tree/"></a>
    
  </section>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
    </main>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-132809676-1', 'auto');
	
	ga('send', 'pageview');
}
</script>


  </body>

</html>
