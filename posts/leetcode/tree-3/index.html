<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Zhengyu Chen">
    <meta name="description" content="ZintrulCre @ 尾張">
    <meta name="keywords" content="ZintrulCre, 尾張">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="LeetCode 树（3）"/>
<meta name="twitter:description" content="LeetCode 树（3） 题目 4. 递归求解 617 合并二叉树 合并两个二叉树。 判断各个节点是否存在，全部合并到一棵树上即可。 class Solution { public: TreeNode *mergeTrees(TreeNode *t1, TreeNode *t2) { if (!t1 &amp;&amp; !t2) return nullptr; else if (!t1) return t2;"/>

    <meta property="og:title" content="LeetCode 树（3）" />
<meta property="og:description" content="LeetCode 树（3） 题目 4. 递归求解 617 合并二叉树 合并两个二叉树。 判断各个节点是否存在，全部合并到一棵树上即可。 class Solution { public: TreeNode *mergeTrees(TreeNode *t1, TreeNode *t2) { if (!t1 &amp;&amp; !t2) return nullptr; else if (!t1) return t2;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zintrulcre.vip/posts/leetcode/tree-3/" />
<meta property="article:published_time" content="2019-08-24T19:12:25+10:00" />
<meta property="article:modified_time" content="2019-08-24T19:12:25+10:00" />


    
      <base href="https://zintrulcre.vip/posts/leetcode/tree-3/">
    
    <title>
  LeetCode 树（3） · 尾張
</title>

    
      <link rel="canonical" href="https://zintrulcre.vip/posts/leetcode/tree-3/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="https://zintrulcre.vip/css/coder.min.28d751104f30c16da1aa1bb04015cbe662cacfe0d1b01af4f2240ad58580069c.css" integrity="sha256-KNdREE8wwW2hqhuwQBXL5mLKz&#43;DRsBr08iQK1YWABpw=" crossorigin="anonymous" media="screen" />
    

    

    

    

    <link rel="icon" type="image/png" href="https://zintrulcre.vip/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://zintrulcre.vip/images/favicon-16x16.png" sizes="16x16">

    <meta name="generator" content="Hugo 0.62.2" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://zintrulcre.vip">
      尾張
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://zintrulcre.vip/posts/">Posts</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://zintrulcre.vip/about/">About</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">LeetCode 树（3）</h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fas fa-calendar"></i>
              <time datetime='2019-08-24T19:12:25&#43;10:00'>
                August 24, 2019
              </time>
            </span>
            
          </div>
          <div class="categories">
  <i class="fas fa-folder"></i>
    <a href="https://zintrulcre.vip/categories/leetcode/">LeetCode</a></div>

          
        </div>
      </header>

      <div>
        <h1 id="leetcode-树3httpsleetcode-cncomtagtree"><a href="https://leetcode-cn.com/tag/tree/">LeetCode 树（3）</a></h1>
<h2 id="题目">题目</h2>
<h3 id="4-递归求解">4. 递归求解</h3>
<h4 id="617-合并二叉树httpsleetcode-cncomproblemsmerge-two-binary-trees"><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617 合并二叉树</a></h4>
<p>合并两个二叉树。</p>
<p>判断各个节点是否存在，全部合并到一棵树上即可。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span> Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    TreeNode *mergeTrees(TreeNode *t1, TreeNode *t2) {
        <span style="color:#fff;font-weight:bold">if</span> (!t1 &amp;&amp; !t2)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">nullptr</span>;
        <span style="color:#fff;font-weight:bold">else</span> if (!t1)
            <span style="color:#fff;font-weight:bold">return</span> t2;
        <span style="color:#fff;font-weight:bold">else</span> if (!t2)
            <span style="color:#fff;font-weight:bold">return</span> t1;
        t1-&gt;val += t2-&gt;val;
        t1-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);
        t1-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);
        <span style="color:#fff;font-weight:bold">return</span> t1;
    }
};
</code></pre></div><h4 id="226-翻转二叉树httpsleetcode-cncomproblemsinvert-binary-tree"><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226 翻转二叉树</a></h4>
<p>翻转一个二叉树。</p>
<p>先将左右子树分别翻转，再交换两者的位置。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span> Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    TreeNode *invertTree(TreeNode *root) {
        <span style="color:#fff;font-weight:bold">if</span> (!root)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">nullptr</span>;
        TreeNode *left = invertTree(root-&gt;left), *right = invertTree(root-&gt;right);
        root-&gt;right = left;
        root-&gt;left = right;
        <span style="color:#fff;font-weight:bold">return</span> root;
    }
};
</code></pre></div><h4 id="104-二叉树的最大深度httpsleetcode-cncomproblemsmaximum-depth-of-binary-tree"><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104 二叉树的最大深度</a></h4>
<p>找出一个二叉树的最大深度。</p>
<p>每层深度为 1，加上左右子树中更大的深度即为最大深度。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span> Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> maxDepth(TreeNode *root) {
        <span style="color:#fff;font-weight:bold">if</span> (!root)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">1</span> + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right));
    }
};
</code></pre></div><h4 id="965-单值二叉树httpsleetcode-cncomproblemsunivalued-binary-tree"><a href="https://leetcode-cn.com/problems/univalued-binary-tree/">965 单值二叉树</a></h4>
<p>判断一个二叉树是否是一个单值二叉树。</p>
<p>判断每个节点与其左右节点的值是否相同即可。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span> Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">bool</span> isUnivalTree(TreeNode *root) {
        <span style="color:#fff;font-weight:bold">if</span> (!root)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">true</span>;
        <span style="color:#fff;font-weight:bold">return</span> (root-&gt;left ? root-&gt;val == root-&gt;left-&gt;val : <span style="color:#fff;font-weight:bold">true</span>) &amp;&amp; (root-&gt;right ? root-&gt;val == root-&gt;right-&gt;val : <span style="color:#fff;font-weight:bold">true</span>) &amp;&amp; isUnivalTree(root-&gt;left) &amp;&amp; isUnivalTree(root-&gt;right);
    }
};
</code></pre></div><h4 id="559-n叉树的最大深度httpsleetcode-cncomproblemsmaximum-depth-of-n-ary-tree"><a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/">559 N叉树的最大深度</a></h4>
<p>找到一个 N 叉树的最大深度。</p>
<p>每层深度为 1，加上其所有子树中最大的深度即为最大深度。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span> Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> maxDepth(Node* root) {
        <span style="color:#fff;font-weight:bold">if</span> (!root)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">int</span> depth = <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">auto</span> &amp;c:root-&gt;children)
            depth = max(depth, maxDepth(c));
        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">1</span> + depth;
    }
};
</code></pre></div><h4 id="563-二叉树的坡度httpsleetcode-cncomproblemsbinary-tree-tilt"><a href="https://leetcode-cn.com/problems/binary-tree-tilt/">563 二叉树的坡度</a></h4>
<p>计算一个二叉树的坡度。</p>
<p>对于每个节点，计算其左子树和右子树的和，将其差的绝对值加到总的坡度上，再返回左子树，右子树，与自己的值的和，递归调用即可。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span> Solution {
    <span style="color:#fff;font-weight:bold">int</span> res;
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> findTilt(TreeNode *root) {
        res = <span style="color:#ff0;font-weight:bold">0</span>;
        CalcTilt(root);
        <span style="color:#fff;font-weight:bold">return</span> res;
    }

    <span style="color:#fff;font-weight:bold">int</span> CalcTilt(TreeNode *node) {
        <span style="color:#fff;font-weight:bold">if</span> (!node)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">int</span> left = CalcTilt(node-&gt;left);
        <span style="color:#fff;font-weight:bold">int</span> right = CalcTilt(node-&gt;right);
        res += abs(left - right);
        <span style="color:#fff;font-weight:bold">return</span> node-&gt;val + left + right;
    }
};
</code></pre></div><h4 id="508-出现次数最多的子树元素和httpsleetcode-cncomproblemsmost-frequent-subtree-sumsubmissions"><a href="https://leetcode-cn.com/problems/most-frequent-subtree-sum/submissions/">508 出现次数最多的子树元素和</a></h4>
<p>找出一个二叉树中出现次数最多的子树元素和。</p>
<p>计算出一个节点的左子树和右子树的子树元素和，加上自身的值就是一个完整的子树元素和，递归调用计算所有的节点并计数即可。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span> Solution {
    unordered_map&lt;<span style="color:#fff;font-weight:bold">int</span>, <span style="color:#fff;font-weight:bold">int</span>&gt; count;
<span style="color:#fff;font-weight:bold">public</span>:
    vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; findFrequentTreeSum(TreeNode *root) {
        vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; res;
        count = unordered_map&lt;<span style="color:#fff;font-weight:bold">int</span>, <span style="color:#fff;font-weight:bold">int</span>&gt;();
        Traverse(root);
        <span style="color:#fff;font-weight:bold">int</span> n = <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">auto</span> &amp;c:count) {
            <span style="color:#fff;font-weight:bold">if</span> (c.second &gt; n) {
                n = c.second;
                res.clear();
                res.push_back(c.first);
            } <span style="color:#fff;font-weight:bold">else</span> if (c.second == n)
                res.push_back(c.first);
        }
        <span style="color:#fff;font-weight:bold">return</span> res;
    }

    <span style="color:#fff;font-weight:bold">int</span> Traverse(TreeNode *root) {
        <span style="color:#fff;font-weight:bold">if</span> (!root)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">int</span> val = Traverse(root-&gt;left) + Traverse(root-&gt;right) + root-&gt;val;
        ++count[val];
        <span style="color:#fff;font-weight:bold">return</span> val;
    }
};
</code></pre></div><h3 id="5-栈求解">5. 栈求解</h3>
<h4 id="623-在二叉树中增加一行httpsleetcode-cncomproblemsadd-one-row-to-tree"><a href="https://leetcode-cn.com/problems/add-one-row-to-tree/">623 在二叉树中增加一行</a></h4>
<p>给一个二叉树，在第 d 层追加一行值为 v 的节点。</p>
<p>用一个栈保存一层的所有节点，逐层遍历即可。注意 d = 1 时要单独处理。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span> Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    TreeNode *addOneRow(TreeNode *root, <span style="color:#fff;font-weight:bold">int</span> v, <span style="color:#fff;font-weight:bold">int</span> d) {
        <span style="color:#fff;font-weight:bold">if</span> (!root)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">nullptr</span>;
        <span style="color:#fff;font-weight:bold">if</span> (d == <span style="color:#ff0;font-weight:bold">1</span>) {
            TreeNode *new_root = <span style="color:#fff;font-weight:bold">new</span> TreeNode(v);
            new_root-&gt;left = root;
            <span style="color:#fff;font-weight:bold">return</span> new_root;
        }
        queue&lt;TreeNode *&gt; q;
        q.push(root);
        <span style="color:#fff;font-weight:bold">int</span> depth = <span style="color:#ff0;font-weight:bold">1</span>, n = <span style="color:#ff0;font-weight:bold">1</span>;
        <span style="color:#fff;font-weight:bold">while</span> (!q.empty() &amp;&amp; depth &lt; d) {
            <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; n; ++i) {
                TreeNode *node = q.front();
                q.pop();
                <span style="color:#fff;font-weight:bold">if</span> (depth == d - <span style="color:#ff0;font-weight:bold">1</span>) {
                    TreeNode *left = node-&gt;left, *right = node-&gt;right;
                    node-&gt;left = <span style="color:#fff;font-weight:bold">new</span> TreeNode(v);
                    node-&gt;right = <span style="color:#fff;font-weight:bold">new</span> TreeNode(v);
                    node-&gt;left-&gt;left = left;
                    node-&gt;right-&gt;right = right;
                }
                <span style="color:#fff;font-weight:bold">if</span> (node-&gt;left)
                    q.push(node-&gt;left);
                <span style="color:#fff;font-weight:bold">if</span> (node-&gt;right)
                    q.push(node-&gt;right);
            }
            ++depth;
            n = q.size();
        }
        <span style="color:#fff;font-weight:bold">return</span> root;
    }
};
</code></pre></div><h3 id="6-找节点">6. 找节点</h3>
<h4 id="1123-最深叶节点的最近公共祖先httpsleetcode-cncomproblemslowest-common-ancestor-of-deepest-leaves"><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/">1123. 最深叶节点的最近公共祖先</a></h4>
<p>找到一个二叉树最深的叶节点的最近公共祖先。</p>
<p>可以先用层序遍历找到二叉树的深度，再通过一次递归找到所有叶节点的公共祖先。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span> Solution {
    TreeNode *res;
    <span style="color:#fff;font-weight:bold">int</span> lvl;
<span style="color:#fff;font-weight:bold">public</span>:
    TreeNode *lcaDeepestLeaves(TreeNode *root) {
        <span style="color:#fff;font-weight:bold">if</span> (!root)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">nullptr</span>;
        res = <span style="color:#fff;font-weight:bold">nullptr</span>;
        lvl = <span style="color:#ff0;font-weight:bold">0</span>;
        queue&lt;TreeNode *&gt; nodes;
        nodes.push(root);
        <span style="color:#fff;font-weight:bold">int</span> n = <span style="color:#ff0;font-weight:bold">1</span>;
        <span style="color:#fff;font-weight:bold">while</span> (!nodes.empty()) {
            <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; n; ++i) {
                TreeNode *node = nodes.front();
                nodes.pop();
                <span style="color:#fff;font-weight:bold">if</span> (node-&gt;left) nodes.push(node-&gt;left);
                <span style="color:#fff;font-weight:bold">if</span> (node-&gt;right) nodes.push(node-&gt;right);
            }
            ++lvl;
            n = nodes.size();
        }
        FindLCA(root, <span style="color:#ff0;font-weight:bold">1</span>);
        <span style="color:#fff;font-weight:bold">return</span> res;
    }

    <span style="color:#fff;font-weight:bold">bool</span> FindLCA(TreeNode *root, <span style="color:#fff;font-weight:bold">int</span> l) {
        <span style="color:#fff;font-weight:bold">if</span> (root &amp;&amp; l == lvl) {
            res = root;
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">true</span>;
        } <span style="color:#fff;font-weight:bold">else</span> <span style="color:#fff;font-weight:bold">if</span> (!root)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">false</span>;
        <span style="color:#fff;font-weight:bold">bool</span> left = FindLCA(root-&gt;left, l + <span style="color:#ff0;font-weight:bold">1</span>), right = FindLCA(root-&gt;right, l + <span style="color:#ff0;font-weight:bold">1</span>);
        <span style="color:#fff;font-weight:bold">if</span> (left &amp;&amp; right)
            res = root;
        <span style="color:#fff;font-weight:bold">return</span> left || right;
    }
};
</code></pre></div><p>但实际上我们并不需要知道这棵树的深度，只需要知道最深的节点即是叶节点，并且如果一个节点的左子树和右子树的最深节点的深度相同，那么这个节点就是他们的最近公共祖先，返回这个节点即可。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span> Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    TreeNode *lcaDeepestLeaves(TreeNode *root) {
        <span style="color:#fff;font-weight:bold">return</span> FindLCA(root).first;
    }

    pair&lt;TreeNode *, <span style="color:#fff;font-weight:bold">int</span>&gt; FindLCA(TreeNode *root) {
        <span style="color:#fff;font-weight:bold">if</span> (!root)
            <span style="color:#fff;font-weight:bold">return</span> pair&lt;TreeNode *, <span style="color:#fff;font-weight:bold">int</span>&gt;(<span style="color:#fff;font-weight:bold">nullptr</span>, <span style="color:#ff0;font-weight:bold">0</span>);
        <span style="color:#fff;font-weight:bold">auto</span> left = FindLCA(root-&gt;left), right = FindLCA(root-&gt;right);
        <span style="color:#fff;font-weight:bold">if</span> (left.second &gt; right.second)
            <span style="color:#fff;font-weight:bold">return</span> pair&lt;TreeNode *, <span style="color:#fff;font-weight:bold">int</span>&gt;(left.first, left.second + <span style="color:#ff0;font-weight:bold">1</span>);
        <span style="color:#fff;font-weight:bold">if</span> (left.second &lt; right.second)
            <span style="color:#fff;font-weight:bold">return</span> pair&lt;TreeNode *, <span style="color:#fff;font-weight:bold">int</span>&gt;(right.first, right.second + <span style="color:#ff0;font-weight:bold">1</span>);
        <span style="color:#fff;font-weight:bold">return</span> pair&lt;TreeNode *, <span style="color:#fff;font-weight:bold">int</span>&gt;(root, left.second + <span style="color:#ff0;font-weight:bold">1</span>);
    }
}
</code></pre></div>
      </div>

      <footer>
        


        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "zintrulcre" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </footer>
    </article>

    
  </section>

      </div>

      <footer class="footer">
  <section class="container">
    
    
    
    
      
      <a href="https://github.com/luizdepra/hugo-coder/tree/"></a>
    
  </section>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
    </main>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-132809676-1', 'auto');
	
	ga('send', 'pageview');
}
</script>


  </body>

</html>
