<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Zhengyu Chen">
    <meta name="description" content="ZintrulCre @ 尾張">
    <meta name="keywords" content="ZintrulCre, 尾張">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="LeetCode 二分查找"/>
<meta name="twitter:description" content="LeetCode 二分查找 二分查找可以在有序数组中以较高的效率查找符合条件的值，时间复杂度是O(logN)，空间复杂度是O(1)。 易错点 计算中间值的方法 k ="/>

    <meta property="og:title" content="LeetCode 二分查找" />
<meta property="og:description" content="LeetCode 二分查找 二分查找可以在有序数组中以较高的效率查找符合条件的值，时间复杂度是O(logN)，空间复杂度是O(1)。 易错点 计算中间值的方法 k =" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zintrulcre.vip/posts/leetcode/binarysearch/" />
<meta property="article:published_time" content="2019-06-23T19:26:39+10:00" />
<meta property="article:modified_time" content="2019-06-23T19:26:39+10:00" />


    
      <base href="https://zintrulcre.vip/posts/leetcode/binarysearch/">
    
    <title>
  LeetCode 二分查找 · 尾張
</title>

    
      <link rel="canonical" href="https://zintrulcre.vip/posts/leetcode/binarysearch/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="https://zintrulcre.vip/css/coder.min.28d751104f30c16da1aa1bb04015cbe662cacfe0d1b01af4f2240ad58580069c.css" integrity="sha256-KNdREE8wwW2hqhuwQBXL5mLKz&#43;DRsBr08iQK1YWABpw=" crossorigin="anonymous" media="screen" />
    

    

    

    

    <link rel="icon" type="image/png" href="https://zintrulcre.vip/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://zintrulcre.vip/images/favicon-16x16.png" sizes="16x16">

    <meta name="generator" content="Hugo 0.62.2" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://zintrulcre.vip">
      尾張
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://zintrulcre.vip/posts/">Posts</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://zintrulcre.vip/about/">About</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">LeetCode 二分查找</h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fas fa-calendar"></i>
              <time datetime='2019-06-23T19:26:39&#43;10:00'>
                June 23, 2019
              </time>
            </span>
            
          </div>
          <div class="categories">
  <i class="fas fa-folder"></i>
    <a href="https://zintrulcre.vip/categories/leetcode/">LeetCode</a></div>

          
        </div>
      </header>

      <div>
        <h1 id="leetcode-二分查找httpsleetcode-cncomtagbinary-search"><a href="https://leetcode-cn.com/tag/binary-search/">LeetCode 二分查找</a></h1>
<p>二分查找可以在有序数组中以较高的效率查找符合条件的值，时间复杂度是O(logN)，空间复杂度是O(1)。</p>
<h2 id="易错点">易错点</h2>
<ol>
<li>
<p>计算中间值的方法</p>
<ul>
<li>k = i + (j - i) / 2</li>
<li>k = (i + j) / 2</li>
</ul>
<p>第二种方法一般都会造成整型数据溢出，所以只用第一种方法。</p>
</li>
<li>
<p>循环条件</p>
<ul>
<li>
<p>如果要找唯一的值，且下限i和上限j都会在更新时在中间值k的基础上+1或-1，那么循环条件是 i &lt;= j，j能被取到，j = nums.size() - 1，计算中间值用 k = i + (j - i + 1) / 2</p>
</li>
<li>
<p>如果要找大于等于或小于等于某条件的值，且下限i和上限j其中之一不会在k的基础上+1或-1，那么循环条件是 i &lt; j，j不能被取到，j = nums.size()，计算中间值用 k = i + (j - i) / 2</p>
</li>
</ul>
<p>两种方法有各自的应用场景，没用对的话会出现边界值的问题，或是死循环导致TLE。</p>
</li>
</ol>
<h2 id="题目">题目</h2>
<h3 id="1-查找数">1. 查找数</h3>
<h4 id="704-二分查找httpsleetcode-cncomproblemsbinary-search"><a href="https://leetcode-cn.com/problems/binary-search/">704 二分查找</a></h4>
<p>在有序数组中搜索目标值，如果存在则返回下标，否则返回 -1。</p>
<p>最标准的二分查找。因为下限i和上限j都会在更新时+1和-1，所以让j = nums.size() - 1，循环条件是 i &lt;= j。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span> Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> search(vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; &amp;nums, <span style="color:#fff;font-weight:bold">int</span> target) {
        <span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>, j = nums.size() - <span style="color:#ff0;font-weight:bold">1</span>, k = <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">while</span> (i &lt;= j) {
            k = i + (j - i + <span style="color:#ff0;font-weight:bold">1</span>) / <span style="color:#ff0;font-weight:bold">2</span>;
            <span style="color:#fff;font-weight:bold">if</span> (nums[k] &gt; target)
                j = k - <span style="color:#ff0;font-weight:bold">1</span>;
            <span style="color:#fff;font-weight:bold">else</span> if (nums[k] &lt; target)
                i = k + <span style="color:#ff0;font-weight:bold">1</span>;
            <span style="color:#fff;font-weight:bold">else</span>
                <span style="color:#fff;font-weight:bold">return</span> k;
        }
        <span style="color:#fff;font-weight:bold">return</span> -<span style="color:#ff0;font-weight:bold">1</span>;
    }
};
</code></pre></div><h4 id="374-猜数字大小httpsleetcode-cncomproblemsguess-number-higher-or-lower"><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/">374 猜数字大小</a></h4>
<p>从 1 到 n 选择一个数字，通过一个预定义的接口 guess(int num)得到-1：数字打了；1：数字小了；0：猜对了。</p>
<p>跟上一题几乎一模一样，只是把target换成了一个接口。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">int</span> guess(<span style="color:#fff;font-weight:bold">int</span> num);

<span style="color:#fff;font-weight:bold">class</span> Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> guessNumber(<span style="color:#fff;font-weight:bold">int</span> n) {
        <span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">1</span>, j = n, k = <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">while</span> (i &lt;= j) {
            k = i + (j - i + <span style="color:#ff0;font-weight:bold">1</span>) / <span style="color:#ff0;font-weight:bold">2</span>;
            <span style="color:#fff;font-weight:bold">auto</span> res = guess(k);
            <span style="color:#fff;font-weight:bold">if</span> (res == <span style="color:#ff0;font-weight:bold">1</span>)
                i = k + <span style="color:#ff0;font-weight:bold">1</span>;
            <span style="color:#fff;font-weight:bold">else</span> if (res == -<span style="color:#ff0;font-weight:bold">1</span>)
                j = k - <span style="color:#ff0;font-weight:bold">1</span>;
            <span style="color:#fff;font-weight:bold">else</span>
                <span style="color:#fff;font-weight:bold">return</span> k;
        }
        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
    }
};
</code></pre></div><h4 id="367-有效的完全平方数httpsleetcode-cncomproblemsvalid-perfect-square"><a href="https://leetcode-cn.com/problems/valid-perfect-square/">367 有效的完全平方数</a></h4>
<p>判断一个正整数是否是一个完全平方数。</p>
<p>判断一个数是否是完全平方数。因为在二分的过程中平方得到的结果可能会超过32位int型的上限，所以用long long。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span> Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">bool</span> isPerfectSquare(<span style="color:#fff;font-weight:bold">int</span> num) {
        <span style="color:#fff;font-weight:bold">long</span> <span style="color:#fff;font-weight:bold">long</span> i = <span style="color:#ff0;font-weight:bold">0</span>, j = num, k = <span style="color:#ff0;font-weight:bold">0</span>, res = <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">while</span> (i &lt;= j) {
            k = i + (j - i + <span style="color:#ff0;font-weight:bold">1</span>) / <span style="color:#ff0;font-weight:bold">2</span>;
            res = k * k;
            <span style="color:#fff;font-weight:bold">if</span> (res &lt; num)
                i = k + <span style="color:#ff0;font-weight:bold">1</span>;
            <span style="color:#fff;font-weight:bold">else</span> if (res &gt; num)
                j = k - <span style="color:#ff0;font-weight:bold">1</span>;
            <span style="color:#fff;font-weight:bold">else</span>
                <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">true</span>;
        }
        <span style="color:#fff;font-weight:bold">return</span> j * j == num;
    }
};
</code></pre></div><h4 id="69-x的平方根httpsleetcode-cncomproblemssqrtx"><a href="https://leetcode-cn.com/problems/sqrtx/">69 x的平方根</a></h4>
<p>计算一个数的平方根，只保留整数部分。</p>
<p>实现int sqrt(int x)函数。用商来判断比用乘积来判断更直观。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span> Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> mySqrt(<span style="color:#fff;font-weight:bold">int</span> x) {
        <span style="color:#fff;font-weight:bold">if</span> (x &lt;= <span style="color:#ff0;font-weight:bold">1</span>)
            <span style="color:#fff;font-weight:bold">return</span> x;
        <span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">1</span>, j = x, k = <span style="color:#ff0;font-weight:bold">0</span>, sqrt = <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">while</span> (i &lt;= j) {
            k = i + (j - i + <span style="color:#ff0;font-weight:bold">1</span>) / <span style="color:#ff0;font-weight:bold">2</span>;
            sqrt = x / k;
            <span style="color:#fff;font-weight:bold">if</span> (sqrt &lt; k)
                j = k - <span style="color:#ff0;font-weight:bold">1</span>;
            <span style="color:#fff;font-weight:bold">else</span> if (sqrt &gt; k)
                i = k + <span style="color:#ff0;font-weight:bold">1</span>;
            <span style="color:#fff;font-weight:bold">else</span>
                <span style="color:#fff;font-weight:bold">return</span> k;
        }
        <span style="color:#fff;font-weight:bold">return</span> j;
    }
};
</code></pre></div><h3 id="2-查找上界下界">2. 查找上界/下界</h3>
<h4 id="35-搜索插入位置httpsleetcode-cncomproblemssearch-insert-position"><a href="https://leetcode-cn.com/problems/search-insert-position/">35 搜索插入位置</a></h4>
<p>在有序数组中找到目标值，如果不存在则返回它将会被按顺序插入的位置，数组中无重复元素。</p>
<p>找到大于等于target的第一个数。因为上限j在更新时会直接被赋给k的值，所以让j = nums.size()，循环条件是i &lt; j。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span> Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> searchInsert(vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;&amp; nums, <span style="color:#fff;font-weight:bold">int</span> target) {
        <span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>, j = nums.size(), k = <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">while</span> (i &lt; j) {
            k = i + (j - i) / <span style="color:#ff0;font-weight:bold">2</span>;
            <span style="color:#fff;font-weight:bold">if</span> (nums[k] &lt; target)
                i = k + <span style="color:#ff0;font-weight:bold">1</span>;
            <span style="color:#fff;font-weight:bold">else</span> if (nums[k] &gt; target)
                j = k;
            <span style="color:#fff;font-weight:bold">else</span>
                <span style="color:#fff;font-weight:bold">return</span> k;
        }
        <span style="color:#fff;font-weight:bold">return</span> j;
    }
};
</code></pre></div><h4 id="744-寻找比目标字母大的最小字母httpsleetcode-cncomproblemsfind-smallest-letter-greater-than-target"><a href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/">744 寻找比目标字母大的最小字母</a></h4>
<p>在有序数组中找到比目标字母大的最小字母，数组里的字母是循环的。</p>
<p>找到大于target的第一个数，相比于上一题只是少了在循环内判断是否等于的情况。从int类型数组变成了char类型数组，不过这一点并没有任何影响。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span> Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">char</span> nextGreatestLetter(vector&lt;<span style="color:#fff;font-weight:bold">char</span>&gt;&amp; letters, <span style="color:#fff;font-weight:bold">char</span> target) {
        <span style="color:#fff;font-weight:bold">int</span> n = letters.size(), i = <span style="color:#ff0;font-weight:bold">0</span>, j = n, k = <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">while</span> (i &lt; j) {
            k = i + (j - i) / <span style="color:#ff0;font-weight:bold">2</span>;
            <span style="color:#fff;font-weight:bold">if</span> (letters[k] &lt;= target)
                i = k + <span style="color:#ff0;font-weight:bold">1</span>;
            <span style="color:#fff;font-weight:bold">else</span> if (letters[k] &gt; target)
                j = k;
        }
        <span style="color:#fff;font-weight:bold">return</span> j &lt; n ? letters[j] : letters[<span style="color:#ff0;font-weight:bold">0</span>];
    }
};
</code></pre></div><h4 id="278-第一个错误的版本httpsleetcode-cncomproblemsfirst-bad-version"><a href="https://leetcode-cn.com/problems/first-bad-version/">278 第一个错误的版本</a></h4>
<p>产品都是基于之前的版本开发的，所有错误的版本之后的所有版本都是错的，找到出错的第一个版本。通过一个接口 bool isBadVersion(version) 来判断版本是否出错。</p>
<p>很标准的找下界。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">bool</span> isBadVersion(<span style="color:#fff;font-weight:bold">int</span> version);

<span style="color:#fff;font-weight:bold">class</span> Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> firstBadVersion(<span style="color:#fff;font-weight:bold">long</span> <span style="color:#fff;font-weight:bold">long</span> n) {
        <span style="color:#fff;font-weight:bold">long</span> <span style="color:#fff;font-weight:bold">long</span> i = <span style="color:#ff0;font-weight:bold">0</span>, j = n + <span style="color:#ff0;font-weight:bold">1</span>, k = <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">while</span> (i &lt; j) {
            k = i + (j - i) / <span style="color:#ff0;font-weight:bold">2</span>;
            <span style="color:#fff;font-weight:bold">if</span> (!isBadVersion(k))
                i = k + <span style="color:#ff0;font-weight:bold">1</span>;
            <span style="color:#fff;font-weight:bold">else</span>
                j = k;
        }
        <span style="color:#fff;font-weight:bold">return</span> j;
    }
};
</code></pre></div><h4 id="875-爱吃香蕉的珂珂httpsleetcode-cncomproblemskoko-eating-bananas"><a href="https://leetcode-cn.com/problems/koko-eating-bananas/">875 爱吃香蕉的珂珂</a></h4>
<p>有 N 堆香蕉，每小时内吃完一堆则不吃另外一堆，计算能在 H 小时内吃完的最慢速度。</p>
<p>将速度作为二分查找的变量，每次判断以当前速度是否能吃完所有香蕉，如果能则 j = k，k 有可能是最后的结果，否则 i = k + 1，此时的 k 一定比结果小。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span> Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> minEatingSpeed(vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;&amp; piles, <span style="color:#fff;font-weight:bold">int</span> H) {
        <span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">1</span>, j = INT_MAX, k = <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">while</span> (i &lt; j) {
            k = i + (j - i) / <span style="color:#ff0;font-weight:bold">2</span>;
            <span style="color:#fff;font-weight:bold">int</span> res = CanEatAll(k, H, piles);
            <span style="color:#fff;font-weight:bold">if</span> (res)
                j = k;
            <span style="color:#fff;font-weight:bold">else</span>
                i = k + <span style="color:#ff0;font-weight:bold">1</span>;
        }
        <span style="color:#fff;font-weight:bold">return</span> j;
    }
    
    <span style="color:#fff;font-weight:bold">bool</span> CanEatAll(<span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">int</span> &amp;speed, <span style="color:#fff;font-weight:bold">int</span> hour, vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;&amp; piles) {
        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">auto</span> &amp;p:piles)
            hour -= p / speed + (p % speed &gt; <span style="color:#ff0;font-weight:bold">0</span>);
        <span style="color:#fff;font-weight:bold">return</span> hour &gt;= <span style="color:#ff0;font-weight:bold">0</span>;
    }
};
</code></pre></div><h3 id="3-根据位置关系查找">3. 根据位置关系查找</h3>
<h4 id="378-有序矩阵中第k小的元素httpsleetcode-cncomproblemskth-smallest-element-in-a-sorted-matrix"><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/">378 有序矩阵中第K小的元素</a></h4>
<p>n x n 的矩阵中每行和每列均按升序排序，找到矩阵中第k小的元素。</p>
<p>这道题可以用跟剑指offer里二维数组中的查找这道题的思路结合二分查找来做，二分的时候每次计算矩阵里小于等于中间值的数的个数就能得到结果了。时间复杂度是 O(logm * n)，m 是 matrix[n - 1][n - 1]，n 是 matrix.size()。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span> Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> kthSmallest(vector&lt;vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;&gt;&amp; matrix, <span style="color:#fff;font-weight:bold">int</span> m) {
        <span style="color:#fff;font-weight:bold">int</span> n = matrix.size(), i = matrix[<span style="color:#ff0;font-weight:bold">0</span>][<span style="color:#ff0;font-weight:bold">0</span>], j = matrix[n - <span style="color:#ff0;font-weight:bold">1</span>][n - <span style="color:#ff0;font-weight:bold">1</span>] + <span style="color:#ff0;font-weight:bold">1</span>, k = <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">while</span> (i &lt; j) {
            k = i + (j - i) / <span style="color:#ff0;font-weight:bold">2</span>;
            <span style="color:#fff;font-weight:bold">auto</span> res = CountLess(matrix, k);
            <span style="color:#fff;font-weight:bold">if</span> (res &lt; m)
                i = k + <span style="color:#ff0;font-weight:bold">1</span>;
            <span style="color:#fff;font-weight:bold">else</span>
                j = k;
        }
        <span style="color:#fff;font-weight:bold">return</span> i;
    }
    
    <span style="color:#fff;font-weight:bold">int</span> CountLess(vector&lt;vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;&gt;&amp; matrix, <span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">int</span> &amp;target) {
        <span style="color:#fff;font-weight:bold">int</span> n = matrix.size(), i = <span style="color:#ff0;font-weight:bold">0</span>, j = n - <span style="color:#ff0;font-weight:bold">1</span>, res = <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">while</span> (i &lt; n &amp;&amp; j &gt;= <span style="color:#ff0;font-weight:bold">0</span>) {
            <span style="color:#fff;font-weight:bold">if</span> (matrix[i][j] &lt;= target)
                res += j + <span style="color:#ff0;font-weight:bold">1</span>, ++i;
            <span style="color:#fff;font-weight:bold">else</span>
                --j;
        }
        <span style="color:#fff;font-weight:bold">return</span> res;
    }
};
</code></pre></div><h4 id="153-寻找旋转排序数组中的最小值httpsleetcode-cncomproblemsfind-minimum-in-rotated-sorted-array"><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153 寻找旋转排序数组中的最小值</a></h4>
<p>一个有序数组在某个点上进行了旋转，找出其中最小的元素。</p>
<p>根据中间值与左右边值和其左右边一位的大小关系来判断，如果中间值k比左边值小，那么k有可能是结果，让 j = k ；否则比较中间值与其右边一位，如果中间值大于右边一位的值，那么右边一位的值就是结果，否则让 i = k + 1。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span> Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> findMin(vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;&amp; nums) {
        <span style="color:#fff;font-weight:bold">int</span> n = nums.size(), i = <span style="color:#ff0;font-weight:bold">0</span>, j = nums.size(), k = <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">if</span> (n == <span style="color:#ff0;font-weight:bold">1</span> || nums[<span style="color:#ff0;font-weight:bold">0</span>] &lt; nums[n - <span style="color:#ff0;font-weight:bold">1</span>])
            <span style="color:#fff;font-weight:bold">return</span> nums[<span style="color:#ff0;font-weight:bold">0</span>];
        <span style="color:#fff;font-weight:bold">else</span> if (n == <span style="color:#ff0;font-weight:bold">2</span>)
            <span style="color:#fff;font-weight:bold">return</span> min(nums[<span style="color:#ff0;font-weight:bold">0</span>], nums[<span style="color:#ff0;font-weight:bold">1</span>]);
        <span style="color:#fff;font-weight:bold">while</span> (i &lt; j) {
            k = i + (j - i) / <span style="color:#ff0;font-weight:bold">2</span>;
            <span style="color:#fff;font-weight:bold">if</span> (nums[i] &gt; nums[k])
                j = k;
            <span style="color:#fff;font-weight:bold">else</span> if (k + <span style="color:#ff0;font-weight:bold">1</span> &lt; j &amp;&amp; nums[k + <span style="color:#ff0;font-weight:bold">1</span>] &gt; nums[i])
                i = k + <span style="color:#ff0;font-weight:bold">1</span>;
            <span style="color:#fff;font-weight:bold">else</span>
                <span style="color:#fff;font-weight:bold">return</span> nums[k + <span style="color:#ff0;font-weight:bold">1</span>];
        }
        <span style="color:#fff;font-weight:bold">return</span> j &gt;= n ? nums[i] : min(nums[i], nums[j]);
    }
};
</code></pre></div><h4 id="540-有序数组中的单一元素httpsleetcode-cncomproblemssingle-element-in-a-sorted-array"><a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/">540 有序数组中的单一元素</a></h4>
<p>一个有序数组中每个元素都会出现了两次，只有一个数出现了一次，找出这个数。</p>
<p>有序数组里其他每个元素都出现两次，找到唯一只出现一次的数。在唯一的数出现之后奇偶位的相等关系会发生变化，利用这一点来做判断。比较直观的写法是分别判断 k % 2 == 0 和 k % 2 == 1 的情况，这样写起来比较复杂，可以直接在 k % 2 == 1 的时候 &ndash;k，再直接判断 nums[k] 和 nums[k + 1] 的关系。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span> Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> singleNonDuplicate(vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; &amp;nums) {
        <span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>, j = nums.size() - <span style="color:#ff0;font-weight:bold">1</span>, k = <span style="color:#ff0;font-weight:bold">0</span>, n = nums.size();
        <span style="color:#fff;font-weight:bold">while</span> (i &lt;= j) {
            k = i + (j - i + <span style="color:#ff0;font-weight:bold">1</span>) / <span style="color:#ff0;font-weight:bold">2</span>;
            cout &lt;&lt; k &lt;&lt; endl;
            <span style="color:#fff;font-weight:bold">if</span> (k % <span style="color:#ff0;font-weight:bold">2</span> == <span style="color:#ff0;font-weight:bold">0</span>) {
                <span style="color:#fff;font-weight:bold">if</span> (k + <span style="color:#ff0;font-weight:bold">1</span> &lt; n &amp;&amp; nums[k] == nums[k + <span style="color:#ff0;font-weight:bold">1</span>])
                    i = k + <span style="color:#ff0;font-weight:bold">1</span>;
                <span style="color:#fff;font-weight:bold">else</span> if (k - <span style="color:#ff0;font-weight:bold">1</span> &gt;= <span style="color:#ff0;font-weight:bold">0</span> &amp;&amp; nums[k] == nums[k - <span style="color:#ff0;font-weight:bold">1</span>])
                    j = k - <span style="color:#ff0;font-weight:bold">1</span>;
                <span style="color:#fff;font-weight:bold">else</span>
                    <span style="color:#fff;font-weight:bold">return</span> nums[k];
            } <span style="color:#fff;font-weight:bold">else</span> {
                <span style="color:#fff;font-weight:bold">if</span> (k + <span style="color:#ff0;font-weight:bold">1</span> &lt; n &amp;&amp; nums[k] == nums[k + <span style="color:#ff0;font-weight:bold">1</span>])
                    j = k - <span style="color:#ff0;font-weight:bold">1</span>;
                <span style="color:#fff;font-weight:bold">else</span> if (k - <span style="color:#ff0;font-weight:bold">1</span> &gt;= <span style="color:#ff0;font-weight:bold">0</span> &amp;&amp; nums[k] == nums[k - <span style="color:#ff0;font-weight:bold">1</span>])
                    i = k + <span style="color:#ff0;font-weight:bold">1</span>;
                <span style="color:#fff;font-weight:bold">else</span>
                    <span style="color:#fff;font-weight:bold">return</span> nums[k];
            }
        }
        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
    }
};
</code></pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span> Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> singleNonDuplicate(vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; &amp;nums) {
        <span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>, j = nums.size(), k = <span style="color:#ff0;font-weight:bold">0</span>, n = nums.size();
        <span style="color:#fff;font-weight:bold">while</span> (i &lt; j) {
            k = i + (j - i) / <span style="color:#ff0;font-weight:bold">2</span>;
            <span style="color:#fff;font-weight:bold">if</span> (k % <span style="color:#ff0;font-weight:bold">2</span> == <span style="color:#ff0;font-weight:bold">1</span>)
                --k;
            <span style="color:#fff;font-weight:bold">if</span> (k + <span style="color:#ff0;font-weight:bold">1</span> &lt; n &amp;&amp; nums[k] == nums[k + <span style="color:#ff0;font-weight:bold">1</span>])
                i = k + <span style="color:#ff0;font-weight:bold">2</span>;
            <span style="color:#fff;font-weight:bold">else</span>
                j = k;
        }
        <span style="color:#fff;font-weight:bold">return</span> nums[j];
    }
};
</code></pre></div><h3 id="4-综合">4. 综合</h3>
<h4 id="1095-山脉数组中查找目标值httpsleetcode-cncomproblemsfind-in-mountain-array"><a href="https://leetcode-cn.com/problems/find-in-mountain-array/">1095 山脉数组中查找目标值</a></h4>
<p>在一个山脉数组中找到等于目标值的最小下标。</p>
<p>因为已知数组一定是一个山脉数组，所以一定有唯一的山顶，用二分查找找到山顶的下标。如果山顶小于目标值那么数组中一定没有目标值存在，返回 -1，否则在山顶左边使用二分查找找目标值，没有的话则在山顶右边使用二分查找找目标值。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span> Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> findInMountainArray(<span style="color:#fff;font-weight:bold">int</span> target, MountainArray &amp;mountainArr) {
        <span style="color:#fff;font-weight:bold">int</span> n = mountainArr.length(), i = <span style="color:#ff0;font-weight:bold">0</span>, j = n - <span style="color:#ff0;font-weight:bold">1</span>, k = <span style="color:#ff0;font-weight:bold">0</span>, peak = <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">while</span> (i &lt;= j) {
            k = i + (j - i + <span style="color:#ff0;font-weight:bold">1</span>) / <span style="color:#ff0;font-weight:bold">2</span>;
            <span style="color:#fff;font-weight:bold">if</span> (mountainArr.get(k) &gt; mountainArr.get(k - <span style="color:#ff0;font-weight:bold">1</span>) &amp;&amp; mountainArr.get(k) &gt; mountainArr.get(k + <span style="color:#ff0;font-weight:bold">1</span>))
                <span style="color:#fff;font-weight:bold">break</span>;
            <span style="color:#fff;font-weight:bold">else</span> if (mountainArr.get(k) &lt; mountainArr.get(k - <span style="color:#ff0;font-weight:bold">1</span>))
                j = k - <span style="color:#ff0;font-weight:bold">1</span>;
            <span style="color:#fff;font-weight:bold">else</span>
                i = k + <span style="color:#ff0;font-weight:bold">1</span>;
        }
        <span style="color:#fff;font-weight:bold">if</span> (mountainArr.get(k) &lt; target)
            <span style="color:#fff;font-weight:bold">return</span> -<span style="color:#ff0;font-weight:bold">1</span>;
        <span style="color:#fff;font-weight:bold">else</span> if (mountainArr.get(k) == target)
            <span style="color:#fff;font-weight:bold">return</span> k;
        
        peak = k;
        i = <span style="color:#ff0;font-weight:bold">0</span>, j = peak;
        <span style="color:#fff;font-weight:bold">while</span> (i &lt; j) {
            k = i + (j - i) / <span style="color:#ff0;font-weight:bold">2</span>;
            <span style="color:#fff;font-weight:bold">if</span> (mountainArr.get(k) &lt; target)
                i = k + <span style="color:#ff0;font-weight:bold">1</span>;
            <span style="color:#fff;font-weight:bold">else</span>
                j = k;
        }
        <span style="color:#fff;font-weight:bold">if</span> (mountainArr.get(j) == target)
            <span style="color:#fff;font-weight:bold">return</span> j;
        
        i = peak + <span style="color:#ff0;font-weight:bold">1</span>, j = n;
        <span style="color:#fff;font-weight:bold">while</span> (i &lt; j) {
            k = i + (j - i) / <span style="color:#ff0;font-weight:bold">2</span>;
            <span style="color:#fff;font-weight:bold">if</span> (mountainArr.get(k) &lt; target)
                j = k - <span style="color:#ff0;font-weight:bold">1</span>;
            <span style="color:#fff;font-weight:bold">else</span> if (mountainArr.get(k) &gt; target)
                i = k + <span style="color:#ff0;font-weight:bold">1</span>;
            <span style="color:#fff;font-weight:bold">else</span>
                j = k;
        }
        <span style="color:#fff;font-weight:bold">if</span> (i &lt; n &amp;&amp; mountainArr.get(i) == target)
            <span style="color:#fff;font-weight:bold">return</span> i;
        <span style="color:#fff;font-weight:bold">return</span> -<span style="color:#ff0;font-weight:bold">1</span>;
    }
};
</code></pre></div><h3 id="5-猜数">5. 猜数</h3>
<h4 id="719-找出第-k-小的距离对httpsleetcode-cncomproblemsfind-k-th-smallest-pair-distance"><a href="https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/">719 找出第 k 小的距离对</a></h4>
<p>最简单的做法遍历两遍算出所有数对的差值保存在一个小根堆中，然后依次找到小于等于 k 的最小距离，但这样做时间复杂度是 O(n ^ 2) 会超时。我们可以先将数组排序，然后用 low = 0, high = nums[n - 1] - nums[0] 表示可能结果的最小值和最大值，用二分法来判断中间值 mid 是否满足小于等于 mid 的数对差值的数是否小于等于 k，判断时因为数组是有序的，可以使用双指针让中间的差值维持在小于等于 mid，从而计算出小于等于 mid 的数对差值的数，时间复杂度是 O(nlogn + nlogm)，其中 n 是数组的长度，m 是数组最大值与最小值之差，nlogn 是排序的平均时间复杂度，而 nlogm 中 n 是使用双指针判断的时间复杂度，logm 是二分法的时间复杂度。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span> Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> smallestDistancePair(vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; &amp;nums, <span style="color:#fff;font-weight:bold">int</span> k) {
        sort(nums.begin(), nums.end());
        <span style="color:#fff;font-weight:bold">int</span> n = nums.size(), low = <span style="color:#ff0;font-weight:bold">0</span>, high = nums[n - <span style="color:#ff0;font-weight:bold">1</span>] - nums[<span style="color:#ff0;font-weight:bold">0</span>], mid = <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">while</span> (low &lt; high) {
            mid = low + (high - low) / <span style="color:#ff0;font-weight:bold">2</span>;
            <span style="color:#fff;font-weight:bold">if</span> (IsDistMoreThanK(nums, mid, k))
                high = mid;
            <span style="color:#fff;font-weight:bold">else</span>
                low = mid + <span style="color:#ff0;font-weight:bold">1</span>;
        }
        <span style="color:#fff;font-weight:bold">return</span> high;
    }

    <span style="color:#fff;font-weight:bold">bool</span> IsDistMoreThanK(<span style="color:#fff;font-weight:bold">const</span> vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; &amp;nums, <span style="color:#fff;font-weight:bold">int</span> m, <span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">int</span> &amp;k) {
        <span style="color:#fff;font-weight:bold">int</span> left = <span style="color:#ff0;font-weight:bold">0</span>, right = <span style="color:#ff0;font-weight:bold">0</span>, count = <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">while</span> (right &lt; nums.size()) {
            <span style="color:#fff;font-weight:bold">while</span> (nums[right] - nums[left] &gt; m)
                ++left;
            count += right - left;
            ++right;
        }
        <span style="color:#fff;font-weight:bold">return</span> count &gt;= k;
    }
};
</code></pre></div>
      </div>

      <footer>
        


        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "zintrulcre" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </footer>
    </article>

    
  </section>

      </div>

      <footer class="footer">
  <section class="container">
    
    
    
    
      
      <a href="https://github.com/luizdepra/hugo-coder/tree/"></a>
    
  </section>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
    </main>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-132809676-1', 'auto');
	
	ga('send', 'pageview');
}
</script>


  </body>

</html>
