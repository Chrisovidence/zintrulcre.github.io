<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Zhengyu Chen">
    <meta name="description" content="ZintrulCre @ 尾張">
    <meta name="keywords" content="ZintrulCre, 尾張">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="LeetCode 树（1）"/>
<meta name="twitter:description" content="LeetCode 树（1） 题目 1. 树的遍历 144 二叉树的前序遍历 前序遍历一个二叉树。 前序遍历是按照根节点，左子节点，右子节点的顺序来遍历一个二叉树，有递归和迭代两"/>

    <meta property="og:title" content="LeetCode 树（1）" />
<meta property="og:description" content="LeetCode 树（1） 题目 1. 树的遍历 144 二叉树的前序遍历 前序遍历一个二叉树。 前序遍历是按照根节点，左子节点，右子节点的顺序来遍历一个二叉树，有递归和迭代两" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zintrulcre.vip/posts/leetcode/tree-1/" />
<meta property="article:published_time" content="2019-07-13T19:12:25&#43;10:00"/>
<meta property="article:modified_time" content="2019-07-13T19:12:25&#43;10:00"/>


    
      <base href="https://zintrulcre.vip/posts/leetcode/tree-1/">
    
    <title>
  LeetCode 树（1） · 尾張
</title>

    
      <link rel="canonical" href="https://zintrulcre.vip/posts/leetcode/tree-1/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="https://zintrulcre.vip/css/coder.min.28d751104f30c16da1aa1bb04015cbe662cacfe0d1b01af4f2240ad58580069c.css" integrity="sha256-KNdREE8wwW2hqhuwQBXL5mLKz&#43;DRsBr08iQK1YWABpw=" crossorigin="anonymous" media="screen" />
    

    

    

    

    <link rel="icon" type="image/png" href="https://zintrulcre.vip/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://zintrulcre.vip/images/favicon-16x16.png" sizes="16x16">

    <meta name="generator" content="Hugo 0.55.2" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://zintrulcre.vip">
      尾張
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://zintrulcre.vip/posts/">Posts</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://zintrulcre.vip/about/">About</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">LeetCode 树（1）</h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fas fa-calendar"></i>
              <time datetime='2019-07-13T19:12:25&#43;10:00'>
                July 13, 2019
              </time>
            </span>
            
          </div>
          <div class="categories">
  <i class="fas fa-folder"></i>
    <a href="https://zintrulcre.vip/categories/leetcode/">LeetCode</a></div>

          
        </div>
      </header>

      <div>
        

<h1 id="leetcode-树-1-https-leetcode-cn-com-tag-tree"><a href="https://leetcode-cn.com/tag/tree/">LeetCode 树（1）</a></h1>

<h2 id="题目">题目</h2>

<h3 id="1-树的遍历">1. 树的遍历</h3>

<h4 id="144-二叉树的前序遍历-https-leetcode-cn-com-problems-binary-tree-preorder-traversal"><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144 二叉树的前序遍历</a></h4>

<p>前序遍历一个二叉树。</p>

<p>前序遍历是按照根节点，左子节点，右子节点的顺序来遍历一个二叉树，有递归和迭代两种方法。对于迭代方法，先将节点加入结果数组，然后用一个栈保存右，左子节点，依次访问，重复此过程。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
        vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; res;
<span style="color:#fff;font-weight:bold">public</span>:
    vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; preorderTraversal(TreeNode *root) {
        res = vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;();
        Preorder(root);
        <span style="color:#fff;font-weight:bold">return</span> res;
    }
    
    <span style="color:#fff;font-weight:bold">void</span> Preorder(TreeNode *root) {
        <span style="color:#fff;font-weight:bold">if</span> (!root)
            <span style="color:#fff;font-weight:bold">return</span>;
        res.push_back(root-&gt;val);
        Preorder(root-&gt;left);
        Preorder(root-&gt;right);
    }
};
</code></pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; preorderTraversal(TreeNode *root) {
        vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; res;
        <span style="color:#fff;font-weight:bold">if</span> (!root)
            <span style="color:#fff;font-weight:bold">return</span> res;
        stack&lt;TreeNode *&gt; pre;
        pre.push(root);
        <span style="color:#fff;font-weight:bold">while</span> (!pre.empty()) {
            TreeNode *node = pre.top();
            pre.pop();
            res.push_back(node-&gt;val);
            <span style="color:#fff;font-weight:bold">if</span> (node-&gt;right)
                pre.push(node-&gt;right);
            <span style="color:#fff;font-weight:bold">if</span> (node-&gt;left)
                pre.push(node-&gt;left);
        }
        <span style="color:#fff;font-weight:bold">return</span> res;
    }
};
</code></pre></div>
<h4 id="589-n叉树的前序遍历-https-leetcode-cn-com-problems-n-ary-tree-preorder-traversal"><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/">589 N叉树的前序遍历</a></h4>

<p>前序遍历一个 N 叉树。</p>

<p>跟二叉树的前序遍历类似，有递归和迭代两种做法。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
    vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; res;
<span style="color:#fff;font-weight:bold">public</span>:
    vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; preorder(Node *root) {
        res = vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;();
        Preorder(root);
        <span style="color:#fff;font-weight:bold">return</span> res;
    }
    
    <span style="color:#fff;font-weight:bold">void</span> Preorder(Node *root) {
        <span style="color:#fff;font-weight:bold">if</span> (!root)
            <span style="color:#fff;font-weight:bold">return</span>;
        res.push_back(root-&gt;val);
        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">auto</span> &amp;c:root-&gt;children)
            Preorder(c);
    }
};
</code></pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; preorder(Node *root) {
        vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; res;
        <span style="color:#fff;font-weight:bold">if</span> (!root)
            <span style="color:#fff;font-weight:bold">return</span> res;
        stack&lt;Node *&gt; pre;
        pre.push(root);
        <span style="color:#fff;font-weight:bold">while</span> (!pre.empty()) {
            Node *node = pre.top();
            pre.pop();
            res.push_back(node-&gt;val);
            <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">auto</span> iter = node-&gt;children.rbegin(); iter &lt; node-&gt;children.rend(); ++iter)
                pre.push(*iter);
        }
        <span style="color:#fff;font-weight:bold">return</span> res;
    }
};
</code></pre></div>
<h4 id="94-二叉树的中序遍历-https-leetcode-cn-com-problems-binary-tree-inorder-traversal"><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94 二叉树的中序遍历</a></h4>

<p>中序遍历一个二叉树。</p>

<p>中序遍历是按照左子节点，根节点，右子节点的顺序来遍历一个二叉树，有递归和迭代两种方法。对于迭代方法，用一个栈保存父节点以便最后访问，先找到最左节点，将其加入结果数组，然后访问其右子节点，重复此过程。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
    vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; res;
<span style="color:#fff;font-weight:bold">public</span>:
    vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; inorderTraversal(TreeNode* root) {
        res = vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;();
        Inorder(root);
        <span style="color:#fff;font-weight:bold">return</span> res;
    }
    
    <span style="color:#fff;font-weight:bold">void</span> Inorder(TreeNode *root) {
        <span style="color:#fff;font-weight:bold">if</span> (!root)
            <span style="color:#fff;font-weight:bold">return</span>;
        Inorder(root-&gt;left);
        res.push_back(root-&gt;val);
        Inorder(root-&gt;right);
    }
};
</code></pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; inorderTraversal(TreeNode *root) {
        vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; res;
        <span style="color:#fff;font-weight:bold">if</span> (!root)
            <span style="color:#fff;font-weight:bold">return</span> res;
        stack&lt;TreeNode *&gt; in;
        TreeNode *node = root;
        <span style="color:#fff;font-weight:bold">while</span> (node || !in.empty()) {
            <span style="color:#fff;font-weight:bold">while</span> (node) {
                in.push(node);
                node = node-&gt;left;
            }
            <span style="color:#fff;font-weight:bold">if</span> (!in.empty()) {
                node = in.top();
                in.pop();
                res.push_back(node-&gt;val);
                node = node-&gt;right;
            }
        }
        <span style="color:#fff;font-weight:bold">return</span> res;
    }
};
</code></pre></div>
<h4 id="145-二叉树的后序遍历-https-leetcode-cn-com-problems-binary-tree-postorder-traversal"><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145 二叉树的后序遍历</a></h4>

<p>后序遍历一个二叉树。</p>

<p>后序遍历是按照左子节点，右子节点，根节点的顺序来遍历一个二叉树，有递归和迭代两种方法。对于迭代方法，用一个栈保存父节点以便最后访问，先找到最左节点，如果其已经是叶子节点则将其加入结果数组，否则访问其右子节点，用 last 保存上一次访问过的右子节点防止再次访问，重复此过程。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
    vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; res;
<span style="color:#fff;font-weight:bold">public</span>:
    vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; postorderTraversal(TreeNode* root) {
        res = vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;();
        Postorder(root);
        <span style="color:#fff;font-weight:bold">return</span> res;
    }
    
    <span style="color:#fff;font-weight:bold">void</span> Postorder(TreeNode *root) {
        <span style="color:#fff;font-weight:bold">if</span> (!root)
            <span style="color:#fff;font-weight:bold">return</span>;
        Postorder(root-&gt;left);
        Postorder(root-&gt;right);
        res.push_back(root-&gt;val);
    }
};
</code></pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; postorderTraversal(TreeNode *root) {
        vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; res;
        <span style="color:#fff;font-weight:bold">if</span> (!root)
            <span style="color:#fff;font-weight:bold">return</span> res;
        stack&lt;TreeNode *&gt; post;
        TreeNode *node = root, *last = <span style="color:#fff;font-weight:bold">nullptr</span>;
        <span style="color:#fff;font-weight:bold">while</span> (node || !post.empty()) {
            <span style="color:#fff;font-weight:bold">while</span> (node) {
                post.push(node);
                node = node-&gt;left;
            }
            <span style="color:#fff;font-weight:bold">if</span> (!post.empty()) {
                node = post.top();
                <span style="color:#fff;font-weight:bold">if</span> (node-&gt;right &amp;&amp; node-&gt;right != last)
                    node = node-&gt;right;
                <span style="color:#fff;font-weight:bold">else</span> {
                    res.push_back(node-&gt;val);
                    post.pop();
                    last = node;
                    node = <span style="color:#fff;font-weight:bold">nullptr</span>;
                }
            }
        }
        <span style="color:#fff;font-weight:bold">return</span> res;
    }
};
</code></pre></div>
<h4 id="590-n叉树的后序遍历-https-leetcode-cn-com-problems-n-ary-tree-postorder-traversal"><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">590 N叉树的后序遍历</a></h4>

<p>跟二叉树的后序遍历类似，有递归和迭代两种做法。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
    vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; res;
<span style="color:#fff;font-weight:bold">public</span>:
    vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; postorder(Node *root) {
        res = vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;();
        Postorder(root);
        <span style="color:#fff;font-weight:bold">return</span> res;
    }
    
    <span style="color:#fff;font-weight:bold">void</span> Postorder(Node *root) {
        <span style="color:#fff;font-weight:bold">if</span> (!root)
            <span style="color:#fff;font-weight:bold">return</span>;
        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">auto</span> &amp;c:root-&gt;children)
            Postorder(c);
        res.push_back(root-&gt;val);
    }
};
</code></pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; postorder(Node *root) {
        vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; res;
        <span style="color:#fff;font-weight:bold">if</span> (!root)
            <span style="color:#fff;font-weight:bold">return</span> res;
        stack&lt;Node *&gt; post;
        post.push(root);
        <span style="color:#fff;font-weight:bold">while</span> (!post.empty()) {
            Node *node = post.top();
            post.pop();
            res.push_back(node-&gt;val);
            <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">auto</span> &amp;c:node-&gt;children)
                post.push(c);
        }
        reverse(res.begin(), res.end());
        <span style="color:#fff;font-weight:bold">return</span> res;
    }
};
</code></pre></div>
<h4 id="102-二叉树的层次遍历-https-leetcode-cn-com-problems-binary-tree-level-order-traversal"><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102 二叉树的层次遍历</a></h4>

<p>给一个二叉树，返回其按层次遍历的节点值。</p>

<p>用一个队列来保存该二叉树当前一层的所有节点，一边将这些节点 pop 并 push 进结果数组中，一边将这些节点的子节点 push 进队列。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    vector&lt;vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;&gt; levelOrder(TreeNode *root) {
        vector&lt;vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;&gt; res;
        <span style="color:#fff;font-weight:bold">if</span> (!root)
            <span style="color:#fff;font-weight:bold">return</span> res;
        queue&lt;TreeNode *&gt; q;
        q.push(root);
        <span style="color:#fff;font-weight:bold">int</span> n = <span style="color:#ff0;font-weight:bold">1</span>;
        <span style="color:#fff;font-weight:bold">while</span> (!q.empty()) {
            vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; lvl;
            <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; n; ++i) {
                TreeNode *node = q.front();
                q.pop();
                lvl.push_back(node-&gt;val);
                <span style="color:#fff;font-weight:bold">if</span> (node-&gt;left)
                    q.push(node-&gt;left);
                <span style="color:#fff;font-weight:bold">if</span> (node-&gt;right)
                    q.push(node-&gt;right);
            }
            res.push_back(lvl);
            n = q.size();
        }
        <span style="color:#fff;font-weight:bold">return</span> res;
    }
};
</code></pre></div>
<h4 id="107-二叉树的层次遍历-ii-https-leetcode-cn-com-problems-binary-tree-level-order-traversal-ii"><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">107 二叉树的层次遍历 II</a></h4>

<p>给一个二叉树，返回其节点值自底向上的层次遍历。</p>

<p>跟上一题相同，只需要将结果数组倒置，或用一个栈保存结果，再 pop 进结果数组即可。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    vector&lt;vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;&gt; levelOrderBottom(TreeNode *root) {
        vector&lt;vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;&gt; res;
        <span style="color:#fff;font-weight:bold">if</span> (!root)
            <span style="color:#fff;font-weight:bold">return</span> res;
        queue&lt;TreeNode *&gt; q;
        <span style="color:#fff;font-weight:bold">int</span> n = <span style="color:#ff0;font-weight:bold">1</span>;
        q.push(root);
        <span style="color:#fff;font-weight:bold">while</span> (!q.empty()) {
            vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; lvl;
            <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; n; ++i) {
                TreeNode *node = q.front();
                q.pop();
                lvl.push_back(node-&gt;val);
                <span style="color:#fff;font-weight:bold">if</span> (node-&gt;left)
                    q.push(node-&gt;left);
                <span style="color:#fff;font-weight:bold">if</span> (node-&gt;right)
                    q.push(node-&gt;right);
            }
            res.push_back(lvl);
            n = q.size();
        }
        reverse(res.begin(), res.end());
        <span style="color:#fff;font-weight:bold">return</span> res;
    }
};
</code></pre></div>
<h4 id="429-n-叉树的层序遍历-https-leetcode-cn-com-problems-n-ary-tree-level-order-traversal"><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/">429 N 叉树的层序遍历</a></h4>

<p>层序遍历一个 N 叉树。</p>

<p>用一个队列来保存该 N 叉树当前一层的所有节点，一边将这些节点 pop 并 push 进结果数组中，一边将这些节点的子节点 push 进队列。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    vector&lt;vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;&gt; levelOrder(Node *root) {
        vector&lt;vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;&gt; res;
        <span style="color:#fff;font-weight:bold">if</span> (!root)
            <span style="color:#fff;font-weight:bold">return</span> res;
        queue&lt;Node *&gt; q;
        q.push(root);
        <span style="color:#fff;font-weight:bold">int</span> n = <span style="color:#ff0;font-weight:bold">1</span>;
        <span style="color:#fff;font-weight:bold">while</span> (!q.empty()) {
            vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; lvl;
            <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; n; ++i) {
                Node *node = q.front();
                q.pop();
                lvl.push_back(node-&gt;val);
                <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">auto</span> &amp;c:node-&gt;children)
                    q.push(c);
            }
            res.push_back(lvl);
            n = q.size();
        }
        <span style="color:#fff;font-weight:bold">return</span> res;
    }
};
</code></pre></div>
<h4 id="987-二叉树的垂序遍历-https-leetcode-cn-com-problems-vertical-order-traversal-of-a-binary-tree"><a href="https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/">987 二叉树的垂序遍历</a></h4>

<p>垂序遍历一个二叉树。</p>

<p>用红黑树把二叉树中每个节点的位置保存下来，如果根节点的位置是 (x, y)，那么其左子节点和右子节点的位置分别是 (x - 1, y + 1) 和 (x + 1, y + 1)，再按顺序保存到结果数组即可。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
    map&lt;<span style="color:#fff;font-weight:bold">int</span>, map&lt;<span style="color:#fff;font-weight:bold">int</span>, vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;&gt;&gt; matrix;
<span style="color:#fff;font-weight:bold">public</span>:
    vector&lt;vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;&gt; verticalTraversal(TreeNode *root) {
        vector&lt;vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;&gt; res;
        matrix = map&lt;<span style="color:#fff;font-weight:bold">int</span>, map&lt;<span style="color:#fff;font-weight:bold">int</span>, vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;&gt;&gt;();
        Traverse(root, <span style="color:#ff0;font-weight:bold">0</span>, <span style="color:#ff0;font-weight:bold">0</span>);
        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">auto</span> &amp;m:matrix) {
            vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; temp;
            <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">auto</span> &amp;n:m.second) {
                sort(n.second.begin(), n.second.end());
                temp.insert(temp.end(), n.second.begin(), n.second.end());
            }
            res.push_back(temp);
        }
        <span style="color:#fff;font-weight:bold">return</span> res;
    }

    <span style="color:#fff;font-weight:bold">void</span> Traverse(TreeNode *root, <span style="color:#fff;font-weight:bold">int</span> x, <span style="color:#fff;font-weight:bold">int</span> y) {
        <span style="color:#fff;font-weight:bold">if</span> (!root)
            <span style="color:#fff;font-weight:bold">return</span>;
        <span style="color:#fff;font-weight:bold">if</span> (matrix.find(x) == matrix.end())
            matrix[x] = map&lt;<span style="color:#fff;font-weight:bold">int</span>, vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;&gt;();
        <span style="color:#fff;font-weight:bold">if</span> (matrix[x].find(y) == matrix[x].end())
            matrix[x][y] = vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;();
        matrix[x][y].push_back(root-&gt;val);
        Traverse(root-&gt;left, x - <span style="color:#ff0;font-weight:bold">1</span>, y + <span style="color:#ff0;font-weight:bold">1</span>);
        Traverse(root-&gt;right, x + <span style="color:#ff0;font-weight:bold">1</span>, y + <span style="color:#ff0;font-weight:bold">1</span>);
    }
};
</code></pre></div>
<h4 id="103-二叉树的锯齿形层次遍历-https-leetcode-cn-com-problems-binary-tree-zigzag-level-order-traversal"><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103 二叉树的锯齿形层次遍历</a></h4>

<p>锯齿形层次遍历一个二叉树。</p>

<p>用两个栈轮流从左往右和从右往左保存节点，再依次加入结果数组即可。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    vector&lt;vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;&gt; zigzagLevelOrder(TreeNode *root) {
        stack&lt;TreeNode *&gt; s1, s2;
        vector&lt;vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;&gt; res;
        <span style="color:#fff;font-weight:bold">if</span> (!root)
            <span style="color:#fff;font-weight:bold">return</span> res;
        s1.push(root);
        <span style="color:#fff;font-weight:bold">while</span> (!s1.empty() || !s2.empty()) {
            vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; lvl;
            <span style="color:#fff;font-weight:bold">if</span> (s2.empty()) {
                <span style="color:#fff;font-weight:bold">while</span> (!s1.empty()) {
                    TreeNode *node = s1.top();
                    s1.pop();
                    lvl.push_back(node-&gt;val);
                    <span style="color:#fff;font-weight:bold">if</span> (node-&gt;left)
                        s2.push(node-&gt;left);
                    <span style="color:#fff;font-weight:bold">if</span> (node-&gt;right)
                        s2.push(node-&gt;right);
                }
            } <span style="color:#fff;font-weight:bold">else</span> {
                <span style="color:#fff;font-weight:bold">while</span> (!s2.empty()) {
                    TreeNode *node = s2.top();
                    s2.pop();
                    lvl.push_back(node-&gt;val);
                    <span style="color:#fff;font-weight:bold">if</span> (node-&gt;right)
                        s1.push(node-&gt;right);
                    <span style="color:#fff;font-weight:bold">if</span> (node-&gt;left)
                        s1.push(node-&gt;left);
                }
            }
            res.push_back(lvl);
        }
        <span style="color:#fff;font-weight:bold">return</span> res;
    }
};
</code></pre></div>
<h4 id="124-二叉树中的最大路径和-https-leetcode-cn-com-problems-binary-tree-maximum-path-sum"><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124 二叉树中的最大路径和</a></h4>

<p>用递归的方式，在每个节点值加上其左右子树的最大路径来更新结果，并以其左右子树中较大的一个加上其节点值返回即可。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
    <span style="color:#fff;font-weight:bold">int</span> res;
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> maxPathSum(TreeNode *root) {
        res = INT_MIN;
        Traverse(root);
        <span style="color:#fff;font-weight:bold">return</span> res;
    }

    <span style="color:#fff;font-weight:bold">int</span> Traverse(TreeNode *node) {
        <span style="color:#fff;font-weight:bold">if</span> (!node)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">int</span> left = max(<span style="color:#ff0;font-weight:bold">0</span>, Traverse(node-&gt;left));
        <span style="color:#fff;font-weight:bold">int</span> right = max(<span style="color:#ff0;font-weight:bold">0</span>, Traverse(node-&gt;right));
        res = max(res, left + right + node-&gt;val);
        <span style="color:#fff;font-weight:bold">return</span> max(left, right) + node-&gt;val;
    }
};
</code></pre></div>
<h3 id="2-构造二叉树">2. 构造二叉树</h3>

<h4 id="105-从前序与中序遍历序列构造二叉树-https-leetcode-cn-com-problems-construct-binary-tree-from-preorder-and-inorder-traversal"><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105 从前序与中序遍历序列构造二叉树</a></h4>

<p>根据前序遍历与中序遍历的结果构造二叉树。</p>

<p>前序遍历结果中的第一个元素一定是二叉树的根节点的值，因此在中序遍历结果中找到这个值，那么中序遍历结果中这个值左边的所有元素一定都在这个根节点的左子树上，右边的所有元素一定都在这个根节点的右子树上，假设左边的长度为 m，那么在前序遍历结果的第一个元素后的 m 个元素也都对应左子树上的这些元素，分别把这两部分递归调用构造新的子树即可。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    TreeNode *buildTree(vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; &amp;preorder, vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; &amp;inorder) {
        <span style="color:#fff;font-weight:bold">return</span> Build(preorder, <span style="color:#ff0;font-weight:bold">0</span>, preorder.size(), inorder, <span style="color:#ff0;font-weight:bold">0</span>, inorder.size());
    }

    TreeNode *Build(vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; &amp;preorder, <span style="color:#fff;font-weight:bold">int</span> x, <span style="color:#fff;font-weight:bold">int</span> y, vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; &amp;inorder, <span style="color:#fff;font-weight:bold">int</span> m, <span style="color:#fff;font-weight:bold">int</span> n) {
        <span style="color:#fff;font-weight:bold">if</span> (x &gt;= y || m &gt;= n)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">nullptr</span>;
        TreeNode *node = <span style="color:#fff;font-weight:bold">new</span> TreeNode(preorder[x]);
        <span style="color:#fff;font-weight:bold">int</span> pos = m;
        <span style="color:#fff;font-weight:bold">while</span> (pos &lt; n &amp;&amp; inorder[pos] != preorder[x])
            ++pos;
        node-&gt;left = Build(preorder, x + <span style="color:#ff0;font-weight:bold">1</span>, x + <span style="color:#ff0;font-weight:bold">1</span> + pos - m, inorder, m, pos);
        node-&gt;right = Build(preorder, x + <span style="color:#ff0;font-weight:bold">1</span> + pos - m, y, inorder, pos + <span style="color:#ff0;font-weight:bold">1</span>, n);
        <span style="color:#fff;font-weight:bold">return</span> node;
    }
};
</code></pre></div>
<h4 id="106-从中序与后序遍历序列构造二叉树-https-leetcode-cn-com-problems-construct-binary-tree-from-inorder-and-postorder-traversal"><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106 从中序与后序遍历序列构造二叉树</a></h4>

<p>根据后序遍历与中序遍历的结果构造二叉树。</p>

<p>后序遍历结果中的最后一个元素一定是二叉树的根节点的值，因此在中序遍历结果中找到这个值，那么中序遍历结果中这个值左边的所有元素一定都在这个根节点的左子树上，右边的所有元素一定都在这个根节点的右子树上，假设左边的长度为 m，那么在后序遍历结果中从第一个元素往后 m 个元素也都对应左子树上的这些元素，分别把这两部分递归调用构造新的子树即可。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    TreeNode *buildTree(vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; &amp;inorder, vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; &amp;postorder) {
        <span style="color:#fff;font-weight:bold">return</span> Build(inorder, <span style="color:#ff0;font-weight:bold">0</span>, inorder.size(), postorder, <span style="color:#ff0;font-weight:bold">0</span>, postorder.size());
    }

    TreeNode *Build(vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; &amp;inorder, <span style="color:#fff;font-weight:bold">int</span> x, <span style="color:#fff;font-weight:bold">int</span> y, vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; &amp;postorder, <span style="color:#fff;font-weight:bold">int</span> m, <span style="color:#fff;font-weight:bold">int</span> n) {
        <span style="color:#fff;font-weight:bold">if</span> (x &gt;= y || m &gt;= n)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">nullptr</span>;
        TreeNode *node = <span style="color:#fff;font-weight:bold">new</span> TreeNode(postorder[n - <span style="color:#ff0;font-weight:bold">1</span>]);
        <span style="color:#fff;font-weight:bold">int</span> pos = x;
        <span style="color:#fff;font-weight:bold">while</span> (pos &lt; y &amp;&amp; inorder[pos] != postorder[n - <span style="color:#ff0;font-weight:bold">1</span>])
            ++pos;
        node-&gt;left = Build(inorder, x, pos, postorder, m, m + pos - x);
        node-&gt;right = Build(inorder, pos + <span style="color:#ff0;font-weight:bold">1</span>, y, postorder, m + pos - x, n - <span style="color:#ff0;font-weight:bold">1</span>);
        <span style="color:#fff;font-weight:bold">return</span> node;
    }
};
</code></pre></div>
<h4 id="889-根据前序和后序遍历构造二叉树-https-leetcode-cn-com-problems-construct-binary-tree-from-preorder-and-postorder-traversal"><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889 根据前序和后序遍历构造二叉树</a></h4>

<p>根据前序遍历与后序遍历的结果构造二叉树。</p>

<p>前序遍历结果中的第一个元素对应后序遍历结果中的最后一个元素，都是二叉树的根节点的值，以此构建根节点；前序遍历结果中的第二个元素一定是根节点的左子节点，而后序遍历结果中的这个值一定是左子树上的最后一个值，那么只需要找到这个值在后序遍历结果中的位置，就可以确定左子树和右子树的长度，分别递归调用构造新的子树即可。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    TreeNode *constructFromPrePost(vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; &amp;pre, vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; &amp;post) {
        <span style="color:#fff;font-weight:bold">return</span> Build(pre, <span style="color:#ff0;font-weight:bold">0</span>, pre.size(), post, <span style="color:#ff0;font-weight:bold">0</span>, post.size());
    }

    TreeNode *Build(vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; &amp;pre, <span style="color:#fff;font-weight:bold">int</span> x, <span style="color:#fff;font-weight:bold">int</span> y, vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; &amp;post, <span style="color:#fff;font-weight:bold">int</span> m, <span style="color:#fff;font-weight:bold">int</span> n) {
        <span style="color:#fff;font-weight:bold">if</span> (x &gt;= y || m &gt;= n)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">nullptr</span>;
        TreeNode *node = <span style="color:#fff;font-weight:bold">new</span> TreeNode(pre[x]);
        <span style="color:#fff;font-weight:bold">if</span> (x == y - <span style="color:#ff0;font-weight:bold">1</span>)
            <span style="color:#fff;font-weight:bold">return</span> node;
        <span style="color:#fff;font-weight:bold">int</span> pos = m;
        <span style="color:#fff;font-weight:bold">while</span> (pos &lt; n &amp;&amp; post[pos] != pre[x + <span style="color:#ff0;font-weight:bold">1</span>])
            ++pos;
        node-&gt;left = Build(pre, x + <span style="color:#ff0;font-weight:bold">1</span>, x + pos - m + <span style="color:#ff0;font-weight:bold">2</span>, post, m, pos + <span style="color:#ff0;font-weight:bold">1</span>);
        node-&gt;right = Build(pre, x + pos - m + <span style="color:#ff0;font-weight:bold">2</span>, y, post, pos + <span style="color:#ff0;font-weight:bold">1</span>, n - <span style="color:#ff0;font-weight:bold">1</span>);
        <span style="color:#fff;font-weight:bold">return</span> node;
    }
};
</code></pre></div>
<h4 id="1008-先序遍历构造二叉树-https-leetcode-cn-com-problems-construct-binary-search-tree-from-preorder-traversal"><a href="https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/">1008 先序遍历构造二叉树</a></h4>

<p>给一个先序遍历的结果，构造其对应的二叉搜索树。</p>

<p>根据先序遍历和二叉搜索树的定义，数组的第一个元素即是根节点，其后所有小于它的元素都在它的左子树上，所有大于它的元素都在它的右子树上，递归求解即可。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    TreeNode *bstFromPreorder(vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; &amp;preorder) {
        <span style="color:#fff;font-weight:bold">return</span> Build(preorder, <span style="color:#ff0;font-weight:bold">0</span>, preorder.size());
    }

    TreeNode *Build(vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; &amp;preorder, <span style="color:#fff;font-weight:bold">int</span> x, <span style="color:#fff;font-weight:bold">int</span> y) {
        <span style="color:#fff;font-weight:bold">if</span> (x &gt;= y)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">nullptr</span>;
        TreeNode *root = <span style="color:#fff;font-weight:bold">new</span> TreeNode(preorder[x]);
        <span style="color:#fff;font-weight:bold">int</span> i = x + <span style="color:#ff0;font-weight:bold">1</span>;
        <span style="color:#fff;font-weight:bold">while</span> (i &lt; y &amp;&amp; preorder[i] &lt; preorder[x])
            ++i;
        root-&gt;left = Build(preorder, x + <span style="color:#ff0;font-weight:bold">1</span>, i);
        root-&gt;right = Build(preorder, i, y);
        <span style="color:#fff;font-weight:bold">return</span> root;
    }
};
</code></pre></div>
<h4 id="1028-从先序遍历还原二叉树-https-leetcode-cn-com-problems-recover-a-tree-from-preorder-traversal"><a href="https://leetcode-cn.com/problems/recover-a-tree-from-preorder-traversal/">1028 从先序遍历还原二叉树</a></h4>

<p>给一个先序遍历的结果和用不同长度的 &lsquo;-&rsquo; 相连的字符串，构造其对应的二叉树。</p>

<p>&rsquo;-&rsquo; 的长度代表当前的层次，如果当前节点之后的 &lsquo;-&rsquo; 的长度等于当前的层次加一，那么其后的数构成当前节点的左节点；如果左节点之后的 &lsquo;-&rsquo; 的长度等于当前的层次加一，那么其后的数构成当前节点的右节点；否则如果当前节点之后或左节点之后的 &lsquo;-&rsquo; 的长度小于等于等钱层次则代表当前节点已经是叶子节点，其没有左右子节点，直接返回。用一个变量 pos 保存当前遍历到的字符串位置，递归调用该过程即可。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    TreeNode *recoverFromPreorder(string S) {
        <span style="color:#fff;font-weight:bold">int</span> pos = <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">return</span> Build(S, <span style="color:#ff0;font-weight:bold">0</span>, pos, <span style="color:#ff0;font-weight:bold">0</span>);
    }

    TreeNode *Build(<span style="color:#fff;font-weight:bold">const</span> string &amp;S, <span style="color:#fff;font-weight:bold">int</span> x, <span style="color:#fff;font-weight:bold">int</span> &amp;pos, <span style="color:#fff;font-weight:bold">int</span> lvl) {
        <span style="color:#fff;font-weight:bold">int</span> num = <span style="color:#ff0;font-weight:bold">0</span>, i = x;
        <span style="color:#fff;font-weight:bold">while</span> (S[i] &gt;= <span style="color:#0ff;font-weight:bold">&#39;0&#39;</span> &amp;&amp; S[i] &lt;= <span style="color:#0ff;font-weight:bold">&#39;9&#39;</span>)
            ++i;
        TreeNode *node = <span style="color:#fff;font-weight:bold">new</span> TreeNode(stoi(S.substr(x, i - x + <span style="color:#ff0;font-weight:bold">1</span>)));
        pos = i;
        <span style="color:#fff;font-weight:bold">while</span> (S[i] == <span style="color:#0ff;font-weight:bold">&#39;-&#39;</span>)
            ++i;
        <span style="color:#fff;font-weight:bold">if</span> (i - pos == lvl + <span style="color:#ff0;font-weight:bold">1</span>)
            node-&gt;left = Build(S, i, pos, lvl + <span style="color:#ff0;font-weight:bold">1</span>);
        <span style="color:#fff;font-weight:bold">else</span>
            <span style="color:#fff;font-weight:bold">return</span> node;
        i = pos;
        <span style="color:#fff;font-weight:bold">while</span> (S[i] == <span style="color:#0ff;font-weight:bold">&#39;-&#39;</span>)
            ++i;
        <span style="color:#fff;font-weight:bold">if</span> (i - pos == lvl + <span style="color:#ff0;font-weight:bold">1</span>)
            node-&gt;right = Build(S, i, y, pos, lvl + <span style="color:#ff0;font-weight:bold">1</span>);
        <span style="color:#fff;font-weight:bold">return</span> node;
    }
};
</code></pre></div>
      </div>

      <footer>
        


        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "zintrulcre" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </footer>
    </article>

    
  </section>

      </div>

      <footer class="footer">
  <section class="container">
    
    
    
    
      
      <a href="https://github.com/luizdepra/hugo-coder/tree/"></a>
    
  </section>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
    </main>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-132809676-1', 'auto');
	
	ga('send', 'pageview');
}
</script>


  </body>

</html>
