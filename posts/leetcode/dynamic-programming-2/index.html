<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Zhengyu Chen">
    <meta name="description" content="ZintrulCre @ 尾張">
    <meta name="keywords" content="ZintrulCre, 尾張">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="LeetCode 动态规划（2）"/>
<meta name="twitter:description" content="LeetCode 动态规划 题目 3. 数组 300 最长上升子序列 在无序数组中找到最长上升子序列的长度。 用一个数组 dp[i] 表示到第 i 个数字为止的最长上升子序列，每次遍历 i 之前的"/>

    <meta property="og:title" content="LeetCode 动态规划（2）" />
<meta property="og:description" content="LeetCode 动态规划 题目 3. 数组 300 最长上升子序列 在无序数组中找到最长上升子序列的长度。 用一个数组 dp[i] 表示到第 i 个数字为止的最长上升子序列，每次遍历 i 之前的" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zintrulcre.vip/posts/leetcode/dynamic-programming-2/" />
<meta property="article:published_time" content="2019-06-28T10:09:13&#43;10:00"/>
<meta property="article:modified_time" content="2019-06-28T10:09:13&#43;10:00"/>


    
      <base href="https://zintrulcre.vip/posts/leetcode/dynamic-programming-2/">
    
    <title>
  LeetCode 动态规划（2） · 尾張
</title>

    
      <link rel="canonical" href="https://zintrulcre.vip/posts/leetcode/dynamic-programming-2/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="https://zintrulcre.vip/css/coder.min.28d751104f30c16da1aa1bb04015cbe662cacfe0d1b01af4f2240ad58580069c.css" integrity="sha256-KNdREE8wwW2hqhuwQBXL5mLKz&#43;DRsBr08iQK1YWABpw=" crossorigin="anonymous" media="screen" />
    

    

    

    

    <link rel="icon" type="image/png" href="https://zintrulcre.vip/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://zintrulcre.vip/images/favicon-16x16.png" sizes="16x16">

    <meta name="generator" content="Hugo 0.55.2" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://zintrulcre.vip">
      尾張
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://zintrulcre.vip/posts/">Posts</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://zintrulcre.vip/about/">About</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">LeetCode 动态规划（2）</h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fas fa-calendar"></i>
              <time datetime='2019-06-28T10:09:13&#43;10:00'>
                June 28, 2019
              </time>
            </span>
            
          </div>
          <div class="categories">
  <i class="fas fa-folder"></i>
    <a href="https://zintrulcre.vip/categories/leetcode/">LeetCode</a></div>

          
        </div>
      </header>

      <div>
        

<h1 id="leetcode-动态规划-https-leetcode-cn-com-problemset-all-search-e4-b8-91-e6-95-b0"><a href="https://leetcode-cn.com/problemset/all/?search=%E4%B8%91%E6%95%B0">LeetCode 动态规划</a></h1>

<h2 id="题目">题目</h2>

<h3 id="3-数组">3. 数组</h3>

<h4 id="300-最长上升子序列-https-leetcode-cn-com-problems-longest-increasing-subsequence-submissions"><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/submissions/">300 最长上升子序列</a></h4>

<p>在无序数组中找到最长上升子序列的长度。</p>

<p>用一个数组 dp[i] 表示到第 i 个数字为止的最长上升子序列，每次遍历 i 之前的每个数字 j，如果 nums[i] &gt; nums[j]，那么 j 和 i 可以形成一个上升子序列，让 dp[i] = max(dp[i], dp[j] + 1) 就能得到最长的上升子序列了。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> lengthOfLIS(vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;&amp; nums) {
        <span style="color:#fff;font-weight:bold">int</span> n = nums.size(), res = <span style="color:#ff0;font-weight:bold">0</span>;
        vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; dp(n, <span style="color:#ff0;font-weight:bold">1</span>);
        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">1</span>; i &lt; n; ++i)
            <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> j = <span style="color:#ff0;font-weight:bold">0</span>; j &lt; i; ++j)
                <span style="color:#fff;font-weight:bold">if</span> (nums[i] &gt; nums[j]) {
                    dp[i] = max(dp[i], dp[j] + <span style="color:#ff0;font-weight:bold">1</span>);
                    res = max(res, dp[i]);
                }
        <span style="color:#fff;font-weight:bold">return</span> res;
    }
};
</code></pre></div>
<h4 id="53-最大子序和-https-leetcode-cn-com-problems-maximum-subarray"><a href="https://leetcode-cn.com/problems/maximum-subarray/">53 最大子序和</a></h4>

<p>找一个数组中具有最大和的连续子数组的和。</p>

<p>从头开始用一个变量 val 保存到当前数为止的连续子数组和，每一个数对于之前的连续子数组和只有加与不加两种选择，当之前的连续子数组和大于 0 时加上之前的连续子数组和，否则不加。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> maxSubArray(vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; &amp;nums) {
        <span style="color:#fff;font-weight:bold">int</span> res = INT_MIN, val = <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">auto</span> &amp;n:nums) {
            val = max(val, <span style="color:#ff0;font-weight:bold">0</span>) + n;
            res = max(res, val);
        }
        <span style="color:#fff;font-weight:bold">return</span> res;
    }
};
</code></pre></div>
<h4 id="813-最大平均值和的分组-https-leetcode-cn-com-problems-largest-sum-of-averages"><a href="https://leetcode-cn.com/problems/largest-sum-of-averages/">813 最大平均值和的分组</a></h4>

<p>将数组分为 K 个相邻的非空子数组，求所有子数组的平均值的和的最大值。</p>

<p>用二维数组 dp[n][K] 来表示前 i 个数分成 k 组得到的最优值，每次将从第 j 个数到第 n 个数分为一组，将前面 j - 1 个数分为 k - 1 组，求得 dp[i][k] 的最大值。为了快速地算出第 j 个数到第 n 个数的和以及前 j - 1 个数的和，可以用一个前缀和数组将前 m 个数的和保存下来，再用状态转移方程 dp[i][k] = max(dp[i][k], dp[j][k - 1] + (pre[i] - pre[j]) / (i - j)) 求得最优值。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">double</span> largestSumOfAverages(vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; &amp;A, <span style="color:#fff;font-weight:bold">int</span> K) {
        <span style="color:#fff;font-weight:bold">int</span> n = A.size();
        <span style="color:#fff;font-weight:bold">if</span> (n == <span style="color:#ff0;font-weight:bold">0</span>)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
        vector&lt;<span style="color:#fff;font-weight:bold">double</span>&gt; pre(n + <span style="color:#ff0;font-weight:bold">1</span>, <span style="color:#ff0;font-weight:bold">0</span>);
        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">1</span>; i &lt;= n; ++i)
            pre[i] += pre[i - <span style="color:#ff0;font-weight:bold">1</span>] + A[i - <span style="color:#ff0;font-weight:bold">1</span>];
        vector&lt;vector&lt;<span style="color:#fff;font-weight:bold">double</span>&gt;&gt; dp(n + <span style="color:#ff0;font-weight:bold">1</span>, vector&lt;<span style="color:#fff;font-weight:bold">double</span>&gt;(K + <span style="color:#ff0;font-weight:bold">1</span>, <span style="color:#ff0;font-weight:bold">0</span>));
        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">1</span>; i &lt;= n; ++i) {
            dp[i][<span style="color:#ff0;font-weight:bold">1</span>] = pre[i] / i;
            <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> k = <span style="color:#ff0;font-weight:bold">2</span>; k &lt;= K &amp;&amp; k &lt;= i; ++k)
                <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> j = <span style="color:#ff0;font-weight:bold">1</span>; j &lt; i; ++j)
                    dp[i][k] = max(dp[i][k], dp[j][k - <span style="color:#ff0;font-weight:bold">1</span>] + (pre[i] - pre[j]) / (i - j));
        }
        <span style="color:#fff;font-weight:bold">return</span> dp[n][K];
    }
};
</code></pre></div>
<h3 id="4-斐波那契数列">4. 斐波那契数列</h3>

<h4 id="70-爬楼梯-https-leetcode-cn-com-problems-climbing-stairs"><a href="https://leetcode-cn.com/problems/climbing-stairs/">70 爬楼梯</a></h4>

<p>每次能爬 1 或 2 阶楼梯，求爬 n 阶楼梯有多少种方法。</p>

<p>爬到当前楼梯的方法等于爬到前两阶楼梯的方法之和，因此有状态转移方程 dp[i] = dp[i - 1] + dp[i - 2]，又因为当前状态只取决于前两个状态，因此可以只使用两个变量 s1 和 s2 来保存前两个状态的结果。时间复杂度是 O(n)，空间复杂度是 O(1)。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> climbStairs(<span style="color:#fff;font-weight:bold">int</span> n) {
        <span style="color:#fff;font-weight:bold">if</span> (n &lt;= <span style="color:#ff0;font-weight:bold">1</span>)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">1</span>;
        <span style="color:#fff;font-weight:bold">int</span> s1 = <span style="color:#ff0;font-weight:bold">1</span>, s2 = <span style="color:#ff0;font-weight:bold">1</span>, temp;
        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">1</span>; i &lt; n; ++i) {
            temp = s2;
            s2 += s1;
            s1 = temp;
        }
        <span style="color:#fff;font-weight:bold">return</span> s2;
    }
};
</code></pre></div>
<h4 id="198-打家劫舍-https-leetcode-cn-com-problems-house-robber"><a href="https://leetcode-cn.com/problems/house-robber/">198 打家劫舍</a></h4>

<p>给一个带权值的数组，取不相邻的数，求能取到的最大值。</p>

<p>对于某一点，如果到之前一点为止能取到的最大值大于取当前点与之前两点的最大值的和则不取，否则取当前点，当前点的值与之前两点的最大值之和就是当前点的最优值，因此有状态转移方程 dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])，时间复杂度是 O(n)。当前点只与之前两个点有关，因此可以只使用两个变量 p1 和 p2 来保存前两个点的结果，空间复杂度是 O(1)。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> rob(vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;&amp; nums) {
        <span style="color:#fff;font-weight:bold">int</span> n = nums.size();
        <span style="color:#fff;font-weight:bold">if</span> (n &lt;= <span style="color:#ff0;font-weight:bold">2</span>)
            <span style="color:#fff;font-weight:bold">return</span> n == <span style="color:#ff0;font-weight:bold">0</span> ? <span style="color:#ff0;font-weight:bold">0</span> : n == <span style="color:#ff0;font-weight:bold">1</span> ? nums[<span style="color:#ff0;font-weight:bold">0</span>] : max(nums[<span style="color:#ff0;font-weight:bold">0</span>], nums[<span style="color:#ff0;font-weight:bold">1</span>]);
        <span style="color:#fff;font-weight:bold">int</span> p1 = nums[<span style="color:#ff0;font-weight:bold">0</span>], p2 = max(nums[<span style="color:#ff0;font-weight:bold">0</span>], nums[<span style="color:#ff0;font-weight:bold">1</span>]), temp;
        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">2</span>; i &lt; n; ++i) {
            temp = p2;
            p2 = max(p1 + nums[i], p2);
            p1 = temp;
        }
        <span style="color:#fff;font-weight:bold">return</span> p2;
    }
};
</code></pre></div>
<h4 id="213-打家劫舍-ii-https-leetcode-cn-com-problems-house-robber-ii"><a href="https://leetcode-cn.com/problems/house-robber-ii/">213 打家劫舍 II</a></h4>

<p>给一个带权值的数组，数组首尾相邻，取不相邻的数，求能取到的最大值。</p>

<p>数组首尾相邻代表不能同时取第一个点和最后一个点，因此从第一个点到倒数第二个点进行动态规划得到的就是包含第一个点而不包含最后一个点能取到的最大值，从第二个点到最后一个点进行动态规划得到的就是包含最后一个点而不包含第一个点能取到的最大值，用于上一题同样的方法分别做两次就能得到结果。时间复杂度是 O(n)，空间复杂度是 O(1)。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4">class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {
        int res = 0, n = nums.size();
        if (n &lt;= 2)
            return n == 0 ? 0 : n == 1 ? nums[0] : max(nums[0], nums[1]);
        int p1 = nums[0], p2 = max(nums[0], nums[1]);
        for (int i = 2; i &lt; n - 1; ++i) {
            int temp = p2;
            p2 = max(p2, p1 + nums[i]);
            p1 = temp;
        }
        res = p2;
        p1 = nums[1], p2 = max(nums[1], nums[2]);
        for (int i = 3; i &lt; n; ++i) {
            int temp = p2;
            p2 = max(p2, p1 + nums[i]);
            p1 = temp;
        }
        return max(res, p2);
    }
};</pre></div>
<h4 id="337-打家劫舍-iii-https-leetcode-cn-com-problems-house-robber-iii"><a href="https://leetcode-cn.com/problems/house-robber-iii/">337 打家劫舍 III</a></h4>

<p>给一个带权值的二叉树，取不相邻的数，求能取到的最大值。</p>

<p>对于一个节点，如果取节点本身则不能取两个子节点，如果取两个子节点则不能去其本身和四个子节点，因此对比其两个子节点的和与其本身和四个孙子节点的和，取最大值返回，也就是 max(dp[node-&gt;left-&gt;left] + dp [node-&gt;left-&gt;right] + dp[node-&gt;right-&gt;left] + dp [node-&gt;right-&gt;right] + dp[node], dp[node-&gt;left] + dp[node-&gt;right])。因为递归会造成大量的重复计算，因此用一个哈希表把已经计算过的节点的最优值保存下来，递归到该节点的时候直接取值防止造成TLE。时间复杂度是 O(n)，空间复杂度是 O(n)。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
    unordered_map&lt;TreeNode *, <span style="color:#fff;font-weight:bold">int</span>&gt; val;
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> rob(TreeNode *node) {
        <span style="color:#fff;font-weight:bold">if</span> (!node)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">if</span> (val.find(node) != val.end())
            <span style="color:#fff;font-weight:bold">return</span> val[node];
        <span style="color:#fff;font-weight:bold">int</span> p1 = <span style="color:#ff0;font-weight:bold">0</span>, p2 = <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">if</span> (node-&gt;left)
            p1 += rob(node-&gt;left-&gt;left) + rob(node-&gt;left-&gt;right);
        <span style="color:#fff;font-weight:bold">if</span> (node-&gt;right)
            p1 += rob(node-&gt;right-&gt;left) + rob(node-&gt;right-&gt;right);
        p1 += node-&gt;val;
        p2 += rob(node-&gt;left) + rob(node-&gt;right);
        val[node] = max(p1, p2);
        <span style="color:#fff;font-weight:bold">return</span> val[node];
    }
}
</code></pre></div>
<h4 id="873-最长的斐波那契子序列的长度-https-leetcode-cn-com-problems-length-of-longest-fibonacci-subsequence"><a href="https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/">873 最长的斐波那契子序列的长度</a></h4>

<p>给一个严格递增的数组，找到其中最长的斐波那契子序列的长度。</p>

<p>根据斐波那契数列的定义，要判断 A[i] 和 A[j] 能否在原数组中构成斐波那契数列，只需要知道 A[i - j] 是否在原数组中，并且 A[i] - A[j] &lt; A[j] &lt; A[i] 是否成立，于是我们可以用一个二维数组 dp[n][n] 来代表由 A[i] 和 A[j] 以及 A[i - j] 构成的斐波那契子序列的最长长度。为了查找 A[i - j] 是否在原数组中，我们可以用一个哈希表 pos 来保存 A[i - j] 在原数组中的下标，获取下标 k = pos[A[i] - A[j]] 后，用状态转移方程 dp[i][j] = dp[j][k] + 1 来更新最长长度。</p>

<p>注意在判断下标是否存在于哈希表中时要用 pos.find(A[i] - A[j]) == pos.end()，而不能直接用 pos[A[i] - A[j]] 来获取，这样虽然如果 A[i] - A[j] 不存在于哈希表中仍然能够得到结果 0，但效率非常低，会导致TLE。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> lenLongestFibSubseq(vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; &amp;A) {
        <span style="color:#fff;font-weight:bold">int</span> n = A.size(), res = <span style="color:#ff0;font-weight:bold">0</span>;
        vector&lt;vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;&gt; dp(n, vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;(n, <span style="color:#ff0;font-weight:bold">0</span>));
        unordered_map&lt;<span style="color:#fff;font-weight:bold">int</span>, <span style="color:#fff;font-weight:bold">int</span>&gt; pos;
        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; n; ++i) {
            pos[A[i]] = i;
            <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> j = <span style="color:#ff0;font-weight:bold">0</span>; j &lt; i; ++j) {
                <span style="color:#fff;font-weight:bold">auto</span> k = pos.find(A[i] - A[j]) == pos.end() ? -<span style="color:#ff0;font-weight:bold">1</span> : pos[A[i] - A[j]];
                dp[i][j] = A[i] - A[j] &lt; A[j] &amp;&amp; k != -<span style="color:#ff0;font-weight:bold">1</span> ? dp[j][k] + <span style="color:#ff0;font-weight:bold">1</span> : <span style="color:#ff0;font-weight:bold">2</span>;
                res = max(res, dp[i][j]);
            }
        }
        <span style="color:#fff;font-weight:bold">return</span> res &lt; <span style="color:#ff0;font-weight:bold">3</span> ? <span style="color:#ff0;font-weight:bold">0</span> : res;
    }
};
</code></pre></div>
<h3 id="5-回文">5. 回文</h3>

<h4 id="5-最长回文子串-https-leetcode-cn-com-problems-longest-palindromic-substring"><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5 最长回文子串</a></h4>

<p>找到一个字符串中的最长回文子串。</p>

<p>最简单的方法是从一个字符与其前一个/两个字符分别往两边遍历。也可以按照自下而上的动态规划思想，用一个二维数组 dp[i][j]，判断两个字符 s[i] 与 s[j] 是否相等，以及他们内侧的子字符串是否是一个回文串，状态转移方程是 dp[i][j] = s[i] == s[j] &amp;&amp; (dp[i + 1][j - 1] || j - i &lt; 3)。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    string longestPalindrome(string s) {
        <span style="color:#fff;font-weight:bold">int</span> n = s.size();
        string res;
        vector&lt;vector&lt;<span style="color:#fff;font-weight:bold">bool</span>&gt;&gt; dp(n, vector&lt;<span style="color:#fff;font-weight:bold">bool</span>&gt;(n, <span style="color:#fff;font-weight:bold">false</span>));
        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; n; ++i)
            <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> j = i; j &gt;= <span style="color:#ff0;font-weight:bold">0</span>; --j)
                <span style="color:#fff;font-weight:bold">if</span> (s[i] == s[j] &amp;&amp; (i - j &lt; <span style="color:#ff0;font-weight:bold">3</span> || dp[j + <span style="color:#ff0;font-weight:bold">1</span>][i - <span style="color:#ff0;font-weight:bold">1</span>])) {
                    dp[j][i] = <span style="color:#fff;font-weight:bold">true</span>;
                    <span style="color:#fff;font-weight:bold">if</span> (i - j + <span style="color:#ff0;font-weight:bold">1</span> &gt; res.size())
                        res = s.substr(j, i - j + <span style="color:#ff0;font-weight:bold">1</span>);
                }
        <span style="color:#fff;font-weight:bold">return</span> res;
    }
};
</code></pre></div>
<h4 id="516-最长回文子序列-https-leetcode-cn-com-problems-longest-palindromic-subsequence"><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">516 最长回文子序列</a></h4>

<p>给定一个字符串，找最长的回文子序列。</p>

<p>只有当两个字符相等时，他们才有可能和他们之间的子序列形成回文子序列，因此只需要知道他们之间的最长回文子序列的长度即可，否则他们之间的最长回文子序列只能是其中一个字符的左边或右边到另一个字符之间的最大回文子序列长度，状态转移方程是 dp[j][i] = s[i] == s[j] ? dp[j + 1][i - 1] + 2 : max(dp[j + 1][i], dp[j][i - 1])。时间复杂度是 O(n ^ 2)，空间复杂度是 O(n ^ 2)。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> longestPalindromeSubseq(string s) {
        <span style="color:#fff;font-weight:bold">int</span> n = s.size();
        <span style="color:#fff;font-weight:bold">if</span> (n &lt;= <span style="color:#ff0;font-weight:bold">1</span>)
            <span style="color:#fff;font-weight:bold">return</span> n;
        vector&lt;vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;&gt; dp(n, vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;(n, <span style="color:#ff0;font-weight:bold">0</span>));
        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">1</span>; i &lt; n; ++i) {
            dp[i][i] = <span style="color:#ff0;font-weight:bold">1</span>;
            <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> j = i - <span style="color:#ff0;font-weight:bold">1</span>; j &gt;= <span style="color:#ff0;font-weight:bold">0</span>; --j) {
                <span style="color:#fff;font-weight:bold">if</span> (s[i] == s[j])
                    dp[j][i] = dp[j + <span style="color:#ff0;font-weight:bold">1</span>][i - <span style="color:#ff0;font-weight:bold">1</span>] + <span style="color:#ff0;font-weight:bold">2</span>;
                <span style="color:#fff;font-weight:bold">else</span>
                    dp[j][i] = max(dp[j + <span style="color:#ff0;font-weight:bold">1</span>][i], dp[j][i - <span style="color:#ff0;font-weight:bold">1</span>]);
            }
        }
        <span style="color:#fff;font-weight:bold">return</span> dp[<span style="color:#ff0;font-weight:bold">0</span>][n - <span style="color:#ff0;font-weight:bold">1</span>];
    }
};
</code></pre></div>
      </div>

      <footer>
        


        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "zintrulcre" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </footer>
    </article>

    
  </section>

      </div>

      <footer class="footer">
  <section class="container">
    
    
    
    
      
      <a href="https://github.com/luizdepra/hugo-coder/tree/"></a>
    
  </section>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
    </main>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-132809676-1', 'auto');
	
	ga('send', 'pageview');
}
</script>


  </body>

</html>
