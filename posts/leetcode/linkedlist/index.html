<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Zhengyu Chen">
    <meta name="description" content="ZintrulCre @ 尾張">
    <meta name="keywords" content="ZintrulCre, 尾張">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="LeetCode 链表"/>
<meta name="twitter:description" content="LeetCode 链表 题目 1. 常规题 21 合并两个有序链表 合并两个有序链表。 逐个比较大小并添加到当前节点后面，并移动对应的链表节点。 classSolution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode *head = new ListNode(0), *node"/>

    <meta property="og:title" content="LeetCode 链表" />
<meta property="og:description" content="LeetCode 链表 题目 1. 常规题 21 合并两个有序链表 合并两个有序链表。 逐个比较大小并添加到当前节点后面，并移动对应的链表节点。 classSolution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode *head = new ListNode(0), *node" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zintrulcre.vip/posts/leetcode/linkedlist/" />
<meta property="article:published_time" content="2019-07-03T19:12:25&#43;10:00"/>
<meta property="article:modified_time" content="2019-07-03T19:12:25&#43;10:00"/>


    
      <base href="https://zintrulcre.vip/posts/leetcode/linkedlist/">
    
    <title>
  LeetCode 链表 · 尾張
</title>

    
      <link rel="canonical" href="https://zintrulcre.vip/posts/leetcode/linkedlist/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="https://zintrulcre.vip/css/coder.min.28d751104f30c16da1aa1bb04015cbe662cacfe0d1b01af4f2240ad58580069c.css" integrity="sha256-KNdREE8wwW2hqhuwQBXL5mLKz&#43;DRsBr08iQK1YWABpw=" crossorigin="anonymous" media="screen" />
    

    

    

    

    <link rel="icon" type="image/png" href="https://zintrulcre.vip/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://zintrulcre.vip/images/favicon-16x16.png" sizes="16x16">

    <meta name="generator" content="Hugo 0.55.2" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://zintrulcre.vip">
      尾張
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://zintrulcre.vip/posts/">Posts</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://zintrulcre.vip/about/">About</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">LeetCode 链表</h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fas fa-calendar"></i>
              <time datetime='2019-07-03T19:12:25&#43;10:00'>
                July 3, 2019
              </time>
            </span>
            
          </div>
          <div class="categories">
  <i class="fas fa-folder"></i>
    <a href="https://zintrulcre.vip/categories/leetcode/">LeetCode</a></div>

          
        </div>
      </header>

      <div>
        

<h1 id="leetcode-链表-https-leetcode-cn-com-tag-linked-list"><a href="https://leetcode-cn.com/tag/linked-list/">LeetCode 链表</a></h1>

<h2 id="题目">题目</h2>

<h3 id="1-常规题">1. 常规题</h3>

<h4 id="21-合并两个有序链表-https-leetcode-cn-com-problems-merge-two-sorted-lists-submissions"><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/submissions/">21 合并两个有序链表</a></h4>

<p>合并两个有序链表。</p>

<p>逐个比较大小并添加到当前节点后面，并移动对应的链表节点。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode *head = <span style="color:#fff;font-weight:bold">new</span> ListNode(<span style="color:#ff0;font-weight:bold">0</span>), *node = head;
        <span style="color:#fff;font-weight:bold">while</span> (l1 &amp;&amp; l2) {
            <span style="color:#fff;font-weight:bold">if</span> (l1-&gt;val &lt; l2-&gt;val)
                head-&gt;next = l1, l1 = l1-&gt;next;
            <span style="color:#fff;font-weight:bold">else</span>
                head-&gt;next = l2, l2 = l2-&gt;next;
            head = head-&gt;next;
        }
        <span style="color:#fff;font-weight:bold">while</span> (l1)
            head-&gt;next = l1, l1 = l1-&gt;next, head = head-&gt;next;
        <span style="color:#fff;font-weight:bold">while</span> (l2)
            head-&gt;next = l2, l2 = l2-&gt;next, head = head-&gt;next;
        <span style="color:#fff;font-weight:bold">return</span> node-&gt;next;
    }
};
</code></pre></div>
<h4 id="83-删除排序链表中的重复元素-https-leetcode-cn-com-problems-remove-duplicates-from-sorted-list-submissions"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/submissions/">83 删除排序链表中的重复元素</a></h4>

<p>删除链表中所有重复的元素。</p>

<p>将每个节点与其后面的节点的值做对比，如果相同则删除后面的节点。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    ListNode* deleteDuplicates(ListNode* head) {
        <span style="color:#fff;font-weight:bold">auto</span> ret = head;
        <span style="color:#fff;font-weight:bold">while</span> (head) {
            <span style="color:#fff;font-weight:bold">while</span> (head-&gt;next &amp;&amp; head-&gt;next-&gt;val == head-&gt;val) {
                <span style="color:#fff;font-weight:bold">auto</span> next = head-&gt;next;
                head-&gt;next = next-&gt;next;
                <span style="color:#fff;font-weight:bold">delete</span> next;
            }
            head = head-&gt;next;
        }
        <span style="color:#fff;font-weight:bold">return</span> ret;
    }
};
</code></pre></div>
<h4 id="203-移除链表元素-https-leetcode-cn-com-problems-remove-linked-list-elements-submissions"><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/submissions/">203 移除链表元素</a></h4>

<p>删除链表中等于给定值的所有节点。</p>

<p>先判断头节点是否等于给定值，再判断其后面的节点是否等于给定值。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    ListNode* removeElements(ListNode* head, <span style="color:#fff;font-weight:bold">int</span> val) {
        <span style="color:#fff;font-weight:bold">while</span> (head &amp;&amp; head-&gt;val == val) {
            <span style="color:#fff;font-weight:bold">auto</span> prev = head;
            head = head-&gt;next;
            <span style="color:#fff;font-weight:bold">delete</span> prev;
        }
        <span style="color:#fff;font-weight:bold">auto</span> ret = head;
        <span style="color:#fff;font-weight:bold">while</span> (head) {
            <span style="color:#fff;font-weight:bold">while</span> (head-&gt;next &amp;&amp; head-&gt;next-&gt;val == val) {
                <span style="color:#fff;font-weight:bold">auto</span> next = head-&gt;next;
                head-&gt;next = next-&gt;next;
                <span style="color:#fff;font-weight:bold">delete</span> next;
            }
            head = head-&gt;next;
        }
        <span style="color:#fff;font-weight:bold">return</span> ret;
    }
};
</code></pre></div>
<h4 id="817-链表组件-https-leetcode-cn-com-problems-linked-list-components-submissions"><a href="https://leetcode-cn.com/problems/linked-list-components/submissions/">817 链表组件</a></h4>

<p>给一个链表和一个数组，找到链表中一段子链表的值都在数组中的子链表的个数。</p>

<p>先将数组转换成哈希表方便查询，再依次遍历整个链表，判断一段子链表结束时或遍历结束时子链表是否是符合条件。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">int</span> numComponents(ListNode* head, vector&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;&amp; G) {
        unordered_set&lt;<span style="color:#fff;font-weight:bold">int</span>&gt; exist(G.begin(), G.end());
        <span style="color:#fff;font-weight:bold">bool</span> cont = <span style="color:#fff;font-weight:bold">false</span>, curr = <span style="color:#fff;font-weight:bold">false</span>;
        <span style="color:#fff;font-weight:bold">int</span> res = <span style="color:#ff0;font-weight:bold">0</span>;
        <span style="color:#fff;font-weight:bold">while</span> (head) {
            curr = exist.count(head-&gt;val);
            res += cont &amp;&amp; !curr;
            cont = curr;
            head = head-&gt;next;
        }
        <span style="color:#fff;font-weight:bold">return</span> res + cont;
    }
};
</code></pre></div>
<h4 id="24-两两交换链表中的节点-https-leetcode-cn-com-problems-swap-nodes-in-pairs"><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24 两两交换链表中的节点</a></h4>

<p>给一个链表，返回两两交换其中相邻的节点后的结果。</p>

<p>用三个指针把要交换的两个节点和他们的前驱节点保存下来，交换后再更新三个指针，按顺序交换即可。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    ListNode *swapPairs(ListNode *head) {
        <span style="color:#fff;font-weight:bold">if</span> (!head || !head-&gt;next)
            <span style="color:#fff;font-weight:bold">return</span> head;
        ListNode *root = <span style="color:#fff;font-weight:bold">new</span> ListNode(<span style="color:#ff0;font-weight:bold">0</span>), *prev = root;
        root-&gt;next = head;
        <span style="color:#fff;font-weight:bold">auto</span> first = head, second = head-&gt;next;
        <span style="color:#fff;font-weight:bold">while</span> (first &amp;&amp; second) {
            <span style="color:#fff;font-weight:bold">auto</span> temp = second-&gt;next;
            prev-&gt;next = second;
            second-&gt;next = first;
            first-&gt;next = temp;
            prev = first;
            first = temp;
            second = temp ? temp-&gt;next : <span style="color:#fff;font-weight:bold">nullptr</span>;
        }
        <span style="color:#fff;font-weight:bold">return</span> root-&gt;next;
    }
};
</code></pre></div>
<h3 id="2-链表反转">2. 链表反转</h3>

<h4 id="206-反转链表-https-leetcode-cn-com-problems-reverse-linked-list-submissions"><a href="https://leetcode-cn.com/problems/reverse-linked-list/submissions/">206 反转链表</a></h4>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    ListNode* reverseList(ListNode* head) {
        <span style="color:#fff;font-weight:bold">if</span> (!head)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">nullptr</span>;
        ListNode *prev = <span style="color:#fff;font-weight:bold">nullptr</span>, *curr = head, *next = head-&gt;next;
        <span style="color:#fff;font-weight:bold">while</span> (curr) {
            next = curr-&gt;next;
            curr-&gt;next = prev;
            prev = curr;
            curr = next;
        }
        <span style="color:#fff;font-weight:bold">return</span> prev;
    }
};
</code></pre></div>
<h4 id="369-给单链表加一-https-leetcode-cn-com-problems-plus-one-linked-list-submissions"><a href="https://leetcode-cn.com/problems/plus-one-linked-list/submissions/">369 给单链表加一</a></h4>

<p>用一个单链表表示一个整数，计算将其加一的结果。</p>

<p>先将链表反转方便进位，然后进行加一和进位的操作，最后再反转一次链表。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    ListNode* plusOne(ListNode* head) {
        <span style="color:#fff;font-weight:bold">if</span> (!head)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">nullptr</span>;
        head = Reverse(head);
        <span style="color:#fff;font-weight:bold">auto</span> root = head;
        <span style="color:#fff;font-weight:bold">while</span> (head) {
            <span style="color:#fff;font-weight:bold">if</span> (head-&gt;val == <span style="color:#ff0;font-weight:bold">9</span>) {
                head-&gt;val = <span style="color:#ff0;font-weight:bold">0</span>;
                <span style="color:#fff;font-weight:bold">if</span> (!head-&gt;next) {
                    head-&gt;next = <span style="color:#fff;font-weight:bold">new</span> ListNode(<span style="color:#ff0;font-weight:bold">1</span>);
                    <span style="color:#fff;font-weight:bold">break</span>;
                }
                head = head-&gt;next;
            }
            <span style="color:#fff;font-weight:bold">else</span> {
                ++head-&gt;val;
                <span style="color:#fff;font-weight:bold">break</span>;
            }
        }
        <span style="color:#fff;font-weight:bold">return</span> Reverse(root);
    }
    
    ListNode *Reverse(ListNode* head) {
        <span style="color:#fff;font-weight:bold">if</span> (!head)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">nullptr</span>;
        ListNode *prev = <span style="color:#fff;font-weight:bold">nullptr</span>, *curr = head, *next = head-&gt;next;
        <span style="color:#fff;font-weight:bold">while</span> (curr) {
            next = curr-&gt;next;
            curr-&gt;next = prev;
            prev = curr;
            curr = next;
        }
        <span style="color:#fff;font-weight:bold">return</span> prev;
    }
};
</code></pre></div>
<h3 id="3-双链表">3. 双链表</h3>

<h4 id="328-奇偶链表-https-leetcode-cn-com-problems-odd-even-linked-list-submissions"><a href="https://leetcode-cn.com/problems/odd-even-linked-list/submissions/">328 奇偶链表</a></h4>

<p>把一个链表中的奇数位节点和偶数位节点分别排在一起。</p>

<p>用两个头节点分别表示奇数位和偶数位节点的起始位置，遍历整个链表，将奇数位节点链接在奇数位起始节点后，将偶数位节点链接在偶数位起始节点后，最后将偶数位起始节点链接在奇数位最后节点后即可。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    ListNode* oddEvenList(ListNode* head) {
        <span style="color:#fff;font-weight:bold">if</span> (!head || !head-&gt;next)
            <span style="color:#fff;font-weight:bold">return</span> head;
        <span style="color:#fff;font-weight:bold">auto</span> odd = head, even = head-&gt;next, node = even-&gt;next, even_head = even;
        <span style="color:#fff;font-weight:bold">bool</span> flag = <span style="color:#fff;font-weight:bold">true</span>;
        <span style="color:#fff;font-weight:bold">while</span> (node) {
            <span style="color:#fff;font-weight:bold">if</span> (flag) {
                odd-&gt;next = node;
                odd = odd-&gt;next;
                flag = <span style="color:#fff;font-weight:bold">false</span>;
            } <span style="color:#fff;font-weight:bold">else</span> {
                even-&gt;next = node;
                even = even-&gt;next;
                flag = <span style="color:#fff;font-weight:bold">true</span>;
            }
            node = node-&gt;next;
        }
        odd-&gt;next = even_head;
        even-&gt;next = <span style="color:#fff;font-weight:bold">nullptr</span>;
        <span style="color:#fff;font-weight:bold">return</span> head;
    }
};
</code></pre></div>
<h4 id="86-分隔链表-https-leetcode-cn-com-problems-partition-list"><a href="https://leetcode-cn.com/problems/partition-list/">86 分隔链表</a></h4>

<p>给一个链表和一个值 x，重新排列链表使得所有小于 x 的节点都在大于等于 x 的节点之前。</p>

<p>用两个头节点 sth 和 geq 分别表示小于 x 和大于等于 x 的节点的起始位置，遍历整个链表，分别将各个节点链接到两个头节点之后，最后将 geq 链接到 sth 之后，再将 geq 的末端设为空指针。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    ListNode* partition(ListNode* head, <span style="color:#fff;font-weight:bold">int</span> x) {
        <span style="color:#fff;font-weight:bold">auto</span> sth = <span style="color:#fff;font-weight:bold">new</span> ListNode(<span style="color:#ff0;font-weight:bold">0</span>), sth_head = sth, geq = <span style="color:#fff;font-weight:bold">new</span> ListNode(<span style="color:#ff0;font-weight:bold">0</span>), geq_head = geq;
        <span style="color:#fff;font-weight:bold">while</span> (head) {
            <span style="color:#fff;font-weight:bold">if</span> (head-&gt;val &lt; x) {
                sth-&gt;next = head;
                sth = sth-&gt;next;
            } <span style="color:#fff;font-weight:bold">else</span> {
                geq-&gt;next = head;
                geq = geq-&gt;next;
            }
            head = head-&gt;next;
        }
        sth-&gt;next = geq_head-&gt;next;
        geq-&gt;next = <span style="color:#fff;font-weight:bold">nullptr</span>;
        <span style="color:#fff;font-weight:bold">return</span> sth_head-&gt;next;
    }
};
</code></pre></div>
<h3 id="4-双指针">4. 双指针</h3>

<h4 id="876-链表的中间结点-https-leetcode-cn-com-problems-middle-of-the-linked-list-solution-lian-biao-de-zhong-jian-jie-dian-by-leetcode"><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/solution/lian-biao-de-zhong-jian-jie-dian-by-leetcode/">876 链表的中间结点</a></h4>

<p>找链表的中间节点。</p>

<p>用两个指针 slow 和 fast，fast 每次移动两步，slow 每次移动一步，当 fast 走到末尾的时候 slow 恰好到指针的中间。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    ListNode* middleNode(ListNode* head) {
        <span style="color:#fff;font-weight:bold">auto</span> slow = head, fast = head;
        <span style="color:#fff;font-weight:bold">while</span> (fast &amp;&amp; fast-&gt;next) {
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
        }
        <span style="color:#fff;font-weight:bold">return</span> slow;
    }
};
</code></pre></div>
<h4 id="160-相交链表-https-leetcode-cn-com-problems-intersection-of-two-linked-lists-submissions"><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/submissions/">160 相交链表</a></h4>

<p>找到两个链表相交的起始节点。</p>

<p>假设链表 A 未相交的长度为 l1，链表 B 未相交的长度为 l2，相交部分的长度为 lc，为了让两个指针走相同的长度，只需要让两个指针在走到尾部的时候重新回到另一个链表的头部再继续走，最后当两个指针走过的长度都是 l1 + l2 + l3 时即相交。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        <span style="color:#fff;font-weight:bold">auto</span> a = headA, b = headB;
        <span style="color:#fff;font-weight:bold">if</span> (!a || !b)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">nullptr</span>;
        <span style="color:#fff;font-weight:bold">while</span> (a != b) {
            a = a ? a-&gt;next : headB;
            b = b ? b-&gt;next : headA;
        }
        <span style="color:#fff;font-weight:bold">return</span> a;
    }
};
</code></pre></div>
<h4 id="141-环形链表-https-leetcode-cn-com-problems-linked-list-cycle"><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141 环形链表</a></h4>

<p>判断一个链表中是否有环。</p>

<p>用两个指针 slow 和 fast，fast 每次移动两步，slow 每次移动一步，如果链表中有环那么这两个指针一定会最终相遇，否则 fast 将先到达末尾，当 fast == nullptr 或 fast-&gt;next == nullptr 即代表链表没有换并且 fast 已经到达末尾。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">bool</span> hasCycle(ListNode *head) {
        <span style="color:#fff;font-weight:bold">auto</span> slow = head, fast = head;
        <span style="color:#fff;font-weight:bold">while</span> (fast &amp;&amp; fast-&gt;next) {
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
            <span style="color:#fff;font-weight:bold">if</span> (slow == fast)
                <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">true</span>;
        }
        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">false</span>;
    }
};
</code></pre></div>
<h3 id="5-综合">5. 综合</h3>

<h4 id="234-回文链表-https-leetcode-cn-com-problems-palindrome-linked-list-submissions"><a href="https://leetcode-cn.com/problems/palindrome-linked-list/submissions/">234 回文链表</a></h4>

<p>判断一个链表是否为回文链表。</p>

<p>先找到链表的中间节点，然后将右边的链表翻转，将左边的链表从中间截断，再一次对比两边的每一个节点是否相等。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">bool</span> isPalindrome(ListNode *head) {
        <span style="color:#fff;font-weight:bold">if</span> (!head || !head-&gt;next)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">true</span>;
        <span style="color:#fff;font-weight:bold">auto</span> prev = head, slow = head, fast = head;
        <span style="color:#fff;font-weight:bold">while</span> (fast &amp;&amp; fast-&gt;next) {
            prev = slow;
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
        }
        <span style="color:#fff;font-weight:bold">auto</span> node = Reverse(fast ? slow-&gt;next : slow);
        prev-&gt;next = <span style="color:#fff;font-weight:bold">nullptr</span>;
        <span style="color:#fff;font-weight:bold">while</span> (head &amp;&amp; node &amp;&amp; head-&gt;val == node-&gt;val)
            head = head-&gt;next, node = node-&gt;next;
        <span style="color:#fff;font-weight:bold">return</span> !head &amp;&amp; !node;
    }
    
    ListNode *Reverse(ListNode *head) {
        <span style="color:#fff;font-weight:bold">if</span> (!head)
            <span style="color:#fff;font-weight:bold">return</span> head;
        ListNode *prev = <span style="color:#fff;font-weight:bold">nullptr</span>, *curr = head, *next = head-&gt;next;
        <span style="color:#fff;font-weight:bold">while</span>(curr) {
            next = curr-&gt;next;
            curr-&gt;next = prev;
            prev = curr;
            curr = next;
        }
        <span style="color:#fff;font-weight:bold">return</span> prev;
    }
};
</code></pre></div>
<h4 id="109-有序链表转换二叉搜索树-https-leetcode-cn-com-problems-convert-sorted-list-to-binary-search-tree"><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">109 有序链表转换二叉搜索树</a></h4>

<p>给一个有序链表，将其转换为一个平衡二叉搜索树。</p>

<p>先找到链表的中间节点，将其作为树的根节点，将中间节点的左边部分链表作为其左子树，右边部分链表作为其右子树。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    TreeNode *sortedListToBST(ListNode *head) {
        <span style="color:#fff;font-weight:bold">if</span> (!head)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">nullptr</span>;
        ListNode *prev = <span style="color:#fff;font-weight:bold">nullptr</span>, *slow = head, *fast = head;
        <span style="color:#fff;font-weight:bold">while</span> (fast &amp;&amp; fast-&gt;next)
            prev = slow, slow = slow-&gt;next, fast = fast-&gt;next-&gt;next;
        <span style="color:#fff;font-weight:bold">if</span> (prev)
            prev-&gt;next = <span style="color:#fff;font-weight:bold">nullptr</span>;
        <span style="color:#fff;font-weight:bold">auto</span> root = <span style="color:#fff;font-weight:bold">new</span> TreeNode(slow-&gt;val);
        root-&gt;left = sortedListToBST(prev ? head : <span style="color:#fff;font-weight:bold">nullptr</span>);
        root-&gt;right = sortedListToBST(slow-&gt;next);
        <span style="color:#fff;font-weight:bold">return</span> root;
    }
};
</code></pre></div>
<h4 id="426-将二叉搜索树转化为排序的双向链表-https-leetcode-cn-com-problems-convert-binary-search-tree-to-sorted-doubly-linked-list-submissions"><a href="https://leetcode-cn.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/submissions/">426 将二叉搜索树转化为排序的双向链表</a></h4>

<p>将一个二叉搜索树转换为一个双向循环链表。</p>

<p>对于一个根节点，其被转换为双向链表之后的前驱节点应该是其左子树中值最大的节点，也就是其左子节点的最右子节点，因此只需要先找到这个节点，然后将根节点与其首尾相连即可，在此之前应该先对根节点的左子树左对应的操作，右子树亦然。除此之外还要把最小的和最大的两个节点保存下来，将这两个节点首尾相连，形成循环链表。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
    Node *first, *last;
<span style="color:#fff;font-weight:bold">public</span>:
    Node *treeToDoublyList(Node *root) {
        first = last = <span style="color:#fff;font-weight:bold">nullptr</span>;
        TreeToList(root);
        <span style="color:#fff;font-weight:bold">if</span> (first)
            first-&gt;left = last;
        <span style="color:#fff;font-weight:bold">if</span> (last)
            last-&gt;right = first;
        <span style="color:#fff;font-weight:bold">return</span> first;
    }

    <span style="color:#fff;font-weight:bold">void</span> TreeToList(Node *root) {
        <span style="color:#fff;font-weight:bold">if</span> (!root)
            <span style="color:#fff;font-weight:bold">return</span>;
        <span style="color:#fff;font-weight:bold">if</span> (!first || first-&gt;val &gt; root-&gt;val)
            first = root;
        <span style="color:#fff;font-weight:bold">if</span> (!last || last-&gt;val &lt; root-&gt;val)
            last = root;
        <span style="color:#fff;font-weight:bold">auto</span> left = root-&gt;left, right = root-&gt;right;
        TreeToList(left);
        TreeToList(right);
        <span style="color:#fff;font-weight:bold">while</span> (left &amp;&amp; left-&gt;right)
            left = left-&gt;right;
        <span style="color:#fff;font-weight:bold">if</span> (left)
            left-&gt;right = root;
        root-&gt;left = left;
        <span style="color:#fff;font-weight:bold">while</span> (right &amp;&amp; right-&gt;left)
            right = right-&gt;left;
        <span style="color:#fff;font-weight:bold">if</span> (right)
            right-&gt;left = root;
        root-&gt;right = right;
    }
};
</code></pre></div>
<h4 id="143-重排链表-https-leetcode-cn-com-problems-reorder-list-submissions"><a href="https://leetcode-cn.com/problems/reorder-list/submissions/">143 重排链表</a></h4>

<p>将一个链表从 L0→L1→…→Ln-1→Ln 重新排列为 L0→Ln→L1→Ln-1→L2→Ln-2→&hellip;。</p>

<p>先将链表从中间分为两部分，将后半部分反转，再将对应位置的节点依次链接上。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">class</span><span style="color:#f00"> </span>Solution {
<span style="color:#fff;font-weight:bold">public</span>:
    <span style="color:#fff;font-weight:bold">void</span> reorderList(ListNode* head) {
        <span style="color:#fff;font-weight:bold">if</span> (!head)
            <span style="color:#fff;font-weight:bold">return</span>;
        <span style="color:#fff;font-weight:bold">auto</span> prev = head, slow = head, fast = head, first = head, second = head;
        <span style="color:#fff;font-weight:bold">while</span> (fast &amp;&amp; fast-&gt;next)
            prev = slow, slow = slow-&gt;next, fast = fast-&gt;next-&gt;next;
        <span style="color:#fff;font-weight:bold">if</span> (fast) {
            second = slow-&gt;next;
            slow-&gt;next = <span style="color:#fff;font-weight:bold">nullptr</span>;
        } <span style="color:#fff;font-weight:bold">else</span> {
            second = slow;
            prev-&gt;next = <span style="color:#fff;font-weight:bold">nullptr</span>;
        }
        second = Reverse(second);
        <span style="color:#fff;font-weight:bold">while</span> (second) {
            <span style="color:#fff;font-weight:bold">auto</span> n1 = first-&gt;next, n2 = second-&gt;next;
            first-&gt;next = second;
            second-&gt;next = n1;
            first = n1;
            second = n2;
        }
    }
    
    ListNode *Reverse(ListNode *head) {
        ListNode *prev = <span style="color:#fff;font-weight:bold">nullptr</span>, *curr = head, *next = <span style="color:#fff;font-weight:bold">nullptr</span>;
        <span style="color:#fff;font-weight:bold">while</span> (curr) {
            next = curr-&gt;next;
            curr-&gt;next = prev;
            prev = curr;
            curr = next;
        }
        <span style="color:#fff;font-weight:bold">return</span> prev;
    }
};
</code></pre></div>
      </div>

      <footer>
        


        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "zintrulcre" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </footer>
    </article>

    
  </section>

      </div>

      <footer class="footer">
  <section class="container">
    
    
    
    
      
      <a href="https://github.com/luizdepra/hugo-coder/tree/"></a>
    
  </section>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
    </main>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-132809676-1', 'auto');
	
	ga('send', 'pageview');
}
</script>


  </body>

</html>
