<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Zhengyu Chen">
    <meta name="description" content="ZintrulCre @ 尾張">
    <meta name="keywords" content="ZintrulCre, 尾張">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="数据库"/>
<meta name="twitter:description" content="数据库 数据库设计 函数依赖 一张数据库表中，在属性 X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X -&gt; Y 在数据表中，不"/>

    <meta property="og:title" content="数据库" />
<meta property="og:description" content="数据库 数据库设计 函数依赖 一张数据库表中，在属性 X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X -&gt; Y 在数据表中，不" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zintrulcre.vip/posts/computer-science/database/" />
<meta property="article:published_time" content="2015-07-05T08:57:52&#43;10:00"/>
<meta property="article:modified_time" content="2015-07-05T08:57:52&#43;10:00"/>


    
      <base href="https://zintrulcre.vip/posts/computer-science/database/">
    
    <title>
  数据库 · 尾張
</title>

    
      <link rel="canonical" href="https://zintrulcre.vip/posts/computer-science/database/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="https://zintrulcre.vip/css/coder.min.28d751104f30c16da1aa1bb04015cbe662cacfe0d1b01af4f2240ad58580069c.css" integrity="sha256-KNdREE8wwW2hqhuwQBXL5mLKz&#43;DRsBr08iQK1YWABpw=" crossorigin="anonymous" media="screen" />
    

    

    

    

    <link rel="icon" type="image/png" href="https://zintrulcre.vip/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://zintrulcre.vip/images/favicon-16x16.png" sizes="16x16">

    <meta name="generator" content="Hugo 0.55.2" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://zintrulcre.vip">
      尾張
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://zintrulcre.vip/posts/">Posts</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://zintrulcre.vip/about/">About</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">数据库</h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fas fa-calendar"></i>
              <time datetime='2015-07-05T08:57:52&#43;10:00'>
                July 5, 2015
              </time>
            </span>
            
          </div>
          <div class="categories">
  <i class="fas fa-folder"></i>
    <a href="https://zintrulcre.vip/categories/computer-science/">Computer Science</a></div>

          
        </div>
      </header>

      <div>
        

<h1 id="数据库">数据库</h1>

<h2 id="数据库设计">数据库设计</h2>

<h3 id="函数依赖">函数依赖</h3>

<ul>
<li>一张数据库表中，在属性 X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X -&gt; Y</li>
<li>在数据表中，不存在任意两条记录，使得它们在 X 属性上的值相同，而在 Y 属性上的值不同</li>
</ul>

<ol>
<li>完全函数依赖

<ul>
<li>一张数据库表中，若 X -&gt; Y，且对于 X 的任何一个真子集（假如属性组 X 包含超过一个属性），X → Y 不成立，那么 Y 对于 X 完全函数依赖</li>
</ul></li>
</ol>

<h3 id="范式-normal-form">范式 Normal Form</h3>

<ul>
<li>范式是数据库的表结构的设计标准，有 1NF, 2NF, 3NF, BCNF, 4NF, 5NF 等</li>
</ul>

<ol>
<li><p>第一范式</p>

<ul>
<li>1NF 是指数据库表的每个属性都不可再分</li>
<li>1NF 是所有关系型数据库的最基本要求</li>
<li>坏处：数据冗余，插入异常，修改异常，删除异常</li>
</ul></li>

<li><p>第二范式</p>

<ul>
<li>2NF 是指在 1NF 的基础之上，消除了非主属性对于主键的部分函数依赖</li>
<li>非主属性完全依赖于主键</li>
</ul></li>

<li><p>第三范式</p>

<ul>
<li>3NF 是指在 2NF 的基础之上，消除了非主属性对于主键的传递函数依赖</li>
<li>非主属性不依赖于其它非主属性</li>
</ul></li>
</ol>

<h2 id="存储引擎">存储引擎</h2>

<h3 id="innodb">InnoDB</h3>

<ul>
<li>MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎</li>
<li>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）；在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读</li>
<li>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升</li>
<li>内部进行了优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等</li>
<li>支持在线热备份；其它存储引擎在需要获取一致性视图时会停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取</li>
</ul>

<h3 id="myisam">MyISAM</h3>

<ul>
<li>设计简单，数据以紧密格式存储；对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它</li>
<li>提供了大量的特性，包括压缩表、空间数据索引等</li>
<li>不支持事务</li>
<li>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）</li>
<li>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的</li>
<li>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作</li>
</ul>

<h3 id="对比">对比</h3>

<ul>
<li>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句</li>
<li>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁</li>
<li>外键：InnoDB 支持外键</li>
<li>备份：InnoDB 支持在线热备份</li>
<li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢</li>
<li>其它：MyISAM 支持压缩表和空间数据索引</li>
</ul>

<h2 id="事务-transaction">事务 Transaction</h2>

<ul>
<li>事务是一个操作序列，用来维护数据的一致性</li>
<li>满足 ACID 原则</li>
</ul>

<h3 id="acid-原则">ACID 原则</h3>

<ol>
<li>原子性 Atomic：事务被视为不可分割的最小单元，其所有操作要么全部提交成功，要么全部失败回滚；回滚可以用回滚日志来实现，回滚日志记录事务所执行的修改操作，在回滚时反向执行所有的修改操作</li>
<li>一致性 Consistency：数据库在事务执行前后都保持一致性状态；在一性状态下，所有事务对一个数据的读取结果都是相同的</li>
<li>隔离性 Isolation：一个事务所做的修改在最终提交以前，对其它事务不可见的</li>
<li>持久性 Durability：一旦事务提交，则其所做的修改将会永远保存到数库中；使用重做日志来保证持久性</li>
</ol>

<ul>
<li>只有满足一致性，事务的执行结果才是正确的</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够被满足；此时只要能满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性；</li>
<li>事务满足持久化是为了能应对数据库崩溃的情况</li>
<li>MySQL 默认采用自动提交模式 AUTOCOMMIT；如果不显式使用 START TRANSACTION 语句来开始一个事务，那么每个查询都会被当做一个事务被自动提交</li>
</ul>

<h2 id="并发">并发</h2>

<h3 id="并发一致性问题">并发一致性问题</h3>

<ul>
<li>产生并发一致性问题主要原因是破坏了事务的隔离性</li>
<li>解决方法是通过并发控制来保证隔离性</li>
</ul>

<ol>
<li><p>丢失修改</p>

<ul>
<li>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改</li>
</ul></li>

<li><p>读脏数据
T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据</p></li>

<li><p>不可重复读
T2 读取一个数据，T1 对该数据做了修改；如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同</p></li>

<li><p>幻影读
T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同</p></li>
</ol>

<h3 id="并发控制">并发控制</h3>

<ul>
<li>并发控制包括封锁（需要用户自己控制，复杂）和事务的隔离级别（数据库系统自带，简单）</li>
</ul>

<h4 id="封锁">封锁</h4>

<h5 id="封锁粒度">封锁粒度</h5>

<ul>
<li><p>MySQL 中提供了两种封锁粒度：行级锁和表级锁</p></li>

<li><p>应该尽量只锁定需要修改的部分数据，而不是所有的资源；锁定的数据量越少，发生锁争用的可能性越小，系统的并发程度越高</p></li>

<li><p>加锁需要消耗资源，锁的各种操作（包括获取、释放、以及检查状态）都会增加系统开销；因此封锁粒度越小，系统开销就越大。</p></li>

<li><p>在选择封锁粒度时，需要在锁开销和并发程度之间做权衡</p></li>
</ul>

<h5 id="封锁类型">封锁类型</h5>

<ol>
<li><p>读写锁</p>

<ul>
<li>排它锁（Exclusive），简写为 X 锁，又称写锁</li>
<li>共享锁（Shared），简写为 S 锁，又称读锁</li>
<li>如果一个事务对数据对象 A 加了排它锁，那么它可以对 A 进行读取和更新，而其它事务不能对 A 加任何锁</li>
<li>如果一个事务对数据对象 A 加了共享锁，那么它可以对 A 进行读取操作，但是不能进行更新操作，其它事务能对 A 加共享锁，但是不能加排它锁</li>
<li>在存在行级锁和表级锁的情况下，如果事务 T 想要对表加排它锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，非常耗时</li>
</ul></li>

<li><p>意向锁</p>

<ul>
<li>意向锁（Intention Locks）可以更容易地支持多粒度封锁</li>
<li>意向锁在 X/S 锁之上引入了 IX/IS，IX/IS 都是表级锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁

<ul>
<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或更强的锁</li>
<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁</li>
</ul></li>
<li>通过引入意向锁，如果事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败</li>
</ul></li>
</ol>

<h4 id="隔离级别">隔离级别</h4>

<ul>
<li><p>未提交读（READ UNCOMMITTED）</p>

<ul>
<li>事务中的修改，即使没有提交也对其它事务可见</li>
</ul></li>

<li><p>提交读（READ COMMITTED）</p>

<ul>
<li>事务中的修改，只能在被提交之后才对其它事务可见</li>
</ul></li>

<li><p>可重复读（REPEATABLE READ）</p>

<ul>
<li>保证在同一个事务中多次读取同样数据的结果是一样的</li>
</ul></li>

<li><p>可串行化（SERIALIZABLE）</p>

<ul>
<li>强制事务串行执行</li>
<li>需要加锁实现，而其它隔离级别通常不需要。</li>
</ul></li>
</ul>

<h5 id="多版本并发控制">多版本并发控制</h5>

<ul>
<li><p>多版本并发控制（MVCC, Multi-Version Concurrency Control）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种方式，用于实现提交读和可重复读这两种隔离级别；未提交读隔离级别总是读取最新的数据行，无需使用 MVCC；可串行化隔离级别需要对所有读取的行都加锁，无法使用 MVCC 实现</p></li>

<li><p>版本号</p>

<ul>
<li>系统版本号：一个递增的数字，每开始一个新的事务，系统版本号就会递增</li>
<li>事务版本号：事务开始时的系统版本号</li>
</ul></li>

<li><p>MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号</p>

<ul>
<li>创建版本号：表示创建一个数据行的快照时的系统版本号</li>
<li>删除版本号：如果删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了</li>
</ul></li>

<li><p>Undo 日志</p>

<ul>
<li>MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来</li>
</ul></li>
</ul>

<h5 id="next-key-locks">Next-Key Locks</h5>

<ul>
<li>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现</li>
<li>MVCC 不能解决幻影读问题；在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题</li>
<li>Record Locks

<ul>
<li>锁定一个记录上的索引，而不是记录本身</li>
<li>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用</li>
</ul></li>
<li>Gap Locks

<ul>
<li>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15</li>
<li><code>SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;</code></li>
</ul></li>
<li>Next-Key Locks

<ul>
<li>Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：
<code>
(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +∞)
</code></li>
</ul></li>
</ul>

<h3 id="锁">锁</h3>

<ol>
<li><p>悲观锁</p>

<ul>
<li>悲观并发控制，又名悲观锁 Pessimistic Concurrency Control</li>
<li>悲观并发控制可以阻止一个事务以影响其他用户的方式来修改数据</li>
<li>如果一个事务执行的操作对某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作</li>
<li>悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中</li>
</ul></li>

<li><p>乐观锁</p>

<ul>
<li>乐观并发控制， 又名乐观锁，Optimistic Concurrency Control</li>
<li>乐观并发控制假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的部分数据</li>
<li>在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据；如果是，那么正在提交的事务将会进行回滚</li>
</ul></li>
</ol>

<p>##nosql</p>

<ol>
<li>redis API使用</li>
</ol>

      </div>

      <footer>
        


        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "zintrulcre" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </footer>
    </article>

    
  </section>

      </div>

      <footer class="footer">
  <section class="container">
    
    
    
    
      
      <a href="https://github.com/luizdepra/hugo-coder/tree/"></a>
    
  </section>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
    </main>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-132809676-1', 'auto');
	
	ga('send', 'pageview');
}
</script>


  </body>

</html>
