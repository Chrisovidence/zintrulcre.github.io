<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Zhengyu Chen">
    <meta name="description" content="ZintrulCre @ 尾張">
    <meta name="keywords" content="ZintrulCre, 尾張">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="操作系统"/>
<meta name="twitter:description" content="操作系统 进程 进程和线程 进程 进程是 CPU 资源分配的基本单位 进程是对程序的一个抽象，包括程序计数器、寄存器和变量的当前值 进程控制块 Process Control Block 描述进程的基"/>

    <meta property="og:title" content="操作系统" />
<meta property="og:description" content="操作系统 进程 进程和线程 进程 进程是 CPU 资源分配的基本单位 进程是对程序的一个抽象，包括程序计数器、寄存器和变量的当前值 进程控制块 Process Control Block 描述进程的基" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zintrulcre.vip/posts/computer-science/operatingsystem/" />
<meta property="article:published_time" content="2015-07-05T08:57:52&#43;10:00"/>
<meta property="article:modified_time" content="2015-07-05T08:57:52&#43;10:00"/>


    
      <base href="https://zintrulcre.vip/posts/computer-science/operatingsystem/">
    
    <title>
  操作系统 · 尾張
</title>

    
      <link rel="canonical" href="https://zintrulcre.vip/posts/computer-science/operatingsystem/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="https://zintrulcre.vip/css/coder.min.28d751104f30c16da1aa1bb04015cbe662cacfe0d1b01af4f2240ad58580069c.css" integrity="sha256-KNdREE8wwW2hqhuwQBXL5mLKz&#43;DRsBr08iQK1YWABpw=" crossorigin="anonymous" media="screen" />
    

    

    

    

    <link rel="icon" type="image/png" href="https://zintrulcre.vip/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://zintrulcre.vip/images/favicon-16x16.png" sizes="16x16">

    <meta name="generator" content="Hugo 0.55.2" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://zintrulcre.vip">
      尾張
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://zintrulcre.vip/posts/">Posts</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://zintrulcre.vip/about/">About</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">操作系统</h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fas fa-calendar"></i>
              <time datetime='2015-07-05T08:57:52&#43;10:00'>
                July 5, 2015
              </time>
            </span>
            
          </div>
          <div class="categories">
  <i class="fas fa-folder"></i>
    <a href="https://zintrulcre.vip/categories/computer-science/">Computer Science</a></div>

          
        </div>
      </header>

      <div>
        

<h1 id="操作系统">操作系统</h1>

<h2 id="进程">进程</h2>

<h3 id="进程和线程">进程和线程</h3>

<ol>
<li><p>进程</p>

<ul>
<li>进程是 CPU 资源分配的基本单位</li>
<li>进程是对程序的一个抽象，包括程序计数器、寄存器和变量的当前值</li>
<li>进程控制块 Process Control Block 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作</li>
<li>创建或销毁进程时，系统要为其分配或回收资源，如内存空间，I/O 设备等，其所付出的开销远大于创建或撤销线程时的开销</li>
<li>进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，开销较大</li>
<li>进程通信需要借助 IPC</li>
</ul></li>

<li><p>线程</p>

<ul>
<li>线程是 CPU 调度的基本单位</li>
<li>线程拥有独立的 ID，寄存器组，堆栈，程序计数器</li>
<li>线程不拥有资源，但可以访问其进程的共享代码段，公有数据等</li>
<li>同一进程的线程的切换不会引起进程切换，而从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换</li>
<li>线程切换时只需保存和设置少量寄存器内容，开销很小</li>
<li>线程通信依靠直接读写同一进程中的数据</li>
</ul></li>

<li><p>守护进程 daemon thread</p>

<ul>
<li>守护进程是运行在后台的特殊进程，它没有控制终端，一般在系统启动时开始运行，并在系统关闭时被终止</li>
<li>守护进程周期性地执行某种任务或者等待处理某些发生的事件，例如管理系统日志的守护进程 syslogd，web 服务 httpd 等</li>
<li>守护进程的父进程是 init 进程（Linux 内核启动的第一个用户态），init 进程在 fork 出子进程后就会退出，因此这些守护进程是由 init 继承来的孤儿进程</li>
</ul></li>

<li><p>fork 函数</p>

<ul>
<li>fork 函数是 Unix 系统下以自身进程创建子进程的系统调用方法</li>
<li>调用一次 fork 函数会有两个返回值，子进程的返回值是 0，父进程的返回值是子进程的 pid 且大于 0</li>
</ul></li>

<li><p>进程、线程状态查看命令：top/strace/gstack&hellip;</p></li>
</ol>

<h3 id="多线程相关api">多线程相关api</h3>

<ol>
<li>Linux

<ul>
<li>POSIX 标准</li>
<li><code>#include &lt;pthread.h&gt;</code></li>
</ul></li>
</ol>

<h3 id="锁">锁</h3>

<ol>
<li><p>互斥锁</p>

<ul>
<li>互斥锁对共享资源进行枷锁，避免多个线程在同一时刻操作一个共享资源</li>
<li>同一时刻只有一个线程能够获取互斥锁，其他申请该锁资源的线程以阻塞的方式等待，并被操作系统调度进入休眠队列</li>
</ul></li>

<li><p>自旋锁</p>

<ul>
<li>自旋锁使用一个死循环反复检查锁变量是否可用</li>
<li>普通的互斥锁在申请不到锁资源时会被操作系统调度进入休眠队列（直到锁的状态改变时被唤醒），并进行上下文切换，但自旋锁在申请不到资源时会执行死循环，使得当前 CPU 占用到达 100%</li>
<li>优点：当需求的锁会在远短于一个时间片的时间内被申请到时，可以直接获取锁资源，避免不必要的上下文切换的开销以提高效率</li>
<li>缺点：会不断地执行死循环，如果需求的锁长时间不能被申请到，会浪费整个时间片的时间</li>
</ul></li>

<li><p>读写锁</p>

<ul>
<li>读写锁用于防止同时有多个写者对共享资源进行写操作</li>
<li>共享资源的访问者被区分为读者和写者，同一时刻只有一个线程获取写锁，但可以有多个线程获取读锁</li>
</ul></li>
</ol>

<h3 id="进程间通信-inter-process-communication">进程间通信 Inter Process Communication</h3>

<ul>
<li>进程间通信指多个进程间进行数据传输或同步的方法</li>
<li>进程间通信的目的是资源共享，通知事件，进程控制等</li>
</ul>

<ol>
<li><p>匿名管道 Pipeline</p>

<ul>
<li>管道只能在具有公共祖先的两个进程之间使用</li>
<li>管道是由内核管理的一个缓冲区，其两端分别连接两个进程，一个进程会向管道输入信息，另一个进程会向管道读取信息</li>
<li>管道只支持半双工通信，数据只能向一个方向流动；当双方需要进行通信时，需要建立两个管道</li>
<li>当管道中没有信息时，读取信息的进程会等待，直到有信息被输入进管道；当管道中信息装满的时候，输入信息的进程会等待，直到有信息被读取出管道；当两个进程都被终结时，管道也会被终结</li>
<li>输入管道的消息会被添加在管道缓冲区的末尾，而读取管道的信息只能从缓冲区的头部读出；如果管道缓冲区头部的数据一直未被读出，那么写操作将被阻塞</li>
</ul></li>

<li><p>命名管道 Named Pipeline / FIFO</p>

<ul>
<li>命名管道可以在任意两个进程之间使用</li>
<li>FIFO 是一种特殊类型的文件，写进程向 FIFO 文件中进行写入，读进程从 FIFO 文件中进行读取；删除 FIFO 文件时，管道也随之消失</li>
<li>可以通过 FIFO 文件的路径来识别管道，从而让没有亲缘关系的进程之间建立连接</li>
</ul></li>

<li><p>消息队列 Message Queue</p>

<ul>
<li>消息队列是一个链表，而消息就是带有特定格式和优先级的记录节点</li>
<li>对消息队列有写权限的进程可以根据一定的规则在消息链表中添加消息，对消息队列有读权限的进程则可以从消息队列中获得所需的信息</li>
<li>消息队列随内核一直持续存在</li>
<li>优点：

<ol>
<li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难</li>
<li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法</li>
<li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收</li>
</ol></li>
</ul></li>

<li><p>共享内存 Shared Memory</p>

<ul>
<li>共享内存是可以被不同中央处理器访问的大容量内存，其允许多个进程访问同一块内存；如果一个进程向共享的内存区域写入了数据，那么共享这个内存区域的所有进程都可以访问其中的内容</li>
<li>共享内存是 Unix 下默认的进程间通信方法，常用于一个程序的多个进程间通信</li>
<li>优点：进程直接读写内存，不进行数据拷贝，效率高</li>
<li>缺点：没有同步机制保证多个进程对同一块内存区域的读写是互斥的，需要手动解决</li>
</ul></li>

<li><p>信号 Signal</p>

<ul>
<li>系统通过信号来通知进程系统中发生的事件</li>
<li>用于进程间通信以及发送信号给进程本身</li>
</ul></li>

<li><p>信号量 Semaphore</p>

<ul>
<li>信号量是一个计数器，用于协调多个进程对共享数据的访问</li>
<li>对信号量的所有操作都是原子操作，有等待 P(sv) 和 发送 V(sv) 两种操作</li>
<li>最简单的信号量是互斥信号量，其值只能取 0 或 1；进行等待操作时，会测试这个信号量的值，如果其值等于 1，就会减 1；如果其值为 0，就挂起该进程的执行；而进行发送操作时，会将该信号量的值加 1</li>
<li>例如两个进程共享初始值为 1 的互斥信号量 sv，其中一个进程执行了 P(sv) 操作，它将获得信号量并获取共享资源，并使 sv 减 1，这时第二个进程也执行了 P（sv）操作，因为此时 sv 的值为 0，它将被阻止获取共享资源，并被挂起并等待前一个进程放弃共享资源并执行 V(sv) 操作释放信号量后，才能获得信号量并获取共享资源</li>
</ul></li>

<li><p>套接字 Socket</p>

<ul>
<li>不同计算机上的进程可以通过 Socket 网络编程进行进程间通信</li>
</ul></li>
</ol>

<h3 id="计划作业-crontab">计划作业 crontab</h3>

<h2 id="内存">内存</h2>

<h3 id="虚拟内存">虚拟内存</h3>

<ul>
<li>虚拟内存是为了让物理内存扩充成为更大的逻辑内存，从而让程序获得更多的可用内存</li>
</ul>

<ol>
<li>内存状态
查看命令：free/memstat</li>
</ol>

<h2 id="io">IO</h2>

<h3 id="同步-异步-阻塞-非阻塞">同步、异步、阻塞、非阻塞</h3>

<ul>
<li>同步与异步是消息通信机制</li>
<li>阻塞与非阻塞是程序等待调用结果时的状态</li>
</ul>

<ol>
<li><p>同步</p>

<ul>
<li>同步是指一个任务需要依赖另外一个任务，只有等待被依赖的任务完成后，依赖的任务才能算完成</li>
<li>当一个同步调用发出后，调用者要一直等待消息结果返回后，才能进行后续的步骤</li>
<li>同步是一种可靠的任务序列，两个任务的状态保持一致（都成功或都失败）</li>
</ul></li>

<li><p>异步</p>

<ul>
<li>异步是指一个任务不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了</li>
<li>当一个异步调用发出后，调用者不用立刻得到消息结果</li>
<li>异步是一种不可靠的任务序列，被依赖的任务是否完成无法由依赖它的任务是否完成来确定</li>
</ul></li>

<li><p>阻塞</p>

<ul>
<li>阻塞调用是指在调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才会返回。</li>
</ul></li>

<li><p>非阻塞</p>

<ul>
<li>非阻塞调用是指在调用结果返回之前，当前线程不会被挂起</li>
</ul></li>
</ol>

<h3 id="linux-的-5-种-i-o-模型">Linux 的 5 种 I/O 模型</h3>

<ul>
<li>在 Linux下，网络 I/O 要经过两个阶段：

<ol>
<li>等待数据报文到达</li>
<li>将数据从内核缓冲区拷贝到用户内存</li>
</ol></li>
<li>根据这两个阶段的不同形式，分为了不同的 I/O 模型</li>
</ul>

<ol>
<li>阻塞 I/O 模型</li>
</ol>

<p><img src="https://raw.githubusercontent.com/ZintrulCre/zintrulcre.github.io/master/data/Computer-Science/Blocking%20IO.png" alt="Blocking I/O" /></p>

<ul>
<li>用户态调用 recvfrom，被阻塞</li>
<li>内核态等待数据，拷贝数据到内核缓冲区，返回结果</li>
<li>用户态解除阻塞状态</li>
<li>特点：IO 执行的两个阶段都会被 block</li>
</ul>

<ol>
<li>非阻塞 I/O 模型</li>
</ol>

<p><img src="https://raw.githubusercontent.com/ZintrulCre/zintrulcre.github.io/master/data/Computer-Science/Nonblocking%20IO.png" alt="Nonblocking I/O" /></p>

<ul>
<li>用户态不断调用 recvfrom</li>
<li>如果内核态中的数据还没有准备好，那么立刻返回 error，且不会阻塞用且不会阻塞用户态；否则阻塞用户态，拷贝数据，并返回结果</li>
<li>特点：用户态需要不断的发送 recvfrom 直到内核态数据准备好</li>
</ul>

<ol>
<li>I/O 多路复用</li>
</ol>

<p><img src="https://raw.githubusercontent.com/ZintrulCre/zintrulcre.github.io/master/data/Computer-Science/IO%20Multiplexing.png" alt="I/O Multiplexing" /></p>

<ul>
<li>有 select/poll/epoll 等 I/O 复用机制</li>
<li>机制被调用，用户态被阻塞，机制会同时阻塞多个文件描述符，当监测到某些文件描述符就绪时返回</li>
<li>用户态调用 recvfrom，用户态被阻塞，直到数据拷贝结束</li>
<li>特点：

<ul>
<li>机制可以同时处理多个连接</li>
<li>当处理的连接数不多时，使用 I/O Multiplexing 不一定比使用多线程阻塞 I/O 更高效</li>
</ul></li>
</ul>

<ol>
<li>信号驱动 I/O</li>
</ol>

<p><img src="https://raw.githubusercontent.com/ZintrulCre/zintrulcre.github.io/master/data/Computer-Science/Signal-Driven%20IO.png" alt="Signal-Driven IO.png" /></p>

<ul>
<li>用户态向内核发送信号并立刻返回，</li>
<li>当内核态中的数据准备好之后，向用户态发送信号</li>
<li>用户态调用 recvfrom，用户态被阻塞，直到数据拷贝结束</li>
<li>特点：只有文件拷贝阶段是阻塞的</li>
</ul>

<ol>
<li>异步 I/O</li>
</ol>

<p><img src="https://raw.githubusercontent.com/ZintrulCre/zintrulcre.github.io/master/data/Computer-Science/Asynchronous%20IO.png" alt="Asynchronous IO" /></p>

<ul>
<li>用户态调用 aio_read，并立刻返回</li>
<li>内核态等待数据，拷贝数据到内核缓冲区</li>
<li>内核态给用户态发送一个 signal，通知用户数据已经就绪</li>
<li>特点：两阶段均不阻塞</li>
</ul>

<ol>
<li>IO 状态查看命令：iostat/df/du    </li>
</ol>

<h2 id="文件">文件</h2>

<ol>
<li><p>了解inode、权限、用户、时间(ctime/mtime/atime)等文件基本属性   </p></li>

<li><p>相关shell命令：
远程文件传输scp/sz/rz&hellip;
文件定位find/whereis
lsof</p></li>
</ol>

      </div>

      <footer>
        


        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "zintrulcre" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </footer>
    </article>

    
  </section>

      </div>

      <footer class="footer">
  <section class="container">
    
    
    
    
      
      <a href="https://github.com/luizdepra/hugo-coder/tree/"></a>
    
  </section>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
    </main>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-132809676-1', 'auto');
	
	ga('send', 'pageview');
}
</script>


  </body>

</html>
