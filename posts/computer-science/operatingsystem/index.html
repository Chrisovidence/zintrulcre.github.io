<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Zhengyu Chen">
    <meta name="description" content="ZintrulCre @ 尾張">
    <meta name="keywords" content="ZintrulCre, 尾張">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="操作系统"/>
<meta name="twitter:description" content="操作系统 进程 进程和线程 进程 进程是 CPU 资源分配的基本单位 进程是对程序的一个抽象，包括程序计数器、寄存器和变量的当前值 进程控制块 Process Control Block 描述进程的基"/>

    <meta property="og:title" content="操作系统" />
<meta property="og:description" content="操作系统 进程 进程和线程 进程 进程是 CPU 资源分配的基本单位 进程是对程序的一个抽象，包括程序计数器、寄存器和变量的当前值 进程控制块 Process Control Block 描述进程的基" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zintrulcre.vip/posts/computer-science/operatingsystem/" />
<meta property="article:published_time" content="2015-07-05T08:57:52&#43;10:00"/>
<meta property="article:modified_time" content="2015-07-05T08:57:52&#43;10:00"/>


    
      <base href="https://zintrulcre.vip/posts/computer-science/operatingsystem/">
    
    <title>
  操作系统 · 尾張
</title>

    
      <link rel="canonical" href="https://zintrulcre.vip/posts/computer-science/operatingsystem/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="https://zintrulcre.vip/css/coder.min.28d751104f30c16da1aa1bb04015cbe662cacfe0d1b01af4f2240ad58580069c.css" integrity="sha256-KNdREE8wwW2hqhuwQBXL5mLKz&#43;DRsBr08iQK1YWABpw=" crossorigin="anonymous" media="screen" />
    

    

    

    

    <link rel="icon" type="image/png" href="https://zintrulcre.vip/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://zintrulcre.vip/images/favicon-16x16.png" sizes="16x16">

    <meta name="generator" content="Hugo 0.55.2" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://zintrulcre.vip">
      尾張
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://zintrulcre.vip/posts/">Posts</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://zintrulcre.vip/about/">About</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">操作系统</h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fas fa-calendar"></i>
              <time datetime='2015-07-05T08:57:52&#43;10:00'>
                July 5, 2015
              </time>
            </span>
            
          </div>
          <div class="categories">
  <i class="fas fa-folder"></i>
    <a href="https://zintrulcre.vip/categories/computer-science/">Computer Science</a></div>

          
        </div>
      </header>

      <div>
        

<h1 id="操作系统">操作系统</h1>

<h2 id="进程">进程</h2>

<h3 id="进程和线程">进程和线程</h3>

<ol>
<li><p>进程</p>

<ul>
<li>进程是 CPU 资源分配的基本单位</li>
<li>进程是对程序的一个抽象，包括程序计数器、寄存器和变量的当前值</li>
<li>进程控制块 Process Control Block 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作</li>
<li>创建或销毁进程时，系统要为其分配或回收资源，如内存空间，I/O 设备等，其所付出的开销远大于创建或撤销线程时的开销</li>
<li>进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，开销较大</li>
<li>进程通信需要借助 IPC</li>
</ul></li>

<li><p>线程</p>

<ul>
<li>线程是 CPU 调度的基本单位</li>
<li>线程拥有独立的 ID，寄存器组，堆栈，程序计数器</li>
<li>线程不拥有资源，但可以访问其进程的共享代码段，公有数据等</li>
<li>同一进程的线程的切换不会引起进程切换，而从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换</li>
<li>线程切换时只需保存和设置少量寄存器内容，开销很小</li>
<li>线程通信依靠直接读写同一进程中的数据</li>
</ul></li>

<li><p>守护进程 daemon thread</p>

<ul>
<li>守护进程是运行在后台的特殊进程，它没有控制终端，一般在系统启动时开始运行，并在系统关闭时被终止</li>
<li>守护进程周期性地执行某种任务或者等待处理某些发生的事件，例如管理系统日志的守护进程 syslogd，web 服务 httpd 等</li>
<li>守护进程的父进程是 init 进程（Linux 内核启动的第一个用户态），init 进程在 fork 出子进程后就会退出，因此这些守护进程是由 init 继承来的孤儿进程</li>
</ul></li>

<li><p>fork 函数</p>

<ul>
<li>fork 函数是 Unix 系统下以自身进程创建子进程的系统调用方法，用于拷贝一个与父进程完全相同的子进程</li>
<li>fork 的实现有两步

<ul>
<li>复制进程资源，包括进程 pcb，代码段和数据段，用户栈，内核栈，虚拟内存池，页表</li>
<li>执行进程</li>
</ul></li>
<li>函数原型 pid_t fork();

<ul>
<li>该进程为父进程时，返回子进程的pid</li>
<li>该进程为子进程时，返回 0</li>
<li>fork 执行失败时，返回 -1</li>
</ul></li>
<li>测试
```c++
int pid = fork();
if (pid == -1)
    return -1;
if (pid == 0)
    printf(&ldquo;This is father process with pid %d\n&rdquo;, getpid()      );
else
    printf(&ldquo;This is child process with pid %d\n&rdquo;, getpid())     ;</li>
</ul>

<p>/*
output
This is child process with pid 87469
This is father process with pid 87470
*/
```</p></li>
</ol>

<h3 id="锁">锁</h3>

<ol>
<li><p>互斥锁</p>

<ul>
<li>互斥锁对共享资源进行枷锁，避免多个线程在同一时刻操作一个共享资源</li>
<li>同一时刻只有一个线程能够获取互斥锁，其他申请该锁资源的线程以阻塞的方式等待，并被操作系统调度进入休眠队列</li>
</ul></li>

<li><p>自旋锁</p>

<ul>
<li>自旋锁使用一个死循环反复检查锁变量是否可用</li>
<li>普通的互斥锁在申请不到锁资源时会被操作系统调度进入休眠队列（直到锁的状态改变时被唤醒），并进行上下文切换，但自旋锁在申请不到资源时会执行死循环，使得当前 CPU 占用到达 100%</li>
<li>优点：当需求的锁会在远短于一个时间片的时间内被申请到时，可以直接获取锁资源，避免不必要的上下文切换的开销以提高效率</li>
<li>缺点：会不断地执行死循环，如果需求的锁长时间不能被申请到，会浪费整个时间片的时间</li>
</ul></li>

<li><p>读写锁</p>

<ul>
<li>读写锁用于防止同时有多个写者对共享资源进行写操作</li>
<li>共享资源的访问者被区分为读者和写者，同一时刻只有一个线程获取写锁，但可以有多个线程获取读锁</li>
</ul></li>
</ol>

<h3 id="进程间通信-inter-process-communication">进程间通信 Inter Process Communication</h3>

<ul>
<li>进程间通信指多个进程间进行数据传输或同步的方法</li>
<li>进程间通信的目的是资源共享，通知事件，进程控制等</li>
</ul>

<ol>
<li><p>匿名管道 Pipeline</p>

<ul>
<li>管道只能在具有公共祖先的两个进程之间使用</li>
<li>管道是由内核管理的一个缓冲区，其两端分别连接两个进程，一个进程会向管道输入信息，另一个进程会向管道读取信息</li>
<li>管道只支持半双工通信，数据只能向一个方向流动；当双方需要进行通信时，需要建立两个管道</li>
<li>当管道中没有信息时，读取信息的进程会等待，直到有信息被输入进管道；当管道中信息装满的时候，输入信息的进程会等待，直到有信息被读取出管道；当两个进程都被终结时，管道也会被终结</li>
<li>输入管道的消息会被添加在管道缓冲区的末尾，而读取管道的信息只能从缓冲区的头部读出；如果管道缓冲区头部的数据一直未被读出，那么写操作将被阻塞</li>
</ul></li>

<li><p>命名管道 Named Pipeline / FIFO</p>

<ul>
<li>命名管道可以在任意两个进程之间使用</li>
<li>FIFO 是一种特殊类型的文件，写进程向 FIFO 文件中进行写入，读进程从 FIFO 文件中进行读取；删除 FIFO 文件时，管道也随之消失</li>
<li>可以通过 FIFO 文件的路径来识别管道，从而让没有亲缘关系的进程之间建立连接</li>
</ul></li>

<li><p>消息队列 Message Queue</p>

<ul>
<li>消息队列是一个链表，而消息就是带有特定格式和优先级的记录节点</li>
<li>对消息队列有写权限的进程可以根据一定的规则在消息链表中添加消息，对消息队列有读权限的进程则可以从消息队列中获得所需的信息</li>
<li>消息队列随内核一直持续存在</li>
<li>优点：

<ol>
<li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难</li>
<li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法</li>
<li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收</li>
</ol></li>
</ul></li>

<li><p>共享内存 Shared Memory</p>

<ul>
<li>共享内存是可以被不同中央处理器访问的大容量内存，其允许多个进程访问同一块内存；如果一个进程向共享的内存区域写入了数据，那么共享这个内存区域的所有进程都可以访问其中的内容</li>
<li>共享内存是 Unix 下默认的进程间通信方法，常用于一个程序的多个进程间通信</li>
<li>优点：进程直接读写内存，不进行数据拷贝，效率高</li>
<li>缺点：没有同步机制保证多个进程对同一块内存区域的读写是互斥的，需要手动解决</li>
</ul></li>

<li><p>信号 Signal</p>

<ul>
<li>系统通过信号来通知进程系统中发生的事件</li>
<li>用于进程间通信以及发送信号给进程本身</li>
</ul></li>

<li><p>信号量 Semaphore</p>

<ul>
<li>信号量是一个计数器，用于协调多个进程对共享数据的访问</li>
<li>对信号量的所有操作都是原子操作，有等待 P(sv) 和 发送 V(sv) 两种操作</li>
<li>最简单的信号量是互斥信号量，其值只能取 0 或 1；进行等待操作时，会测试这个信号量的值，如果其值等于 1，就会减 1；如果其值为 0，就挂起该进程的执行；而进行发送操作时，会将该信号量的值加 1</li>
<li>例如两个进程共享初始值为 1 的互斥信号量 sv，其中一个进程执行了 P(sv) 操作，它将获得信号量并获取共享资源，并使 sv 减 1，这时第二个进程也执行了 P（sv）操作，因为此时 sv 的值为 0，它将被阻止获取共享资源，并被挂起并等待前一个进程放弃共享资源并执行 V(sv) 操作释放信号量后，才能获得信号量并获取共享资源</li>
</ul></li>

<li><p>套接字 Socket</p>

<ul>
<li>不同计算机上的进程可以通过 Socket 网络编程进行进程间通信</li>
</ul></li>
</ol>

<h3 id="计划作业-crontab">计划作业 crontab</h3>

<h2 id="内存">内存</h2>

<h3 id="虚拟内存">虚拟内存</h3>

<ul>
<li>虚拟内存是为了让物理内存扩充成为更大的逻辑内存，从而让程序获得更多的可用内存</li>
</ul>

<h2 id="缓存">缓存</h2>

<ul>
<li><p>命中率：当某个请求能够通过访问缓存而得到响应时，称为缓存命中；缓存命中率越高，缓存利用率越高</p></li>

<li><p>最大空间：缓存通常位于内存中，内存的空间相对磁盘较小，因此当缓存存放的数据量超过最大空间时，需要淘汰部分数据来存放新到达的数据</p></li>
</ul>

<h3 id="淘汰策略">淘汰策略</h3>

<ul>
<li><p>FIFO（First In First Out）：先进先出策略</p>

<ul>
<li>如果需要经常访问最新的数据，可以使用 FIFO，使得最早到达的数据被淘汰</li>
</ul></li>

<li><p>LRU（Least Recently Used）：最近最久未使用策略</p>

<ul>
<li>优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据</li>
<li>保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率</li>
</ul></li>

<li><p>LFU（Least Frequently Used）：最不经常使用策略</p>

<ul>
<li>优先淘汰一段时间内使用次数最少的数据</li>
</ul></li>
</ul>

<h3 id="内容分发网络-cdn-content-distribution-network">内容分发网络 CDN Content distribution network</h3>

<ul>
<li><p>一种互连的网络系统，利用更靠近用户的服务器将静态资源（HTML, CSS, JavaScript）分发给用户</p></li>

<li><p>优点</p>

<ul>
<li>更快地将数据分发给用户</li>
<li>通过部署多台服务器，从而提高系统整体的带宽性能</li>
<li>多台服务器可以看成是一种冗余机制，从而具有高可用性</li>
</ul></li>
</ul>

<h3 id="缓存问题">缓存问题</h3>

<ul>
<li><p>缓存穿透</p>

<ul>
<li>对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库</li>
<li>解决方案

<ul>
<li>对不存在的数据缓存一个空数据</li>
<li>对这类请求进行过滤</li>
</ul></li>
</ul></li>

<li><p>缓存雪崩</p>

<ul>
<li>在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求；当由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效，又或者缓存服务器宕机时，数据库会收到大量的请求，导致数据库崩溃</li>
<li>解决方案

<ul>
<li>防止缓存在同一时间大面积过期：通过观察用户行为，合理设置缓存过期时间来实现</li>
<li>防止缓存服务器宕机：使用分布式缓存；分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用</li>
<li>防止刚上线的系统还未将大量数据进行缓存：进行缓存预热，将相关的缓存数据直接加载到缓存系统</li>
</ul></li>
</ul></li>

<li><p>缓存一致性</p>

<ul>
<li>要求数据更新的同时缓存数据也能够实时更新</li>
<li>解决方案

<ul>
<li>在数据更新的同时立即更新缓存</li>
<li>在读缓存之前先判断缓存是否是最新的，如果不是则先进行更新</li>
</ul></li>
</ul></li>

<li><p>缓存无底洞</p>

<ul>
<li>为了满足业务要求添加大量的缓存节点，但性能不但没有好转反而出现了下降</li>
<li>产生原因

<ul>
<li>缓存系统通常采用 hash 函数将 key 映射到对应的缓存节点，随着缓存节点数目的增加，key 分布到更多的节点上，导致客户端一次批量操作会涉及多次网络操作</li>
<li>批量操作的耗时会随着节点数目的增加而不断增大</li>
<li>网络连接数变多</li>
</ul></li>
<li>解决方案

<ul>
<li>优化批量数据操作命令</li>
<li>减少网络通信次数</li>
<li>降低接入成本，使用长连接/连接池/NIO</li>
</ul></li>
</ul></li>
</ul>

<h2 id="io">IO</h2>

<h3 id="同步-异步-阻塞-非阻塞">同步、异步、阻塞、非阻塞</h3>

<ul>
<li>同步与异步是消息通信机制</li>
<li>阻塞与非阻塞是程序等待调用结果时的状态</li>
</ul>

<ol>
<li><p>同步</p>

<ul>
<li>同步是指一个任务需要依赖另外一个任务，只有等待被依赖的任务完成后，依赖的任务才能算完成</li>
<li>当一个同步调用发出后，调用者要一直等待消息结果返回后，才能进行后续的步骤</li>
<li>同步是一种可靠的任务序列，两个任务的状态保持一致（都成功或都失败）</li>
</ul></li>

<li><p>异步</p>

<ul>
<li>异步是指一个任务不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了</li>
<li>当一个异步调用发出后，调用者不用立刻得到消息结果</li>
<li>异步是一种不可靠的任务序列，被依赖的任务是否完成无法由依赖它的任务是否完成来确定</li>
</ul></li>

<li><p>阻塞</p>

<ul>
<li>阻塞调用是指在调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才会返回。</li>
</ul></li>

<li><p>非阻塞</p>

<ul>
<li>非阻塞调用是指在调用结果返回之前，当前线程不会被挂起</li>
</ul></li>
</ol>

<h2 id="文件">文件</h2>

<ol>
<li><p>了解inode、权限、用户、时间(ctime/mtime/atime)等文件基本属性   </p></li>

<li><p>相关shell命令：
远程文件传输scp/sz/rz&hellip;
文件定位find/whereis
lsof</p></li>
</ol>

      </div>

      <footer>
        


        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "zintrulcre" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </footer>
    </article>

    
  </section>

      </div>

      <footer class="footer">
  <section class="container">
    
    
    
    
      
      <a href="https://github.com/luizdepra/hugo-coder/tree/"></a>
    
  </section>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
    </main>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-132809676-1', 'auto');
	
	ga('send', 'pageview');
}
</script>


  </body>

</html>
