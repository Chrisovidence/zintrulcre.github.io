<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Zhengyu Chen">
    <meta name="description" content="ZintrulCre @ 尾張">
    <meta name="keywords" content="ZintrulCre, 尾張">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Python 源码学习：Python 解释器"/>
<meta name="twitter:description" content="Python 源码学习：Python 解释器 [TOC] Python 是一种解释型语言，一般在使用前我们会从 Python 官方网站上下载使用 C 语言开发编译的 CPython 解释器，本文用到的源码均来自 C"/>

    <meta property="og:title" content="Python 源码学习：Python 解释器" />
<meta property="og:description" content="Python 源码学习：Python 解释器 [TOC] Python 是一种解释型语言，一般在使用前我们会从 Python 官方网站上下载使用 C 语言开发编译的 CPython 解释器，本文用到的源码均来自 C" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zintrulcre.vip/posts/python/python-source-code-interpreter/" />
<meta property="article:published_time" content="2021-05-26T10:18:52+08:00" />
<meta property="article:modified_time" content="2021-05-26T10:18:52+08:00" />


    
      <base href="https://zintrulcre.vip/posts/python/python-source-code-interpreter/">
    
    <title>
  Python 源码学习：Python 解释器 · 尾張
</title>

    
      <link rel="canonical" href="https://zintrulcre.vip/posts/python/python-source-code-interpreter/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="https://zintrulcre.vip/css/coder.min.28d751104f30c16da1aa1bb04015cbe662cacfe0d1b01af4f2240ad58580069c.css" integrity="sha256-KNdREE8wwW2hqhuwQBXL5mLKz&#43;DRsBr08iQK1YWABpw=" crossorigin="anonymous" media="screen" />
    

    

    

    

    <link rel="icon" type="image/png" href="https://zintrulcre.vip/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://zintrulcre.vip/images/favicon-16x16.png" sizes="16x16">

    <meta name="generator" content="Hugo 0.75.1" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://zintrulcre.vip">
      尾張
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://zintrulcre.vip/posts/">Posts</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://zintrulcre.vip/about/">About</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">Python 源码学习：Python 解释器</h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fas fa-calendar"></i>
              <time datetime='2021-05-26T10:18:52&#43;08:00'>
                May 26, 2021
              </time>
            </span>
            
          </div>
          <div class="categories">
  <i class="fas fa-folder"></i>
    <a href="https://zintrulcre.vip/categories/python/">python</a></div>

          
        </div>
      </header>

      <div>
        <h1 id="python-源码学习python-解释器">Python 源码学习：Python 解释器</h1>
<p>[TOC]</p>
<p>Python 是一种解释型语言，一般在使用前我们会从 Python 官方网站上下载使用 C 语言开发编译的 CPython 解释器，本文用到的源码均来自 <a href="https://github.com/python/cpython">CPython</a>。</p>
<p><strong>Python 解释器</strong>（<em>Python Interpreter</em>）由 <strong>Python 编译器</strong>（<em>Python Compiler</em>）和 <strong>Python 虚拟机</strong>（<em>Python Virutal Machine</em>）两部分组成。当我们通过 Python 命令执行 Python 代码时，Python 编译器会将 Python 代码编译为 <strong>Python 字节码</strong>（<em><a href="https://www.quora.com/What-is-the-difference-between-byte-code-and-machine-code-and-what-are-its-advantages">bytecode</a></em>）；随后 Python 虚拟机会读取并逐步执行这些字节码。</p>
<h2 id="1-python-编译器">1 Python 编译器</h2>
<h3 id="11-代码对象">1.1 代码对象</h3>
<p>Python 提供了内置函数 <code>compile</code>，可以编译 Python 代码并生成一个包含字节码信息的对象，举例如下：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#007f7f"># test.py</span>
<span style="color:#fff;font-weight:bold">def</span> Square(a):
    <span style="color:#fff;font-weight:bold">return</span> a * a

<span style="color:#fff;font-weight:bold">print</span>(f<span style="color:#0ff;font-weight:bold">&#34;result:</span><span style="color:#0ff;font-weight:bold">\t\t</span><span style="color:#0ff;font-weight:bold">{Square(5)}&#34;</span>)

<span style="color:#007f7f"># main.py</span>
f = <span style="color:#0ff;font-weight:bold">&#34;test.py&#34;</span>
code_obj = <span style="color:#fff;font-weight:bold">compile</span>(<span style="color:#fff;font-weight:bold">open</span>(f).read(), f, <span style="color:#0ff;font-weight:bold">&#39;exec&#39;</span>)
<span style="color:#fff;font-weight:bold">exec</span>(code_obj)
<span style="color:#fff;font-weight:bold">print</span>(f<span style="color:#0ff;font-weight:bold">&#34;code_obj:</span><span style="color:#0ff;font-weight:bold">\t</span><span style="color:#0ff;font-weight:bold">{code_obj}&#34;</span>)
<span style="color:#fff;font-weight:bold">print</span>(f<span style="color:#0ff;font-weight:bold">&#34;type:</span><span style="color:#0ff;font-weight:bold">\t\t</span><span style="color:#0ff;font-weight:bold">{type(code_obj)}&#34;</span>)
</code></pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ python3 main.py
result:         <span style="color:#ff0;font-weight:bold">25</span>
code_obj:       &lt;code object &lt;module&gt; at 0x7f052c156b30, file <span style="color:#0ff;font-weight:bold">&#34;test.py&#34;</span>, line 1&gt;
type:           &lt;class <span style="color:#0ff;font-weight:bold">&#39;code&#39;</span>&gt;
</code></pre></div><p>可以看到生成的 <code>code_obj</code> 对象的类型是 <code>class 'code'</code>，它在源码中对应的结构体是<strong>代码对象</strong> <em>PyCodeObject</em>；代码对象是后续步骤中 Python 虚拟机操作的核心，它将字节码相关的参数个数、局部变量、变量名称、指令序列等信息包装成了一个结构体：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#007f7f">// Include/cpython/code.h
</span><span style="color:#007f7f"></span>
<span style="color:#007f7f">/* Bytecode object */</span>
<span style="color:#fff;font-weight:bold">struct</span> PyCodeObject {
    PyObject_HEAD
    <span style="color:#fff;font-weight:bold">int</span> co_argcount;            <span style="color:#007f7f">/* #arguments, except *args */</span>
    <span style="color:#fff;font-weight:bold">int</span> co_posonlyargcount;     <span style="color:#007f7f">/* #positional only arguments */</span>
    <span style="color:#fff;font-weight:bold">int</span> co_kwonlyargcount;      <span style="color:#007f7f">/* #keyword only arguments */</span>
    <span style="color:#fff;font-weight:bold">int</span> co_nlocals;             <span style="color:#007f7f">/* #local variables */</span>
    <span style="color:#fff;font-weight:bold">int</span> co_stacksize;           <span style="color:#007f7f">/* #entries needed for evaluation stack */</span>
    <span style="color:#fff;font-weight:bold">int</span> co_flags;               <span style="color:#007f7f">/* CO_..., see below */</span>
    <span style="color:#fff;font-weight:bold">int</span> co_firstlineno;         <span style="color:#007f7f">/* first source line number */</span>
    PyObject *co_code;          <span style="color:#007f7f">/* instruction opcodes */</span>
    PyObject *co_consts;        <span style="color:#007f7f">/* list (constants used) */</span>
    PyObject *co_names;         <span style="color:#007f7f">/* list of strings (names used) */</span>
    PyObject *co_varnames;      <span style="color:#007f7f">/* tuple of strings (local variable names) */</span>
    PyObject *co_freevars;      <span style="color:#007f7f">/* tuple of strings (free variable names) */</span>
    PyObject *co_cellvars;      <span style="color:#007f7f">/* tuple of strings (cell variable names) */</span>
    <span style="color:#007f7f">/* The rest aren&#39;t used in either hash or comparisons, except for co_name,
</span><span style="color:#007f7f">       used in both. This is done to preserve the name and line number
</span><span style="color:#007f7f">       for tracebacks and debuggers; otherwise, constant de-duplication
</span><span style="color:#007f7f">       would collapse identical functions/lambdas defined on different lines.
</span><span style="color:#007f7f">    */</span>
    Py_ssize_t *co_cell2arg;    <span style="color:#007f7f">/* Maps cell vars which are arguments. */</span>
    PyObject *co_filename;      <span style="color:#007f7f">/* unicode (where it was loaded from) */</span>
    PyObject *co_name;          <span style="color:#007f7f">/* unicode (name, for reference) */</span>
    PyObject *co_lnotab;        <span style="color:#007f7f">/* string (encoding addr&lt;-&gt;lineno mapping) See
</span><span style="color:#007f7f">                                   Objects/lnotab_notes.txt for details. */</span>
    <span style="color:#fff;font-weight:bold">void</span> *co_zombieframe;       <span style="color:#007f7f">/* for optimization only (see frameobject.c) */</span>
    PyObject *co_weakreflist;   <span style="color:#007f7f">/* to support weakrefs to code objects */</span>
    <span style="color:#007f7f">/* Scratch space for extra data relating to the code object.
</span><span style="color:#007f7f">       Type is a void* to keep the format private in codeobject.c to force
</span><span style="color:#007f7f">       people to go through the proper APIs. */</span>
    <span style="color:#fff;font-weight:bold">void</span> *co_extra;

    <span style="color:#007f7f">/* Per opcodes just-in-time cache
</span><span style="color:#007f7f">     *
</span><span style="color:#007f7f">     * To reduce cache size, we use indirect mapping from opcode index to
</span><span style="color:#007f7f">     * cache object:
</span><span style="color:#007f7f">     *   cache = co_opcache[co_opcache_map[next_instr - first_instr] - 1]
</span><span style="color:#007f7f">     */</span>

    <span style="color:#007f7f">// co_opcache_map is indexed by (next_instr - first_instr).
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">//  * 0 means there is no cache for this opcode.
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">//  * n &gt; 0 means there is cache in co_opcache[n-1].
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> *co_opcache_map;
    _PyOpcache *co_opcache;
    <span style="color:#fff;font-weight:bold">int</span> co_opcache_flag;  <span style="color:#007f7f">// used to determine when create a cache.
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> co_opcache_size;  <span style="color:#007f7f">// length of co_opcache.
</span><span style="color:#007f7f"></span>};
</code></pre></div><p>其中比较重要的成员有两个，分别是编译后生成的指令序列 <code>co_code</code> 和执行当前代码块所需的栈空间大小 <code>co_stacksize</code>。</p>
<h3 id="12-字节码">1.2 字节码</h3>
<p>在所有的这些成员变量中，<code>PyObject *co_code</code> 存储了编译后生成的指令序列，它是以字节的方式存储的：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#007f7f"># test.py</span>
<span style="color:#fff;font-weight:bold">def</span> Square(a):
    <span style="color:#fff;font-weight:bold">return</span> a * a

<span style="color:#fff;font-weight:bold">print</span>(f<span style="color:#0ff;font-weight:bold">&#34;result:</span><span style="color:#0ff;font-weight:bold">\t\t</span><span style="color:#0ff;font-weight:bold">{Square(5)}&#34;</span>)

<span style="color:#007f7f"># main.py</span>
f = <span style="color:#0ff;font-weight:bold">&#34;test.py&#34;</span>
code_obj = <span style="color:#fff;font-weight:bold">compile</span>(<span style="color:#fff;font-weight:bold">open</span>(f).read(), f, <span style="color:#0ff;font-weight:bold">&#39;exec&#39;</span>)
<span style="color:#fff;font-weight:bold">print</span>(f<span style="color:#0ff;font-weight:bold">&#34;code obj:</span><span style="color:#0ff;font-weight:bold">\t</span><span style="color:#0ff;font-weight:bold">{code_obj}&#34;</span>)
<span style="color:#fff;font-weight:bold">print</span>(f<span style="color:#0ff;font-weight:bold">&#34;stack size:</span><span style="color:#0ff;font-weight:bold">\t</span><span style="color:#0ff;font-weight:bold">{code_obj.co_stacksize}&#34;</span>)
result = <span style="color:#fff;font-weight:bold">exec</span>(code_obj)
bytecode = code_obj.co_code
<span style="color:#fff;font-weight:bold">print</span>(f<span style="color:#0ff;font-weight:bold">&#34;bytecode:</span><span style="color:#0ff;font-weight:bold">\t</span><span style="color:#0ff;font-weight:bold">{bytecode}&#34;</span>)
</code></pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ python3 main.py
code obj:       &lt;code object &lt;module&gt; at 0x7f26cea5ab30, file <span style="color:#0ff;font-weight:bold">&#34;test.py&#34;</span>, line 1&gt;
stack size:     <span style="color:#ff0;font-weight:bold">4</span>
result:         <span style="color:#ff0;font-weight:bold">25</span>
bytecode:       b<span style="color:#0ff;font-weight:bold">&#39;d\x00d\x01\x84\x00Z\x00e\x01d\x02e\x00d\x03\x83\x01\x9b\x00\x9d\x02\x83\x01\x01\x00d\x04S\x00&#39;</span>
</code></pre></div><p>我们可以使用 Python 内置模块 dis 来将这些字节码反编译成类似于汇编语言的格式：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#fff;font-weight:bold">import</span> dis
dis.dis(bytecode)
</code></pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">          <span style="color:#ff0;font-weight:bold">0</span> LOAD_CONST               <span style="color:#ff0;font-weight:bold">0</span> (0)
          <span style="color:#ff0;font-weight:bold">2</span> LOAD_CONST               <span style="color:#ff0;font-weight:bold">1</span> (1)
          <span style="color:#ff0;font-weight:bold">4</span> MAKE_FUNCTION            <span style="color:#ff0;font-weight:bold">0</span>
          <span style="color:#ff0;font-weight:bold">6</span> STORE_NAME               <span style="color:#ff0;font-weight:bold">0</span> (0)
          <span style="color:#ff0;font-weight:bold">8</span> LOAD_NAME                <span style="color:#ff0;font-weight:bold">1</span> (1)
         <span style="color:#ff0;font-weight:bold">10</span> LOAD_CONST               <span style="color:#ff0;font-weight:bold">2</span> (2)
         <span style="color:#ff0;font-weight:bold">12</span> LOAD_NAME                <span style="color:#ff0;font-weight:bold">0</span> (0)
         <span style="color:#ff0;font-weight:bold">14</span> LOAD_CONST               <span style="color:#ff0;font-weight:bold">3</span> (3)
         <span style="color:#ff0;font-weight:bold">16</span> CALL_FUNCTION            <span style="color:#ff0;font-weight:bold">1</span>
         <span style="color:#ff0;font-weight:bold">18</span> FORMAT_VALUE             <span style="color:#ff0;font-weight:bold">0</span>
         <span style="color:#ff0;font-weight:bold">20</span> BUILD_STRING             <span style="color:#ff0;font-weight:bold">2</span>
         <span style="color:#ff0;font-weight:bold">22</span> CALL_FUNCTION            <span style="color:#ff0;font-weight:bold">1</span>
         <span style="color:#ff0;font-weight:bold">24</span> POP_TOP
         <span style="color:#ff0;font-weight:bold">26</span> LOAD_CONST               <span style="color:#ff0;font-weight:bold">4</span> (4)
         <span style="color:#ff0;font-weight:bold">28</span> RETURN_VALUE
</code></pre></div><p>在反编译后的输出结果中，第一列代表字节码中每一条指令的<strong>偏移量</strong> <em>offset</em>；第二列代表各条<strong>助记符</strong> <em>mnemonics</em> 的名称，这些助记符可以很方便地帮助我们理解在后续的步骤中 Python 虚拟机要执行的事件；第三列则是每条指令的<strong>操作数</strong> <em>opargs</em>。</p>
<p>同时，在字节码对应的十六进制表示中，每一位数字也分别代表了不同的助记符和操作数，我们可以直接通过打印出字节码的十六进制以查看其内容：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#fff;font-weight:bold">print</span>(bytecode.hex())
</code></pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#ff0;font-weight:bold">64</span> <span style="color:#ff0;font-weight:bold">00</span> <span style="color:#ff0;font-weight:bold">64</span> <span style="color:#ff0;font-weight:bold">01</span> <span style="color:#ff0;font-weight:bold">84</span> <span style="color:#ff0;font-weight:bold">00</span> 5a <span style="color:#ff0;font-weight:bold">00</span> <span style="color:#ff0;font-weight:bold">65</span> <span style="color:#ff0;font-weight:bold">01</span> <span style="color:#ff0;font-weight:bold">64</span> <span style="color:#ff0;font-weight:bold">02</span> <span style="color:#ff0;font-weight:bold">65</span> <span style="color:#ff0;font-weight:bold">00</span> <span style="color:#ff0;font-weight:bold">64</span> <span style="color:#ff0;font-weight:bold">03</span> <span style="color:#ff0;font-weight:bold">83</span> <span style="color:#ff0;font-weight:bold">01</span> 9b <span style="color:#ff0;font-weight:bold">00</span> 9d <span style="color:#ff0;font-weight:bold">02</span> <span style="color:#ff0;font-weight:bold">83</span> <span style="color:#ff0;font-weight:bold">01</span> <span style="color:#ff0;font-weight:bold">01</span> <span style="color:#ff0;font-weight:bold">00</span> <span style="color:#ff0;font-weight:bold">64</span> <span style="color:#ff0;font-weight:bold">04</span> <span style="color:#ff0;font-weight:bold">53</span> <span style="color:#ff0;font-weight:bold">00</span>
</code></pre></div><p>以上面反编译后的输出为例，在 offset == 0 的地方可以找到数字 64，即 LOAD_CONST 加载常量助记符对应的<strong>操作码 opcode</strong>，其后紧跟着的是它的操作数 opargs == 0；而指令第四行对应的 offset == 6，可以看到 STORE_NAME 助记符对应的操作码 opcode == 5a ，其操作数 opargs == 0；以此类推。</p>
<p>Python 的 opcode 模块提供了关于 Python 虚拟机中助记符和操作码的相关信息，也可以在源码的 Include/opcode.h 中找到相关定义：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#fff;font-weight:bold">import</span> opcode
<span style="color:#fff;font-weight:bold">print</span>(opcode.opname[<span style="color:#ff0;font-weight:bold">0x64</span>])
<span style="color:#fff;font-weight:bold">print</span>(opcode.opname[<span style="color:#ff0;font-weight:bold">0x5a</span>])
<span style="color:#fff;font-weight:bold">print</span>(opcode.opmap[<span style="color:#0ff;font-weight:bold">&#39;LOAD_NAME&#39;</span>])
<span style="color:#fff;font-weight:bold">print</span>(opcode.opmap[<span style="color:#0ff;font-weight:bold">&#39;RETURN_VALUE&#39;</span>])
</code></pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">LOAD_CONST
STORE_NAME
<span style="color:#ff0;font-weight:bold">101</span>
<span style="color:#ff0;font-weight:bold">83</span>
</code></pre></div><h3 id="13-编译原理">1.3 编译原理</h3>
<p>Python 编译器的实现和其他语言类似，包含了<strong>词法分析</strong> <em>Lexical</em>，<strong>语法分析</strong> <em>Syntax Analysis</em> 和<strong>语义分析</strong> <em>Semantic Analysis</em> 等步骤，本文不再赘述编译原理的部分。</p>
<h2 id="2-python-虚拟机">2 Python 虚拟机</h2>
<p>类似于 x86-64, arm 平台和 Java 虚拟机，Python 虚拟机也是 <strong>基于栈的</strong>（<em>Stack-Based</em>），它的函数调用都是通过<strong>调用栈</strong> <em>call stack</em> 和<strong>栈帧</strong> <em>stackframe</em> 来实现的。</p>
<h3 id="21-调用栈">2.1 调用栈</h3>
<p>调用栈是 CPU 寄存器中的一块内存区域，它是一种 FILO 的数据结构，可以进行插入或删除操作的一边称为栈顶，另一边则称为栈底；对于最常见的 x86-64 架构来说，栈地址空间是自顶向下（<em>head down</em>）增长的：</p>
<p><img src="https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/python/call-stack-1.png" alt="call-stack-1"></p>
<p>在 x86-64 平台下，它拥有 16 个<strong>通用寄存器</strong> <em>general-purpose registers</em>，寄存器被集成在 CPU 芯片上，其中 rbp 寄存器保存当前栈帧的栈底（本次函数调用开始时的位置），rsp 寄存器保存当前栈帧的栈顶（函数运行时的当前位置），rbp 和 rsp 之间的空间则被称为本次函数调用的<strong>栈帧</strong> <em>stack frame</em>；在每一次发生函数调用时，调用栈上都会维护一个独立的栈帧以存储函数返回值、参数、局部变量等信息；其他通用寄存器的功能如下。</p>
<p><img src="https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/python/x86-64-registers.png" alt="x86-64-registers"></p>
<p>栈相关的最常见操作有 push 和 pop，push 操作会将一个操作数插入栈顶，这包含了两个步骤，分别是先将 rsp 寄存器保存的地址减去 8，再将操作数写入到这个地址中；而 pop 则正好相反，它先从 rsp 寄存器存储的地址取出数据，写入到其他寄存器中，再对其地址加上 8。</p>
<p>以调试一个简单的 Swap 函数调用为例；本文使用的所有汇编语言都是 <em><a href="https://csiflabs.cs.ucdavis.edu/~ssdavis/50/att-syntax.htm">AT&amp;T Syntax</a></em> 的：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#007f7f">// main.cpp
</span><span style="color:#007f7f"></span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span><span style="color:#0f0;font-weight:bold"></span>
<span style="color:#fff;font-weight:bold">using</span> <span style="color:#fff;font-weight:bold">namespace</span> std;

<span style="color:#fff;font-weight:bold">void</span> Swap(<span style="color:#fff;font-weight:bold">int</span>&amp; a, <span style="color:#fff;font-weight:bold">int</span> &amp;b)
{
    <span style="color:#fff;font-weight:bold">int</span> c = a;
    a = b;
    b = c;
}

<span style="color:#fff;font-weight:bold">int</span> main()
{
    <span style="color:#fff;font-weight:bold">int</span> a = <span style="color:#ff0;font-weight:bold">5</span>, b = <span style="color:#ff0;font-weight:bold">9</span>;
    Swap(a, b);
    cout &lt;&lt; a &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39; &#39;</span> &lt;&lt; b &lt;&lt; endl;
    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
}
</code></pre></div><p>用 gdb 打开并在 main 函数处断点；在 main 函数栈帧中，会通过 movl 指令将两个常量拷贝到内存中：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ g++ -g -O0 -o main main.cpp
$ gdb main
(gdb) b main
(gdb) r
(gdb) layout reg
</code></pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">&gt; 0x400852 &lt;main()+9&gt;      movl  $0x5,-0x14(%rbp)  # 将常量 9 保存在 rbp - 18 的位置
  0x400859 &lt;main()+16&gt;     movl  $0x9,-0x18(%rbp)  # 将常量 5 保存在 rbp - 14 的位置
</code></pre></div><p>在调用函数 Swap 前，会分别将两个参数存入 rdi 和 rsi 寄存器中：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">  0x400860 &lt;main()+23&gt;     lea   -0x18(%rbp),%rdx
  0x400864 &lt;main()+27&gt;     lea   -0x14(%rbp),%rax
  0x400868 &lt;main()+31&gt;     mov    %rdx,%rsi
  0x40086b &lt;main()+34&gt;     mov    %rax,%rdi
&gt; 0x40086e &lt;main()+37&gt;     callq  0x40081d &lt;Swap(int&amp;, int&amp;)&gt;

(gdb) p *$rsi
$6 = <span style="color:#ff0;font-weight:bold">9</span>
(gdb) p *$rdi
$7 = <span style="color:#ff0;font-weight:bold">5</span>
</code></pre></div><p>在 callq 指令处使用 stepi 进入到 Swap 函数中，此时 rbp 和 rsp 指针还分别指向 main 函数栈帧的底部和顶部，能够发现栈地址空间的确是向下增长的：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">&gt; 0x40086e &lt;main()+37&gt;     callq  0x40081d &lt;Swap(int&amp;, int&amp;)&gt;

(gdb) si

&gt; 0x40081d &lt;Swap(int&amp;, int&amp;)&gt;     push   %rbp
  0x40081e &lt;Swap(int&amp;, int&amp;)+1&gt;   mov    %rsp,%rbp

rbp            0x7fffffffe110   0x7fffffffe110
rsp            0x7fffffffe0e8   0x7fffffffe0e8
</code></pre></div><p>此时栈帧结构大致如下：</p>
<p><img src="https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/python/call-stack-2.png" alt="call-stack-2"></p>
<p>执行接下来的 push 指令，将 rbp 的值存入栈顶，可以看到 rsp 的值发生了变化：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">(gdb) ni

  0x40081d &lt;Swap(int&amp;, int&amp;)&gt;     push   %rbp
&gt; 0x40081e &lt;Swap(int&amp;, int&amp;)+1&gt;   mov    %rsp,%rbp

rbp            0x7fffffffe110   0x7fffffffe110
rsp            0x7fffffffe0e0   0x7fffffffe0e0
</code></pre></div><p>继续执行下一条 mov 指令，重置 rbp 的值，进入新的栈帧：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">(gdb) ni

rbp            0x7fffffffe0e0   0x7fffffffe0e0
rsp            0x7fffffffe0e0   0x7fffffffe0e0
</code></pre></div><p>此时栈帧结构变成了如下：</p>
<p><img src="https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/python/call-stack-3.png" alt="call-stack-3"></p>
<p>再经过一系列的 mov 指令操作，将 a 和 b 的值交换之后，执行下一条 pop 指令，将存储的上一个栈帧地址写入 rbp 中，同时修改 rsp；之后再执行 retq 指令即可继续运行 main 函数的下一条汇编指令了：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">&gt; 0x400847 &lt;Swap(int&amp;, int&amp;)+42&gt;  pop    %rbp
  0x400848 &lt;Swap(int&amp;, int&amp;)+43&gt;  retq

rbp            0x7fffffffe0e0   0x7fffffffe0e0
rsp            0x7fffffffe0e0   0x7fffffffe0e0

(gdb) ni

  0x400847 &lt;Swap(int&amp;, int&amp;)+42&gt;  pop    %rbp
&gt; 0x400848 &lt;Swap(int&amp;, int&amp;)+43&gt;  retq

rbp            0x7fffffffe110   0x7fffffffe110
rsp            0x7fffffffe0e8   0x7fffffffe0e8
</code></pre></div><p>Python 中函数调用链和调用栈之间的关系也和 x86-64 平台类似，只不过是把代码块和栈帧分别进行了封装而已。</p>
<h3 id="22-栈帧对象">2.2 栈帧对象</h3>
<p>Python 中的代码对象 PyCodeObject 本身只包含了字节码相关的信息，并不具备用于执行字节码所需要的上下文信息，因此需要引入<strong>栈帧对象 PyFrameObject</strong>，作为代码对象运行的容器，并用来模拟其他平台下的栈帧：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#007f7f">// cpython/Include/frameobject.h
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">struct</span> _frame {
    PyObject_VAR_HEAD
    <span style="color:#fff;font-weight:bold">struct</span> _frame *f_back;      <span style="color:#007f7f">/* previous frame, or NULL */</span>
    PyCodeObject *f_code;       <span style="color:#007f7f">/* code segment */</span>
    PyObject *f_builtins;       <span style="color:#007f7f">/* builtin symbol table (PyDictObject) */</span>
    PyObject *f_globals;        <span style="color:#007f7f">/* global symbol table (PyDictObject) */</span>
    PyObject *f_locals;         <span style="color:#007f7f">/* local symbol table (any mapping) */</span>
    PyObject **f_valuestack;    <span style="color:#007f7f">/* points after the last local */</span>
    PyObject *f_trace;          <span style="color:#007f7f">/* Trace function */</span>
    <span style="color:#fff;font-weight:bold">int</span> f_stackdepth;           <span style="color:#007f7f">/* Depth of value stack */</span>
    <span style="color:#fff;font-weight:bold">char</span> f_trace_lines;         <span style="color:#007f7f">/* Emit per-line trace events? */</span>
    <span style="color:#fff;font-weight:bold">char</span> f_trace_opcodes;       <span style="color:#007f7f">/* Emit per-opcode trace events? */</span>

    <span style="color:#007f7f">/* Borrowed reference to a generator, or NULL */</span>
    PyObject *f_gen;

    <span style="color:#fff;font-weight:bold">int</span> f_lasti;                <span style="color:#007f7f">/* Last instruction if called */</span>
    <span style="color:#007f7f">/* Call PyFrame_GetLineNumber() instead of reading this field
</span><span style="color:#007f7f">       directly.  As of 2.3 f_lineno is only valid when tracing is
</span><span style="color:#007f7f">       active (i.e. when f_trace is set).  At other times we use
</span><span style="color:#007f7f">       PyCode_Addr2Line to calculate the line from the current
</span><span style="color:#007f7f">       bytecode index. */</span>
    <span style="color:#fff;font-weight:bold">int</span> f_lineno;               <span style="color:#007f7f">/* Current line number */</span>
    <span style="color:#fff;font-weight:bold">int</span> f_iblock;               <span style="color:#007f7f">/* index in f_blockstack */</span>
    PyFrameState f_state;       <span style="color:#007f7f">/* What state the frame is in */</span>
    PyTryBlock f_blockstack[CO_MAXBLOCKS]; <span style="color:#007f7f">/* for try and loop blocks */</span>
    PyObject *f_localsplus[<span style="color:#ff0;font-weight:bold">1</span>];  <span style="color:#007f7f">/* locals+stack, dynamically sized */</span>
};

<span style="color:#007f7f">// cpython/Include/pyframe.h
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">typedef</span> <span style="color:#fff;font-weight:bold">struct</span> _frame PyFrameObject;
</code></pre></div><p>可以看到栈帧对象中大致包含了以下数据，它们构成了 Python 虚拟机执行当前栈帧所需要的所有上下文：</p>
<ul>
<li>上一个运行的栈帧对象的指针 <code>struct _frame *f_back</code>；Python 虚拟机中运行的所有栈帧对象的 <code>*f_back</code> 共同组成调用栈结构，仅有初始栈帧有 <code>f_back == NULL</code>；</li>
<li>代码对象指针 <code>PyCodeObject *f_code</code>，它包含了当前运行栈帧所执行的字节码信息；</li>
<li>代码对象执行期间的栈结构 <code>PyObject **f_valuestack</code>，在对字节码进行运算时，需要从栈顶读取数据，并将运算结果存储在栈顶，<code>f_valuestack</code> 就是用来用来存储数据的栈结构，它的大小由对应的代码对象 <code>f_code</code> 的堆栈大小决定；</li>
<li>代码对象执行期间使用的栈结构的深度 <code>int f_stackdepth</code>；</li>
<li>上一条执行过的字节码指令 <code>int f_lasti</code>，类似于 rip 寄存器；</li>
<li>内置命名空间、全局命名空间、局部命名空间的指针 <code>PyObject *f_builtins</code>, <code>PyObject *f_globals</code>, <code>PyObject *f_locals</code>，它们是用来实现 Python 中从符号到对象的映射的结构，一般用字典实现，暂不讨论；</li>
<li>用于跟踪代码执行情况的函数指针 <code>PyObject *f_trace</code> 和相关数据 <code>char f_trace_lines</code>, <code>char f_trace_opcodes</code>，暂不讨论；</li>
<li>用于执行生成器代码的数据 <code>PyObject *f_gen</code>，暂不讨论；</li>
</ul>
<p>Python 在 <code>sys</code> 模块中提供了 <code>_getframe</code> 函数来获取栈帧对象；以一个简单的 Swap 函数为例，在最深层的函数调用处打印出栈帧对象的信息：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#fff;font-weight:bold">import</span> sys

<span style="color:#fff;font-weight:bold">def</span> Swap(a, b):
    frame = sys._getframe()
    <span style="color:#fff;font-weight:bold">while</span> frame is not None:
        <span style="color:#fff;font-weight:bold">print</span>(f<span style="color:#0ff;font-weight:bold">&#34;frame:</span><span style="color:#0ff;font-weight:bold">\t</span><span style="color:#0ff;font-weight:bold">{frame}&#34;</span>)
        <span style="color:#fff;font-weight:bold">print</span>(f<span style="color:#0ff;font-weight:bold">&#34;name:</span><span style="color:#0ff;font-weight:bold">\t</span><span style="color:#0ff;font-weight:bold">{frame.f_code.co_name}&#34;</span>)
        <span style="color:#fff;font-weight:bold">print</span>(f<span style="color:#0ff;font-weight:bold">&#34;locals:</span><span style="color:#0ff;font-weight:bold">\t</span><span style="color:#0ff;font-weight:bold">{frame.f_locals.keys()}</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>)
        <span style="color:#fff;font-weight:bold">print</span>(f<span style="color:#0ff;font-weight:bold">&#34;back:</span><span style="color:#0ff;font-weight:bold">\t</span><span style="color:#0ff;font-weight:bold">{frame.f_back}</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>)
        frame = frame.f_back

    <span style="color:#fff;font-weight:bold">return</span> b, a

<span style="color:#fff;font-weight:bold">def</span> main():
    a, b = <span style="color:#ff0;font-weight:bold">5</span>, <span style="color:#ff0;font-weight:bold">9</span>
    a, b = Swap(a, b)
    <span style="color:#fff;font-weight:bold">print</span>(a, b)

<span style="color:#fff;font-weight:bold">if</span> __name__ == <span style="color:#0ff;font-weight:bold">&#34;__main__&#34;</span>:
    main()
</code></pre></div><p>运行后可以观察到，在 Python 程序开始执行时会先创建一个叫做 module 的栈帧对象用于执行当前脚本中的代码；在每次函数调用的过程中，都会创建出一个新的栈帧对象，这些栈帧对象会使用 <code>f_back</code> 指针保存上一个执行栈帧的地址，并在之后调用其他函数的时候被压入栈顶：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ python3 main.py
frame:  &lt;frame at 0x7fe37d7e5900, file <span style="color:#0ff;font-weight:bold">&#39;/main.py&#39;</span>, line 36, code Swap&gt;
name:   Swap
locals: dict_keys([<span style="color:#0ff;font-weight:bold">&#39;a&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;b&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;frame&#39;</span>])
back:   &lt;frame at 0x7fe71ca65040, file <span style="color:#0ff;font-weight:bold">&#39;/main.py&#39;</span>, line 46, code main&gt;

frame:  &lt;frame at 0x7fe376115040, file <span style="color:#0ff;font-weight:bold">&#39;/main.py&#39;</span>, line 46, code main&gt;
name:   main
locals: dict_keys([<span style="color:#0ff;font-weight:bold">&#39;a&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;b&#39;</span>])
back:   &lt;frame at 0x141f6f0, file <span style="color:#0ff;font-weight:bold">&#39;/main.py&#39;</span>, line 50, code &lt;module&gt;&gt;

frame:  &lt;frame at 0x1ade6f0, file <span style="color:#0ff;font-weight:bold">&#39;/main.py&#39;</span>, line 50, code &lt;module&gt;&gt;
name:   &lt;module&gt;
locals: dict_keys([<span style="color:#0ff;font-weight:bold">&#39;__name__&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;__doc__&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;__package__&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;__loader__&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;__spec__&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;__annotations__&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;__builtins__&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;__file__&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;__cached__&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;sys&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;Swap&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;main&#39;</span>])
back:   None

<span style="color:#ff0;font-weight:bold">9</span> <span style="color:#ff0;font-weight:bold">5</span>
</code></pre></div><h4 id="221-回收和分配">2.2.1 回收和分配</h4>
<p>前文讨论过类型对象，从刚才获取栈帧对象的例子里能够看到通过 <code>sys._getframe()</code> 获取的 <code>frame</code> 对象的类型名为 <code>frame</code>，不难找到它的类型对象实际上是 <code>PyFrame_Type</code>，我们可以从类型对象初始化时使用的函数指针找到它的相关操作：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">PyTypeObject PyFrame_Type = {
    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span style="color:#ff0;font-weight:bold">0</span>)
    <span style="color:#0ff;font-weight:bold">&#34;frame&#34;</span>,
    <span style="color:#fff;font-weight:bold">sizeof</span>(PyFrameObject),
    <span style="color:#fff;font-weight:bold">sizeof</span>(PyObject *),
    (destructor)frame_dealloc,                  <span style="color:#007f7f">/* tp_dealloc */</span>
    <span style="color:#ff0;font-weight:bold">0</span>,                                          <span style="color:#007f7f">/* tp_vectorcall_offset */</span>
    <span style="color:#ff0;font-weight:bold">0</span>,                                          <span style="color:#007f7f">/* tp_getattr */</span>
    <span style="color:#ff0;font-weight:bold">0</span>,                                          <span style="color:#007f7f">/* tp_setattr */</span>
    <span style="color:#ff0;font-weight:bold">0</span>,                                          <span style="color:#007f7f">/* tp_as_async */</span>
    (reprfunc)frame_repr,                       <span style="color:#007f7f">/* tp_repr */</span>
    <span style="color:#ff0;font-weight:bold">0</span>,                                          <span style="color:#007f7f">/* tp_as_number */</span>
    <span style="color:#ff0;font-weight:bold">0</span>,                                          <span style="color:#007f7f">/* tp_as_sequence */</span>
    <span style="color:#ff0;font-weight:bold">0</span>,                                          <span style="color:#007f7f">/* tp_as_mapping */</span>
    <span style="color:#ff0;font-weight:bold">0</span>,                                          <span style="color:#007f7f">/* tp_hash */</span>
    <span style="color:#ff0;font-weight:bold">0</span>,                                          <span style="color:#007f7f">/* tp_call */</span>
    <span style="color:#ff0;font-weight:bold">0</span>,                                          <span style="color:#007f7f">/* tp_str */</span>
    PyObject_GenericGetAttr,                    <span style="color:#007f7f">/* tp_getattro */</span>
    PyObject_GenericSetAttr,                    <span style="color:#007f7f">/* tp_setattro */</span>
    <span style="color:#ff0;font-weight:bold">0</span>,                                          <span style="color:#007f7f">/* tp_as_buffer */</span>
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,<span style="color:#007f7f">/* tp_flags */</span>
    <span style="color:#ff0;font-weight:bold">0</span>,                                          <span style="color:#007f7f">/* tp_doc */</span>
    (traverseproc)frame_traverse,               <span style="color:#007f7f">/* tp_traverse */</span>
    (inquiry)frame_tp_clear,                    <span style="color:#007f7f">/* tp_clear */</span>
    <span style="color:#ff0;font-weight:bold">0</span>,                                          <span style="color:#007f7f">/* tp_richcompare */</span>
    <span style="color:#ff0;font-weight:bold">0</span>,                                          <span style="color:#007f7f">/* tp_weaklistoffset */</span>
    <span style="color:#ff0;font-weight:bold">0</span>,                                          <span style="color:#007f7f">/* tp_iter */</span>
    <span style="color:#ff0;font-weight:bold">0</span>,                                          <span style="color:#007f7f">/* tp_iternext */</span>
    frame_methods,                              <span style="color:#007f7f">/* tp_methods */</span>
    frame_memberlist,                           <span style="color:#007f7f">/* tp_members */</span>
    frame_getsetlist,                           <span style="color:#007f7f">/* tp_getset */</span>
    <span style="color:#ff0;font-weight:bold">0</span>,                                          <span style="color:#007f7f">/* tp_base */</span>
    <span style="color:#ff0;font-weight:bold">0</span>,                                          <span style="color:#007f7f">/* tp_dict */</span>
};
</code></pre></div><p>其中对栈帧对象进行析构的函数是 <code>frame_dealloc</code>，此处省略了部分代码：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#0f0;font-weight:bold">#define PyFrame_MAXFREELIST 200
</span><span style="color:#0f0;font-weight:bold"></span>
<span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> _Py_HOT_FUNCTION
frame_dealloc(PyFrameObject *f)
{
    <span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span>    Py_XDECREF(f-&gt;f_back);
    Py_DECREF(f-&gt;f_builtins);
    Py_DECREF(f-&gt;f_globals);
    Py_CLEAR(f-&gt;f_locals);
    Py_CLEAR(f-&gt;f_trace);

    PyCodeObject *co = f-&gt;f_code;
    <span style="color:#fff;font-weight:bold">if</span> (co-&gt;co_zombieframe  == <span style="color:#fff;font-weight:bold">NULL</span>) {
        co-&gt;co_zombieframe = f;
    }
    <span style="color:#fff;font-weight:bold">else</span> {
        <span style="color:#fff;font-weight:bold">struct</span> _Py_frame_state *state = get_frame_state();
<span style="color:#0f0;font-weight:bold">#ifdef Py_DEBUG
</span><span style="color:#0f0;font-weight:bold"></span>        <span style="color:#007f7f">// frame_dealloc() must not be called after _PyFrame_Fini()
</span><span style="color:#007f7f"></span>        assert(state-&gt;numfree != -<span style="color:#ff0;font-weight:bold">1</span>);
<span style="color:#0f0;font-weight:bold">#endif
</span><span style="color:#0f0;font-weight:bold"></span>        <span style="color:#fff;font-weight:bold">if</span> (state-&gt;numfree &lt; PyFrame_MAXFREELIST) {
            ++state-&gt;numfree;
            f-&gt;f_back = state-&gt;free_list;
            state-&gt;free_list = f;
        }
        <span style="color:#fff;font-weight:bold">else</span> {
            PyObject_GC_Del(f);
        }
    }

    Py_DECREF(co);
    Py_TRASHCAN_SAFE_END(f)
}


<span style="color:#fff;font-weight:bold">struct</span> _Py_frame_state {
    PyFrameObject *free_list;
    <span style="color:#007f7f">/* number of frames currently in free_list */</span>
    <span style="color:#fff;font-weight:bold">int</span> numfree;
};

</code></pre></div><p>这是一个使用非常高频的函数（几乎每一次栈帧退出时都会调用），因此采用了一些策略来进行优化以降低调用函数的开销；一种是在首次进行栈帧对象 <code>f</code> 的回收时会先判断栈帧对象关联的代码对象 <code>co</code> 的成员指针 <code>co_zombieframe</code> 是否为空 <code>if (co-&gt;co_zombieframe == NULL)</code>；如果是，则会将该栈帧对象 <code>f</code> 保存在代码对象的这个指针中 <code>co-&gt;co_zombieframe = f</code>，这样的话在下一次执行相同的代码对象 <code>co</code> 时，就无需再次重新进行栈帧对象 <code>f</code> 的内存分配（只要代码对象 <code>co</code> 不因为引用计数降低为 0 而被 gc）；对于栈帧对象来说，仅有 <code>ob_type</code>, <code>ob_size</code>, <code>f_code</code>, <code>f_valuestack</code> 几个成员变量会保留原有的值，因为这些成员变量与其他对象没有关联，而 <code>f_locals</code>, <code>f_trace</code>, <code>f_exc_type</code> 等指针依然会被通过 <code>Py_CLEAR</code> 置为 NULL，因为通过这些指针关联的对象可能会通过其他途径被回收，从而导致悬空指针的问题。</p>
<p>另一个优化策略是当代码对象 <code>co</code> 的成员指针 <code>co-&gt;co_zombieframe</code> 不为空，即再次执行相同栈帧时，会使用由 Python 线程维护的缓存栈帧链表 <code>state-&gt;free_list</code> 将栈帧对象存储下来，此时如果有新的栈帧对象被定义的话，可以直接从缓存栈帧链表 <code>state-&gt;free_list</code> 中获取一个已经分配内存的栈帧对象直接赋值并使用，以达到减少分配和回收内存的效果。此处可以结合分配栈帧的 <code>frame_alloc</code> 函数来看：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">inline</span> PyFrameObject*
frame_alloc(PyCodeObject *code)
{
    <span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> (state-&gt;free_list == <span style="color:#fff;font-weight:bold">NULL</span>)
    {
        f = PyObject_GC_NewVar(PyFrameObject, &amp;PyFrame_Type, extras);
        <span style="color:#fff;font-weight:bold">if</span> (f == <span style="color:#fff;font-weight:bold">NULL</span>) {
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">NULL</span>;
        }
    }
    <span style="color:#fff;font-weight:bold">else</span> {
<span style="color:#0f0;font-weight:bold">#ifdef Py_DEBUG
</span><span style="color:#0f0;font-weight:bold"></span>        <span style="color:#007f7f">// frame_alloc() must not be called after _PyFrame_Fini()
</span><span style="color:#007f7f"></span>        assert(state-&gt;numfree != -<span style="color:#ff0;font-weight:bold">1</span>);
<span style="color:#0f0;font-weight:bold">#endif
</span><span style="color:#0f0;font-weight:bold"></span>        assert(state-&gt;numfree &gt; <span style="color:#ff0;font-weight:bold">0</span>);
        --state-&gt;numfree;
        f = state-&gt;free_list;
        state-&gt;free_list = state-&gt;free_list-&gt;f_back;
        <span style="color:#fff;font-weight:bold">if</span> (Py_SIZE(f) &lt; extras) {
            PyFrameObject *new_f = PyObject_GC_Resize(PyFrameObject, f, extras);
            <span style="color:#fff;font-weight:bold">if</span> (new_f == <span style="color:#fff;font-weight:bold">NULL</span>) {
                PyObject_GC_Del(f);
                <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">NULL</span>;
            }
            f = new_f;
        }
        _Py_NewReference((PyObject *)f);
    }
    <span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span>}
</code></pre></div><p>可以看到在进行栈帧对象的分配时，会优先判断缓存栈帧链表 <code>state-&gt;free_list</code> 是否为空，不为空的话则会从其链表头部取出一个已经分配好内存的栈帧对象，对其赋值并使用。</p>
<p>这项优化（将未使用的栈帧对象保存在缓存栈帧链表中，并在创建其他栈帧对象时重复利用）与前者（在栈帧退出时将栈帧对象随代码对象保存下来，在执行相同代码对象时直接使用）的做法有些冲突，因此前者在最新的 <em><a href="https://github.com/python/cpython/commit/b11a951f16f0603d98de24fee5c023df83ea552c">PR 26076</a></em> 中已经被移除了。</p>
<p><img src="https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/python/co_zombieframe.png" alt="co_zombieframe.png"></p>
<h3 id="23-运行过程">2.3 运行过程</h3>
<h4 id="231-调用流程">2.3.1 调用流程</h4>
<p>Python 的 main 函数在 cpython/Programs/python.c 文件中，这部分实现比较简单，其调用链可以总结如下：</p>
<p><img src="https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/python/main.png" alt="main.png"></p>
<p>从调用链中可以看到，在真正执行 Python 代码之前，会先读取配置并进行初始化，这些配置会被保存到 cpython/Include/cpython/initconfig.h 文件定义的 PyConfig 结构体中，这个结构体包含了 Python 运行时的环境变量，运行模式等信息；而调用链中 <code>pymain_run_python</code> 函数后的五个分支就分别代表了 Python 通过命令行、文件、标准输入等方式运行的五种模式，但无论是那种模式，最终都会通过调用 <code>run_eval_code_obj</code> 以及 <code>PyEval_EvalCode</code> 函数来执行编译后的代码对象，后者就是 Python 虚拟机执行指令的入口之一。</p>
<h4 id="232-运行栈帧">2.3.2 运行栈帧</h4>
<p>Python 虚拟机中执行指令的入口有 <code>PyEval_EvalCode</code> 和 <code>PyEval_EvalCodeEx</code>，前者相对于后者省略了部分参数，仅将必须的代码对象，全局变量和局部变量作为参数传入，其他参数均设为 NULL。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#007f7f">// cpython/Python/eval.h
</span><span style="color:#007f7f"></span>PyAPI_FUNC(PyObject *) PyEval_EvalCode(PyObject *, PyObject *, PyObject *);

PyAPI_FUNC(PyObject *) PyEval_EvalCodeEx(PyObject *co,
                                         PyObject *globals,
                                         PyObject *locals,
                                         PyObject *<span style="color:#fff;font-weight:bold">const</span> *args, <span style="color:#fff;font-weight:bold">int</span> argc,
                                         PyObject *<span style="color:#fff;font-weight:bold">const</span> *kwds, <span style="color:#fff;font-weight:bold">int</span> kwdc,
                                         PyObject *<span style="color:#fff;font-weight:bold">const</span> *defs, <span style="color:#fff;font-weight:bold">int</span> defc,
                                         PyObject *kwdefs, PyObject *closure);

<span style="color:#007f7f">// cpython/Python/ceval.c
</span><span style="color:#007f7f"></span>PyObject *
PyEval_EvalCode(PyObject *co, PyObject *globals, PyObject *locals)
{
    <span style="color:#fff;font-weight:bold">return</span> PyEval_EvalCodeEx(co,
                      globals, locals,
                      (PyObject **)<span style="color:#fff;font-weight:bold">NULL</span>, <span style="color:#ff0;font-weight:bold">0</span>,
                      (PyObject **)<span style="color:#fff;font-weight:bold">NULL</span>, <span style="color:#ff0;font-weight:bold">0</span>,
                      (PyObject **)<span style="color:#fff;font-weight:bold">NULL</span>, <span style="color:#ff0;font-weight:bold">0</span>,
                      <span style="color:#fff;font-weight:bold">NULL</span>, <span style="color:#fff;font-weight:bold">NULL</span>);
}
</code></pre></div><p>而 <code>PyEval_EvalCodeEx</code> 实际上会调用 <code>_PyEval_EvalCodeWithName</code> 函数，进行参数个数和类型的校验，以及线程状态的检查，并最终调用了 <code>_PyEval_EvalCode</code> 函数：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">PyObject *
_PyEval_EvalCodeWithName(PyObject *_co, PyObject *globals, PyObject *locals,
           PyObject *<span style="color:#fff;font-weight:bold">const</span> *args, Py_ssize_t argcount,
           PyObject *<span style="color:#fff;font-weight:bold">const</span> *kwnames, PyObject *<span style="color:#fff;font-weight:bold">const</span> *kwargs,
           Py_ssize_t kwcount, <span style="color:#fff;font-weight:bold">int</span> kwstep,
           PyObject *<span style="color:#fff;font-weight:bold">const</span> *defs, Py_ssize_t defcount,
           PyObject *kwdefs, PyObject *closure,
           PyObject *name, PyObject *qualname)
{
    PyThreadState *tstate = _PyThreadState_GET();
    <span style="color:#fff;font-weight:bold">return</span> _PyEval_EvalCode(tstate, _co, globals, locals,
               args, argcount,
               kwnames, kwargs,
               kwcount, kwstep,
               defs, defcount,
               kwdefs, closure,
               name, qualname);
}

PyObject *
PyEval_EvalCodeEx(PyObject *_co, PyObject *globals, PyObject *locals,
                  PyObject *<span style="color:#fff;font-weight:bold">const</span> *args, <span style="color:#fff;font-weight:bold">int</span> argcount,
                  PyObject *<span style="color:#fff;font-weight:bold">const</span> *kws, <span style="color:#fff;font-weight:bold">int</span> kwcount,
                  PyObject *<span style="color:#fff;font-weight:bold">const</span> *defs, <span style="color:#fff;font-weight:bold">int</span> defcount,
                  PyObject *kwdefs, PyObject *closure)
{
    <span style="color:#fff;font-weight:bold">return</span> _PyEval_EvalCodeWithName(_co, globals, locals,
                                    args, argcount,
                                    kws, kws != <span style="color:#fff;font-weight:bold">NULL</span> ? kws + <span style="color:#ff0;font-weight:bold">1</span> : <span style="color:#fff;font-weight:bold">NULL</span>,
                                    kwcount, <span style="color:#ff0;font-weight:bold">2</span>,
                                    defs, defcount,
                                    kwdefs, closure,
                                    <span style="color:#fff;font-weight:bold">NULL</span>, <span style="color:#fff;font-weight:bold">NULL</span>);
}

</code></pre></div><p><code>_PyEval_EvalCode</code> 函数会对代码对象参数 <code>PyCodeObject *co</code> 及其参数进行常规检查，并初始化栈帧对象 <code>PyFrameObject *f</code>，并调用 <code>_PyEval_EvalFrame</code>：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#007f7f">// cpython/Python/ceval.c
</span><span style="color:#007f7f"></span>PyObject *
_PyEval_EvalCode(PyThreadState *tstate,
           PyObject *_co, PyObject *globals, PyObject *locals,
           PyObject *<span style="color:#fff;font-weight:bold">const</span> *args, Py_ssize_t argcount,
           PyObject *<span style="color:#fff;font-weight:bold">const</span> *kwnames, PyObject *<span style="color:#fff;font-weight:bold">const</span> *kwargs,
           Py_ssize_t kwcount, <span style="color:#fff;font-weight:bold">int</span> kwstep,
           PyObject *<span style="color:#fff;font-weight:bold">const</span> *defs, Py_ssize_t defcount,
           PyObject *kwdefs, PyObject *closure,
           PyObject *name, PyObject *qualname)
{
    PyObject *retval = <span style="color:#fff;font-weight:bold">NULL</span>;

    <span style="color:#007f7f">/* Create the frame */</span>
    PyFrameObject *f = _PyFrame_New_NoTrack(tstate, co, globals, locals);
    <span style="color:#fff;font-weight:bold">if</span> (f == <span style="color:#fff;font-weight:bold">NULL</span>) {
        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">NULL</span>;
    }
    PyObject **fastlocals = f-&gt;f_localsplus;
    PyObject **freevars = f-&gt;f_localsplus + co-&gt;co_nlocals;

    <span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span>
    retval = _PyEval_EvalFrame(tstate, f, <span style="color:#ff0;font-weight:bold">0</span>);

fail: <span style="color:#007f7f">/* Jump here from prelude on failure */</span>

    <span style="color:#007f7f">/* decref&#39;ing the frame can cause __del__ methods to get invoked,
</span><span style="color:#007f7f">       which can call back into Python.  While we&#39;re done with the
</span><span style="color:#007f7f">       current Python frame (f), the associated C stack is still in use,
</span><span style="color:#007f7f">       so recursion_depth must be boosted for the duration.
</span><span style="color:#007f7f">    */</span>
    <span style="color:#fff;font-weight:bold">if</span> (Py_REFCNT(f) &gt; <span style="color:#ff0;font-weight:bold">1</span>) {
        Py_DECREF(f);
        _PyObject_GC_TRACK(f);
    }
    <span style="color:#fff;font-weight:bold">else</span> {
        ++tstate-&gt;recursion_depth;
        Py_DECREF(f);
        --tstate-&gt;recursion_depth;
    }
    <span style="color:#fff;font-weight:bold">return</span> retval;
}
</code></pre></div><p><code>_PyEval_EvalFrame</code> 函数调用了一个函数指针，这个指针是随 Python 解释器初始化的：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#007f7f">// cpython/Python/internal/pycore_ceval.h
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">inline</span> PyObject*
_PyEval_EvalFrame(PyThreadState *tstate, PyFrameObject *f, <span style="color:#fff;font-weight:bold">int</span> throwflag)
{
    <span style="color:#fff;font-weight:bold">return</span> tstate-&gt;interp-&gt;eval_frame(tstate, f, throwflag);
}

<span style="color:#007f7f">// cpython/Python/pystate.c
</span><span style="color:#007f7f"></span>PyInterpreterState *
PyInterpreterState_New(<span style="color:#fff;font-weight:bold">void</span>)
{
    <span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span>    interp-&gt;eval_frame = _PyEval_EvalFrameDefault;
    <span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span>}
</code></pre></div><p><code>_PyEval_EvalFrameDefault</code> 是整个调用链的终点，它的函数主体是一个循环，不断地读入字节码，并通过 switch 语句判断其类型并执行，</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">
PyObject* _Py_HOT_FUNCTION
_PyEval_EvalFrameDefault(PyThreadState *tstate, PyFrameObject *f, <span style="color:#fff;font-weight:bold">int</span> throwflag)
{
    _Py_EnsureTstateNotNULL(tstate);
    <span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span>
main_loop:
    <span style="color:#fff;font-weight:bold">for</span> (;;) {
        opcode = _Py_OPCODE(*next_instr);

        <span style="color:#fff;font-weight:bold">switch</span> (opcode) {
        <span style="color:#fff;font-weight:bold">case</span> TARGET(LOAD_CONST): {
            PREDICTED(LOAD_CONST);
            PyObject *value = GETITEM(consts, oparg);
            Py_INCREF(value);
            PUSH(value);
            FAST_DISPATCH();

            <span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span>        }
        <span style="color:#007f7f">// ...
</span></code></pre></div><p>这就是整个调用和运行栈帧对象的过程了，整理如下：</p>
<p><img src="https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/python/py-eval.png" alt="py-eval"></p>
<h4 id="233-调试">2.3.3 调试</h4>
<p>最后以 [1.2](#1.2 字节码) 节的 test.py 代码为例，简单地用 gdb 来进行 <code>_PyEval_EvalFrameDefault</code> 函数中逐个字节码指令的调试：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ gdb -ex r --args python3 test.py
(gdb) b _PyEval_EvalFrameDefault
Breakpoint <span style="color:#ff0;font-weight:bold">1</span> at 0x41fa90: file Python/ceval.c, line 919.
(gdb) r
(gdb) n
<span style="color:#007f7f"># ...</span>
</code></pre></div><p>如果有对应版本的源码文件的话也可以直接断点在 <code>switch (opcode) {</code> 所在的行数，这里我们不断地往后执行直到这一行之后：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">(gdb) layout split

  <span style="color:#ff0;font-weight:bold">1487</span>            <span style="color:#fff;font-weight:bold">case</span> TARGET(LOAD_CONST): {
  <span style="color:#ff0;font-weight:bold">1488</span>                PREDICTED(LOAD_CONST);
&gt; <span style="color:#ff0;font-weight:bold">1489</span>                PyObject *value = GETITEM(consts, oparg);
  <span style="color:#ff0;font-weight:bold">1490</span>                Py_INCREF(value);
  <span style="color:#ff0;font-weight:bold">1491</span>                PUSH(value);
  <span style="color:#ff0;font-weight:bold">1492</span>                FAST_DISPATCH();
  <span style="color:#ff0;font-weight:bold">1493</span>            }

(gdb) p opcode
$1 = <span style="color:#ff0;font-weight:bold">100</span>
(gdb) p oparg
$2 = <span style="color:#ff0;font-weight:bold">0</span>
</code></pre></div><p>可以看到在执行 LOAD_CONST 助记符时，其对应的 opcode 的十六进制表示为64，十进制表示为 100，LOAD_CONST 首先获取了 oparg 的值，并填入到栈顶；</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">  <span style="color:#ff0;font-weight:bold">2343</span>            <span style="color:#fff;font-weight:bold">case</span> TARGET(STORE_NAME): {
&gt; <span style="color:#ff0;font-weight:bold">2344</span>                PyObject *name = GETITEM(names, oparg);
  <span style="color:#ff0;font-weight:bold">2345</span>                PyObject *v = POP();
  <span style="color:#ff0;font-weight:bold">2346</span>                PyObject *ns = f-&gt;f_locals;
  <span style="color:#ff0;font-weight:bold">2347</span>                int err;
  <span style="color:#ff0;font-weight:bold">2348</span>                <span style="color:#fff;font-weight:bold">if</span> (ns == NULL) {
  <span style="color:#ff0;font-weight:bold">2349</span>                    _PyErr_Format(tstate, PyExc_SystemError,
  <span style="color:#ff0;font-weight:bold">2350</span>                                  <span style="color:#0ff;font-weight:bold">&#34;no locals found when storing %R&#34;</span>, name);
  <span style="color:#ff0;font-weight:bold">2351</span>                    Py_DECREF(v);
  <span style="color:#ff0;font-weight:bold">2352</span>                    goto error;
  <span style="color:#ff0;font-weight:bold">2353</span>                }
  <span style="color:#ff0;font-weight:bold">2354</span>                <span style="color:#fff;font-weight:bold">if</span> (PyDict_CheckExact(ns))
  <span style="color:#ff0;font-weight:bold">2355</span>                    err = PyDict_SetItem(ns, name, v);
  <span style="color:#ff0;font-weight:bold">2356</span>                <span style="color:#fff;font-weight:bold">else</span>
  <span style="color:#ff0;font-weight:bold">2357</span>                    err = PyObject_SetItem(ns, name, v);
  <span style="color:#ff0;font-weight:bold">2358</span>                Py_DECREF(v);
  <span style="color:#ff0;font-weight:bold">2359</span>                <span style="color:#fff;font-weight:bold">if</span> (err != 0)
  <span style="color:#ff0;font-weight:bold">2360</span>                    goto error;
  <span style="color:#ff0;font-weight:bold">2361</span>                DISPATCH();
  <span style="color:#ff0;font-weight:bold">2362</span>            }
</code></pre></div><p>STORE_NAME 也是类似的，它从栈顶取出一个数值，并存储在局部命名空间中；</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">  <span style="color:#ff0;font-weight:bold">2828</span>            <span style="color:#fff;font-weight:bold">case</span> TARGET(BUILD_MAP): {
  <span style="color:#ff0;font-weight:bold">2829</span>                Py_ssize_t i;
&gt; <span style="color:#ff0;font-weight:bold">2830</span>                PyObject *map = _PyDict_NewPresized((Py_ssize_t)oparg);
  <span style="color:#ff0;font-weight:bold">2831</span>                <span style="color:#fff;font-weight:bold">if</span> (map == NULL)
  <span style="color:#ff0;font-weight:bold">2832</span>                    goto error;
  <span style="color:#ff0;font-weight:bold">2833</span>                <span style="color:#fff;font-weight:bold">for</span> (i = oparg; i &gt; 0; i--) {
  <span style="color:#ff0;font-weight:bold">2834</span>                    int err;
  <span style="color:#ff0;font-weight:bold">2835</span>                    PyObject *key = PEEK(2*i);
  <span style="color:#ff0;font-weight:bold">2836</span>                    PyObject *value = PEEK(2*i - 1);
  <span style="color:#ff0;font-weight:bold">2837</span>                    err = PyDict_SetItem(map, key, value);
  <span style="color:#ff0;font-weight:bold">2838</span>                    <span style="color:#fff;font-weight:bold">if</span> (err != 0) {
  <span style="color:#ff0;font-weight:bold">2839</span>                        Py_DECREF(map);
  <span style="color:#ff0;font-weight:bold">2840</span>                        goto error;
  <span style="color:#ff0;font-weight:bold">2841</span>                    }
  <span style="color:#ff0;font-weight:bold">2842</span>                }
  <span style="color:#ff0;font-weight:bold">2843</span>
  <span style="color:#ff0;font-weight:bold">2844</span>                <span style="color:#fff;font-weight:bold">while</span> (oparg--) {
  <span style="color:#ff0;font-weight:bold">2845</span>                    Py_DECREF(POP());
  <span style="color:#ff0;font-weight:bold">2846</span>                    Py_DECREF(POP());
  <span style="color:#ff0;font-weight:bold">2847</span>                }
  <span style="color:#ff0;font-weight:bold">2848</span>                PUSH(map);
  <span style="color:#ff0;font-weight:bold">2849</span>                DISPATCH();
  <span style="color:#ff0;font-weight:bold">2850</span>            }

(gdb) p opcode
$9 = <span style="color:#ff0;font-weight:bold">105</span>
(gdb) p oparg
$10 = <span style="color:#ff0;font-weight:bold">0</span>
</code></pre></div><p>BUILD_MAP 稍微复杂一些，它会构造一个 Python 中的字典对象（源码中 <code>PyDictObject</code> 结构体的实例对象，用哈希表实现），并不断地从栈帧上获取 key 和 value 插入到字典中；</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">  <span style="color:#ff0;font-weight:bold">2312</span>            <span style="color:#fff;font-weight:bold">case</span> TARGET(LOAD_BUILD_CLASS): {
  <span style="color:#ff0;font-weight:bold">2313</span>                _Py_IDENTIFIER(__build_class__);
  <span style="color:#ff0;font-weight:bold">2314</span>
&gt; <span style="color:#ff0;font-weight:bold">2315</span>                PyObject *bc;
  <span style="color:#ff0;font-weight:bold">2316</span>                <span style="color:#fff;font-weight:bold">if</span> (PyDict_CheckExact(f-&gt;f_builtins)) {
  <span style="color:#ff0;font-weight:bold">2317</span>                    bc = _PyDict_GetItemIdWithError(f-&gt;f_builtins, &amp;PyId___build_class__);
  <span style="color:#ff0;font-weight:bold">2318</span>                    <span style="color:#fff;font-weight:bold">if</span> (bc == NULL) {
  <span style="color:#ff0;font-weight:bold">2319</span>                        <span style="color:#fff;font-weight:bold">if</span> (!_PyErr_Occurred(tstate)) {
  <span style="color:#ff0;font-weight:bold">2320</span>                            _PyErr_SetString(tstate, PyExc_NameError,
  <span style="color:#ff0;font-weight:bold">2321</span>                                             <span style="color:#0ff;font-weight:bold">&#34;__build_class__ not found&#34;</span>);
  <span style="color:#ff0;font-weight:bold">2322</span>                        }
  <span style="color:#ff0;font-weight:bold">2323</span>                        goto error;
  <span style="color:#ff0;font-weight:bold">2324</span>                    }
  <span style="color:#ff0;font-weight:bold">2325</span>                    Py_INCREF(bc);
  <span style="color:#ff0;font-weight:bold">2326</span>                }
  <span style="color:#ff0;font-weight:bold">2327</span>                <span style="color:#fff;font-weight:bold">else</span> {
  <span style="color:#ff0;font-weight:bold">2328</span>                    PyObject *build_class_str = _PyUnicode_FromId(&amp;PyId___build_class__);
  <span style="color:#ff0;font-weight:bold">2329</span>                    <span style="color:#fff;font-weight:bold">if</span> (build_class_str == NULL)
  <span style="color:#ff0;font-weight:bold">2330</span>                        goto error;
  <span style="color:#ff0;font-weight:bold">2331</span>                    bc = PyObject_GetItem(f-&gt;f_builtins, build_class_str);
  <span style="color:#ff0;font-weight:bold">2332</span>                    <span style="color:#fff;font-weight:bold">if</span> (bc == NULL) {
  <span style="color:#ff0;font-weight:bold">2333</span>                        <span style="color:#fff;font-weight:bold">if</span> (_PyErr_ExceptionMatches(tstate, PyExc_KeyError))
  <span style="color:#ff0;font-weight:bold">2334</span>                            _PyErr_SetString(tstate, PyExc_NameError,
  <span style="color:#ff0;font-weight:bold">2335</span>                                             <span style="color:#0ff;font-weight:bold">&#34;__build_class__ not found&#34;</span>);
  <span style="color:#ff0;font-weight:bold">2336</span>                        goto error;
  <span style="color:#ff0;font-weight:bold">2337</span>                    }
  <span style="color:#ff0;font-weight:bold">2338</span>                }
  <span style="color:#ff0;font-weight:bold">2339</span>                PUSH(bc);
  <span style="color:#ff0;font-weight:bold">2340</span>                DISPATCH();
  <span style="color:#ff0;font-weight:bold">2341</span>            }
(gdb) p opcode
$11 = <span style="color:#ff0;font-weight:bold">71</span>
(gdb) p oparg
$12 = <span style="color:#ff0;font-weight:bold">0</span>
</code></pre></div><p>LOAD_BUILD_CLASS 则会从内置命名空间中通过哈希方法找到函数指针，并插入栈顶；</p>
<p>其他的字节码指令还有很多，都可以通过阅读源码或者使用 gdb 调试的方法找到其实际执行的代码；相比于汇编指令，字节码指令实际上代表了由许多行代码组成的功能，而 Python 虚拟机则是通过字节码指令模拟出了对汇编指令的执行过程。</p>

      </div>

      <footer>
        


        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "zintrulcre" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </footer>
    </article>

    
  </section>

      </div>

      <footer class="footer">
  <section class="container">
    
    
    
    
      
      <a href="https://github.com/luizdepra/hugo-coder/tree/"></a>
    
  </section>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
    </main>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-132809676-1', 'auto');
	
	ga('send', 'pageview');
}
</script>


  </body>

</html>
