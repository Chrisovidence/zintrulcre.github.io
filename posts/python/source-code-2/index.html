<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Python 源码学习（2）：int 类型 | 尾張</title>
<meta name=keywords content>
<meta name=description content="Python 源码学习（2）：int 类型 Python 中的标准数据类型有六种，分别是 number, string, list, tuple, set, dictionary，前文已经阐述过它们的对象类型都是继承了 PyBaseObject_Type 类型的 PyType_Type 类型的实例对象，本文则主要探究 Python 中 int 类型的实现。
不同于 C 和 C++ 中的 int 类型，Python 中的 int 类型最大的特点是它一般是不会溢出的，对比用 C 和 Python 分别输出两个一百万相乘的结果：
>>> x = 10000000000 >>> print(x) 10000000000 在 C 语言中会发生溢出：
printf(&#34;%d\n&#34;, 1000000 * 1000000); printf(&#34;%u\n&#34;, 1000000 * 1000000); -727379968 3567587328 1 int 类型在内存中的存储方式 1.1 内存结构 Python 中的 int 整数类型实际上是一个名为 PyLongObject 的结构体，定义在 longintrepr.h 文件中：
// Include/object.h #define PyObject_VAR_HEAD PyVarObject ob_base;  // Objects/longobject.">
<meta name=author content="Zhengyu">
<link rel=canonical href=http://zintrulcre.github.io/posts/python/source-code-2/>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.91.2">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-132809676-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="Python 源码学习（2）：int 类型">
<meta property="og:description" content="Python 源码学习（2）：int 类型 Python 中的标准数据类型有六种，分别是 number, string, list, tuple, set, dictionary，前文已经阐述过它们的对象类型都是继承了 PyBaseObject_Type 类型的 PyType_Type 类型的实例对象，本文则主要探究 Python 中 int 类型的实现。
不同于 C 和 C++ 中的 int 类型，Python 中的 int 类型最大的特点是它一般是不会溢出的，对比用 C 和 Python 分别输出两个一百万相乘的结果：
>>> x = 10000000000 >>> print(x) 10000000000 在 C 语言中会发生溢出：
printf(&#34;%d\n&#34;, 1000000 * 1000000); printf(&#34;%u\n&#34;, 1000000 * 1000000); -727379968 3567587328 1 int 类型在内存中的存储方式 1.1 内存结构 Python 中的 int 整数类型实际上是一个名为 PyLongObject 的结构体，定义在 longintrepr.h 文件中：
// Include/object.h #define PyObject_VAR_HEAD PyVarObject ob_base;  // Objects/longobject.">
<meta property="og:type" content="article">
<meta property="og:url" content="http://zintrulcre.github.io/posts/python/source-code-2/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-03-31T15:37:52+08:00">
<meta property="article:modified_time" content="2021-03-31T15:37:52+08:00"><meta property="og:site_name" content="尾張">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Python 源码学习（2）：int 类型">
<meta name=twitter:description content="Python 源码学习（2）：int 类型 Python 中的标准数据类型有六种，分别是 number, string, list, tuple, set, dictionary，前文已经阐述过它们的对象类型都是继承了 PyBaseObject_Type 类型的 PyType_Type 类型的实例对象，本文则主要探究 Python 中 int 类型的实现。
不同于 C 和 C++ 中的 int 类型，Python 中的 int 类型最大的特点是它一般是不会溢出的，对比用 C 和 Python 分别输出两个一百万相乘的结果：
>>> x = 10000000000 >>> print(x) 10000000000 在 C 语言中会发生溢出：
printf(&#34;%d\n&#34;, 1000000 * 1000000); printf(&#34;%u\n&#34;, 1000000 * 1000000); -727379968 3567587328 1 int 类型在内存中的存储方式 1.1 内存结构 Python 中的 int 整数类型实际上是一个名为 PyLongObject 的结构体，定义在 longintrepr.h 文件中：
// Include/object.h #define PyObject_VAR_HEAD PyVarObject ob_base;  // Objects/longobject.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://zintrulcre.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Python 源码学习（2）：int 类型","item":"http://zintrulcre.github.io/posts/python/source-code-2/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python 源码学习（2）：int 类型","name":"Python 源码学习（2）：int 类型","description":"Python 源码学习（2）：int 类型 Python 中的标准数据类型有六种，分别是 number, string, list, tuple, set, dictionary，前文已经阐述过它们的对象类型都是继承了 PyBaseObject_Type 类型的 PyType_Type 类型的实例对象，本文则主要探究 Python 中 int 类型的实现。\n不同于 C 和 C++ 中的 int 类型，Python 中的 int 类型最大的特点是它一般是不会溢出的，对比用 C 和 Python 分别输出两个一百万相乘的结果：\n\u0026gt;\u0026gt;\u0026gt; x = 10000000000 \u0026gt;\u0026gt;\u0026gt; print(x) 10000000000 在 C 语言中会发生溢出：\nprintf(\u0026#34;%d\\n\u0026#34;, 1000000 * 1000000); printf(\u0026#34;%u\\n\u0026#34;, 1000000 * 1000000); -727379968 3567587328 1 int 类型在内存中的存储方式 1.1 内存结构 Python 中的 int 整数类型实际上是一个名为 PyLongObject 的结构体，定义在 longintrepr.h 文件中：\n// Include/object.h #define PyObject_VAR_HEAD PyVarObject ob_base;  // Objects/longobject.","keywords":[],"articleBody":"Python 源码学习（2）：int 类型 Python 中的标准数据类型有六种，分别是 number, string, list, tuple, set, dictionary，前文已经阐述过它们的对象类型都是继承了 PyBaseObject_Type 类型的 PyType_Type 类型的实例对象，本文则主要探究 Python 中 int 类型的实现。\n不同于 C 和 C++ 中的 int 类型，Python 中的 int 类型最大的特点是它一般是不会溢出的，对比用 C 和 Python 分别输出两个一百万相乘的结果：\n x = 10000000000  print(x) 10000000000 在 C 语言中会发生溢出：\nprintf(\"%d\\n\", 1000000 * 1000000); printf(\"%u\\n\", 1000000 * 1000000); -727379968 3567587328 1 int 类型在内存中的存储方式 1.1 内存结构 Python 中的 int 整数类型实际上是一个名为 PyLongObject 的结构体，定义在 longintrepr.h 文件中：\n// Include/object.h #define PyObject_VAR_HEAD PyVarObject ob_base;  // Objects/longobject.h #if PYLONG_BITS_IN_DIGIT == 30 typedef uint32_t digit; // ... #elif PYLONG_BITS_IN_DIGIT == 15 typedef unsigned short digit; // ... #endif typedef struct _longobject PyLongObject; /* Revealed in longintrepr.h */ // Include/longintrepr.h struct _longobject { PyObject_VAR_HEAD digit ob_digit[1]; }; 它由两部分组成，分别是：\n  一个变长对象 PyVarObject ob_base，其中包括引用计数 Py_ssize_t ob_refcnt、类型指针 PyTypeObject *ob_type、变长部分的长度 Py_ssize_t ob_size，表明 PyLongObject 也是一个变长对象；\n  一个 digit 类型的数组 ob_digit ，用于存储整数值，数组长度默认为 1，在初始化时如果长度不够则会被扩大； digit 是一个被 PYLONG_BITS_IN_DIGIT  宏控制的类型，在编译 Python 解释器时可以通过修改这个宏来指定其类型；如果没有指定 PYLONG_BITS_IN_DIGIT  宏的值，则默认会根据操作系统的类型来决定，当指针占用 8 字节以上空间时（64 位以上操作系统），PYLONG_BITS_IN_DIGIT = 30，digit 即为 uint32_t，否则 PYLONG_BITS_IN_DIGIT = 15，digit 则是 unsigned short：\n  #ifndef PYLONG_BITS_IN_DIGIT #if SIZEOF_VOID_P = 8 #define PYLONG_BITS_IN_DIGIT 30 #else #define PYLONG_BITS_IN_DIGIT 15 #endif #endif\n `PyLongObject` 的内存结构大致如图： ![PyLongObject](https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/python/PyLongObject.png) ### 1.2 数据表示 在 `ob_digit` 数组中，数据的表示遵循两个原则： 1. `ob_size` 的绝对值表示 `ob_digit` 数组的长度，`ob_size = 0` 表示 `PyLongObject` 的数值等于 0；数据的正负由 `ob_size` 的正负来标识，`ob_size  0` 表示 `PyLongObject  0`，`ob_size (Py_ssize_t)MAX_LONG_DIGITS) { PyErr_SetString(PyExc_OverflowError, \"too many digits in integer\"); return NULL; } result = PyObject_MALLOC(offsetof(PyLongObject, ob_digit) + size*sizeof(digit)); if (!result) { PyErr_NoMemory(); return NULL; } _PyObject_InitVar((PyVarObject*)result, \u0026PyLong_Type, size); return result; } 这个函数非常简单，主要是做了两件事：\n 内存分配前后的检查，包括参数 size 不能超过 MAX_LONG_DIGITS，也就是说 PyLongObject 所表示的整数大小不能超过 2^(30*2147483648) - 1，以及生成使用 malloc 分配内存失败后的报错信息； 为 PyLongObject 对象申请内存，其大小分为两部分，第一部分是 PyVarObject 在内存对齐后所占用的空间，即 offsetof(PyLongObject, ob_digit)；第二部分是 ob_digit 数组所占用的空间，其中参数 size 是 ob_digit 数组的长度。  1.4 数据转化 每一个 PyLongObject 对象都拥有不同的内存地址，我们可以通过 Python 中的 id 函数来查看一个变量的标识，这个标识会因内存地址的不同而改变：\nfor i in range(5): print(id(i)) $ python3 main.py 139748219328384 139748219328416 139748219328448 139748219328480 139748219328512 可以看出 0 到 4 这 5 个数的标识里每两个都相差了 32，刚好符合每一个 PyLongObject 对象所占用的空间 32 字节，而不是 C 语言里一个 long 类型变量通常所占用的 4 字节或 8 字节，这是因为所有原始的数据都会被转化为 PyLongObject 对象。\n数据转化的方法有很多，以 PyLong_FromLong 为例，它会将一个 long 类型的整数转化为 PyLongObject 对象：\n// Objects/longobject.c /* interpreter state */ #define _PY_NSMALLPOSINTS 257 #define _PY_NSMALLNEGINTS 5  #define NSMALLNEGINTS _PY_NSMALLNEGINTS #define NSMALLPOSINTS _PY_NSMALLPOSINTS  #define IS_SMALL_INT(ival) (-NSMALLNEGINTS  PyObject * PyLong_FromLong(long ival) { PyLongObject *v; unsigned long abs_ival; unsigned long t; /* unsigned so  doesn't propagate sign bit */ int ndigits = 0; int sign; if (IS_SMALL_INT(ival)) { return get_small_int((sdigit)ival); } if (ival  0) { /* negate: can't write this as abs_ival = -ival since that invokes undefined behaviour when ival is LONG_MIN */ abs_ival = 0U-(unsigned long)ival; sign = -1; } else { abs_ival = (unsigned long)ival; sign = ival == 0 ? 0 : 1; } /* Fast path for single-digit ints */ if (!(abs_ival  PyLong_SHIFT)) { v = _PyLong_New(1); if (v) { Py_SET_SIZE(v, sign); v-ob_digit[0] = Py_SAFE_DOWNCAST( abs_ival, unsigned long, digit); } return (PyObject*)v; } #if PyLong_SHIFT==15  /* 2 digits */ if (!(abs_ival  2*PyLong_SHIFT)) { v = _PyLong_New(2); if (v) { Py_SET_SIZE(v, 2 * sign); v-ob_digit[0] = Py_SAFE_DOWNCAST( abs_ival \u0026 PyLong_MASK, unsigned long, digit); v-ob_digit[1] = Py_SAFE_DOWNCAST( abs_ival  PyLong_SHIFT, unsigned long, digit); } return (PyObject*)v; } #endif  /* Larger numbers: loop to determine number of digits */ t = abs_ival; while (t) { ++ndigits; t = PyLong_SHIFT; } v = _PyLong_New(ndigits); if (v != NULL) { digit *p = v-ob_digit; Py_SET_SIZE(v, ndigits * sign); t = abs_ival; while (t) { *p++ = Py_SAFE_DOWNCAST( t \u0026 PyLong_MASK, unsigned long, digit); t = PyLong_SHIFT; } } return (PyObject *)v; } 虽然看起来比较长，但其实思路非常简单：\n 创建用于存储返回值的指针 PyLongObject *z，保存数据绝对值的变量 unsigned long abs_ival, t，标识数组长度的 int ndigits 和标识数据正负的 int sign； 如果数据范围在 [-5, 257) 内，则通过 get_small_int 函数返回结果； 获取数据的绝对值和正负符号； 如果数据绝对值没有超过 ob_digit 数组的单个元素所能表示的大小，则通过一个快速路径返回结果； 对于较大的数据，确定其 ob_digit 数组的长度，逐位置入。  可以注意到，第 2 步针对 [-5, 257) 区间内的小整数做了特殊处理，最终在调用到 __PyLong_GetSmallInt_internal 函数时，会通过 tstate-interp-small_ints[index] 缓存数组获取小整数对应的指针对象并将其返回，这里的 small_ints 数组是一个全局变量，一般称为小整数对象池，是针对常用的小整数做的一个优化：\n// Objects/longobject.c static inline PyObject* __PyLong_GetSmallInt_internal(int value) { PyThreadState *tstate = _PyThreadState_GET(); #ifdef Py_DEBUG  _Py_EnsureTstateNotNULL(tstate); #endif  assert(-_PY_NSMALLNEGINTS  value \u0026\u0026 value  _PY_NSMALLPOSINTS); size_t index = _PY_NSMALLNEGINTS + value; PyObject *obj = (PyObject*)tstate-interp-small_ints[index]; // _PyLong_GetZero() and _PyLong_GetOne() must not be called  // before _PyLong_Init() nor after _PyLong_Fini()  assert(obj != NULL); return obj; } 2 数学运算 PyLongObject 的类型对象是 PyLong_Type，PyLong_Type 的成员变量 PyNumberMethods *tp_as_number 由 static PyNumberMethods long_as_number* 结构体指针初始化，其中包含了许多数学运算的函数指针，当我们对 PyLong_Type 进行数学运算时，实际上会调用这些函数：\n// Objects/longobject.c PyTypeObject PyLong_Type = { // ...  \u0026long_as_number, /* tp_as_number */ // ... }; static PyNumberMethods long_as_number = { (binaryfunc)long_add, /*nb_add*/ (binaryfunc)long_sub, /*nb_subtract*/ (binaryfunc)long_mul, /*nb_multiply*/ long_mod, /*nb_remainder*/ long_divmod, /*nb_divmod*/ long_pow, /*nb_power*/ // ... }; 2.1 加法 PyLong_Type 的加法运算对应的函数是 long_add，其实现和相关的宏定义如下：\n// Objects/longobject.c #define CHECK_BINOP(v,w) \\ do { \\ if (!PyLong_Check(v) || !PyLong_Check(w)) \\ Py_RETURN_NOTIMPLEMENTED; \\ } while(0)  /* convert a PyLong of size 1, 0 or -1 to an sdigit */ #define MEDIUM_VALUE(x) (assert(-1 Py_SIZE(x) ob_digit[0] : \\ (Py_SIZE(x) == 0 ? (sdigit)0 : \\ (sdigit)(x)-ob_digit[0]))  static PyObject * long_add(PyLongObject *a, PyLongObject *b) { PyLongObject *z; CHECK_BINOP(a, b); if (Py_ABS(Py_SIZE(a))  1 \u0026\u0026 Py_ABS(Py_SIZE(b))  1) { return PyLong_FromLong(MEDIUM_VALUE(a) + MEDIUM_VALUE(b)); } if (Py_SIZE(a)  0) { if (Py_SIZE(b)  0) { z = x_add(a, b); if (z != NULL) { /* x_add received at least one multiple-digit int, and thus z must be a multiple-digit int. That also means z is not an element of small_ints, so negating it in-place is safe. */ assert(Py_REFCNT(z) == 1); Py_SET_SIZE(z, -(Py_SIZE(z))); } } else z = x_sub(b, a); } else { if (Py_SIZE(b)  0) z = x_sub(a, b); else z = x_add(a, b); } return (PyObject *)z; } 可以看到它的实现非常简单，主要分为以下几个步骤：\n 创建一个用于存储返回值的指针 PyLongObject *z； 检查两个参数是否都是 PyLongObject 类型的指针 CHECK_BINOP(a, b)； 如果两个参数都满足 ob_size （即绝对值均小于 2^30），那么先通过 MEDIUM_VALUE 获取两个 ob_digit[0] 的值，并将两数直接相加（一定不会溢出），再通过 PyLong_FromLong 将这个数包装为一个 PyLongObject 指针并返回；通常我们进行运算的数都不会太大，因此这里可以利用简化的运算步骤和 CPU 分支预测来提高效率； 判断两者的正负关系，将问题简化为绝对值加减法，利用辅助函数 x_add 和 x_sub 进行运算并返回结果。  2.2 绝对值加法 绝对值加法函数 x_add 的定义如下：\n#if PYLONG_BITS_IN_DIGIT == 30 #define PyLong_SHIFT 30 // ... #endif #define PyLong_BASE ((digit)1 #define PyLong_MASK ((digit)(PyLong_BASE - 1))  /* Add the absolute values of two integers. */ static PyLongObject * x_add(PyLongObject *a, PyLongObject *b) { Py_ssize_t size_a = Py_ABS(Py_SIZE(a)), size_b = Py_ABS(Py_SIZE(b)); PyLongObject *z; Py_ssize_t i; digit carry = 0; /* Ensure a is the larger of the two: */ if (size_a  size_b) { { PyLongObject *temp = a; a = b; b = temp; } { Py_ssize_t size_temp = size_a; size_a = size_b; size_b = size_temp; } } z = _PyLong_New(size_a+1); if (z == NULL) return NULL; for (i = 0; i  size_b; ++i) { carry += a-ob_digit[i] + b-ob_digit[i]; z-ob_digit[i] = carry \u0026 PyLong_MASK; carry = PyLong_SHIFT; } for (; i  size_a; ++i) { carry += a-ob_digit[i]; z-ob_digit[i] = carry \u0026 PyLong_MASK; carry = PyLong_SHIFT; } z-ob_digit[i] = carry; return long_normalize(z); } 其步骤大致分为以下几步：\n 获取两个参数的 ob_size 的绝对值，创建存储返回值的指针 PyLongObject *z， 如果 a-ob_size ob_size 则交换两者，保证 a 的值较大； 将 z 的 ob_size 设置为 size_a + 1，保证不会溢出； 以 i = 0 为下标，从小到大依次对两数的每一位进行相加操作，将没有超过 2^30 的部分存储在 z-ob_digit[i] 中，超过的部分进位保存在 carry 中；这里充分利用了两个小于 2^30 的数相加不会溢出的特性；如果 size_a  size_b 还需要将 a-ob_digit 多余的部分按照相同的方法置入 z-ob_digit里； 得到的结果 z 中，其 ob_digit 的最后一个元素可能等于 0，因此通过 long_normalize 函数将其转换为符合 PyLongObject 定义的格式返回。  整个过程可以抽象为类似 2^30 进制的加法，和十进制加法的过程几乎完全一样，只不过是把十进制每一位的数字换成了一个最大值为 2^30 的数字，每逢 2^30 进一位；举个例，假设有 a-ob_digit = {4, 5, 6}, b-ob_digit = {1073741823, 1073741823}，那么整个加法的步骤为：\n v-ob_digit[0] = (4 + 1073741823) % 1073741824 = 3, carry = 1； v-ob_digit[1] = (5 + 1073741823 + 1) % 1073741824 = 5, carry = 1； v-ob_digit[2] = (6 + 1) % 1073741824 = 7, carry = 0； v-ob_digit[3] = 0；  结果即 v-ob_digit = {3, 5, 7, 0}，最后一个元素 0 需要通过 long_normalize 函数去掉。\n2.3 绝对值减法 绝对值减法的实现如下：\n/* Subtract the absolute values of two integers. */ static PyLongObject * x_sub(PyLongObject *a, PyLongObject *b) { Py_ssize_t size_a = Py_ABS(Py_SIZE(a)), size_b = Py_ABS(Py_SIZE(b)); PyLongObject *z; Py_ssize_t i; int sign = 1; digit borrow = 0; /* Ensure a is the larger of the two: */ if (size_a  size_b) { sign = -1; { PyLongObject *temp = a; a = b; b = temp; } { Py_ssize_t size_temp = size_a; size_a = size_b; size_b = size_temp; } } else if (size_a == size_b) { /* Find highest digit where a and b differ: */ i = size_a; while (--i = 0 \u0026\u0026 a-ob_digit[i] == b-ob_digit[i]) ; if (i  0) return (PyLongObject *)PyLong_FromLong(0); if (a-ob_digit[i]  b-ob_digit[i]) { sign = -1; { PyLongObject *temp = a; a = b; b = temp; } } size_a = size_b = i+1; } z = _PyLong_New(size_a); if (z == NULL) return NULL; for (i = 0; i  size_b; ++i) { /* The following assumes unsigned arithmetic works module 2**N for some NPyLong_SHIFT. */ borrow = a-ob_digit[i] - b-ob_digit[i] - borrow; z-ob_digit[i] = borrow \u0026 PyLong_MASK; borrow = PyLong_SHIFT; borrow \u0026= 1; /* Keep only one sign bit */ } for (; i  size_a; ++i) { borrow = a-ob_digit[i] - borrow; z-ob_digit[i] = borrow \u0026 PyLong_MASK; borrow = PyLong_SHIFT; borrow \u0026= 1; /* Keep only one sign bit */ } assert(borrow == 0); if (sign  0) { Py_SET_SIZE(z, -Py_SIZE(z)); } return maybe_small_long(long_normalize(z)); } 其步骤和绝对值加法类似，大致分为以下几步：\n 获取两个参数的 ob_size 的绝对值，创建存储返回值的指针 PyLongObject *z， 如果 a-ob_size ob_size 则交换两者，保证 a 的值较大，并用 sign 记录运算结果为负；如果 a-ob_size == b-ob_size 则从最高位依次往低位找到第一次出现 a-ob_digit[i] != b-ob_digit[i] 的位置，比较 a-ob_digit[i] 和 b-ob_digit[i]，并决定是否交换两者以及 sign 的值； 将 z 的 ob_size 设置为 size_a； 以 i = 0 为下标，从小到大依次对两数的每一位进行相减操作，如果被减数 a-ob_digit[i] 小于减数 b-ob_digit[i] 则要向高位 a-ob_digit[i + 1] 借 1；在十进制的减法中向高位借到的数是 10，这里向 digit 数组的高位借到的则是 2^30；但 digit 是通过 typedef uint32_t digit 定义出来，通过公式 borrow = a-ob_digit[i] - b-ob_digit[i] - borrow 实际上得到的是 2^32 + a-ob_digit[i] - b-ob_digit[i]，所以还需要与 PyLong_MASK 做 \u0026 操作，取后 30 位，便能得到借位相减后的结果，再将结果存储在 z-ob_digit[i] 中；借位部分 borrow 向右位移 30 位后还剩 2 位，只需要将其与 1 进行 \u0026 操作即可知道此次减法运算是否有借位；如果 size_a  size_b 还需要将 a-ob_digit 多余的部分按照相同的方法置入 z-ob_digit里； 得到的结果 z 中，其 ob_digit 的最后一个元素可能等于 0，因此通过 long_normalize 函数将其转换为符合 PyLongObject 定义的格式返回。  可以看到这里的步骤也跟十进制减法几乎完全相同，都跟 NOIP 入门的大数加减法加法思路相同。\n","wordCount":"1668","inLanguage":"en","datePublished":"2021-03-31T15:37:52+08:00","dateModified":"2021-03-31T15:37:52+08:00","author":{"@type":"Person","name":"Zhengyu"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://zintrulcre.github.io/posts/python/source-code-2/"},"publisher":{"@type":"Organization","name":"尾張","logo":{"@type":"ImageObject","url":"http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://zintrulcre.github.io/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=http://zintrulcre.github.io/archives/ title=Posts>
<span>Posts</span>
</a>
</li>
<li>
<a href=http://zintrulcre.github.io/about/ title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=http://zintrulcre.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://zintrulcre.github.io/posts/>Posts</a></div>
<h1 class=post-title>
Python 源码学习（2）：int 类型
</h1>
<div class=post-meta><span title="2021-03-31 15:37:52 +0800 CST">March 31, 2021</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Zhengyu&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/python/source-code-2.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header> <div class=toc>
<details open>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#python-%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a02int-%e7%b1%bb%e5%9e%8b aria-label="Python 源码学习（2）：int 类型">Python 源码学习（2）：int 类型</a><ul>
<li>
<a href=#1-int-%e7%b1%bb%e5%9e%8b%e5%9c%a8%e5%86%85%e5%ad%98%e4%b8%ad%e7%9a%84%e5%ad%98%e5%82%a8%e6%96%b9%e5%bc%8f aria-label="1 int 类型在内存中的存储方式">1 int 类型在内存中的存储方式</a><ul>
<li>
<a href=#11-%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84 aria-label="1.1 内存结构">1.1 内存结构</a></li>
<li>
<a href=#14-%e6%95%b0%e6%8d%ae%e8%bd%ac%e5%8c%96 aria-label="1.4 数据转化">1.4 数据转化</a></li></ul>
</li>
<li>
<a href=#2-%e6%95%b0%e5%ad%a6%e8%bf%90%e7%ae%97 aria-label="2 数学运算">2 数学运算</a><ul>
<li>
<a href=#21-%e5%8a%a0%e6%b3%95 aria-label="2.1 加法">2.1 加法</a></li>
<li>
<a href=#22-%e7%bb%9d%e5%af%b9%e5%80%bc%e5%8a%a0%e6%b3%95 aria-label="2.2 绝对值加法">2.2 绝对值加法</a></li>
<li>
<a href=#23-%e7%bb%9d%e5%af%b9%e5%80%bc%e5%87%8f%e6%b3%95 aria-label="2.3 绝对值减法">2.3 绝对值减法</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h1 id=python-源码学习2int-类型>Python 源码学习（2）：int 类型<a hidden class=anchor aria-hidden=true href=#python-源码学习2int-类型>#</a></h1>
<p>Python 中的标准数据类型有六种，分别是 number, string, list, tuple, set, dictionary，前文已经阐述过它们的对象类型都是继承了 <code>PyBaseObject_Type</code> 类型的 <code>PyType_Type</code> 类型的实例对象，本文则主要探究 Python 中 int 类型的实现。</p>
<p>不同于 C 和 C++ 中的 <code>int</code> 类型，Python 中的 <code>int</code> 类型最大的特点是它一般是<strong>不会溢出</strong>的，对比用 C 和 Python 分别输出两个一百万相乘的结果：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>&gt;&gt;&gt;</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>10000000000</span>
<span style=color:#f92672>&gt;&gt;&gt;</span> print(x)
<span style=color:#ae81ff>10000000000</span>
</code></pre></div><p>在 C 语言中会发生溢出：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++>printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#ae81ff>1000000</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1000000</span>);
printf(<span style=color:#e6db74>&#34;%u</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#ae81ff>1000000</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1000000</span>);
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>-727379968
<span style=color:#ae81ff>3567587328</span>
</code></pre></div><h2 id=1-int-类型在内存中的存储方式>1 int 类型在内存中的存储方式<a hidden class=anchor aria-hidden=true href=#1-int-类型在内存中的存储方式>#</a></h2>
<h3 id=11-内存结构>1.1 内存结构<a hidden class=anchor aria-hidden=true href=#11-内存结构>#</a></h3>
<p>Python 中的 <code>int</code> 整数类型实际上是一个名为 <code>PyLongObject</code> 的结构体，定义在 <code>longintrepr.h</code> 文件中：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// Include/object.h
</span><span style=color:#75715e></span><span style=color:#75715e>#define PyObject_VAR_HEAD      PyVarObject ob_base;
</span><span style=color:#75715e></span>
<span style=color:#75715e>// Objects/longobject.h
</span><span style=color:#75715e></span><span style=color:#75715e>#if PYLONG_BITS_IN_DIGIT == 30
</span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>uint32_t</span> digit;
<span style=color:#75715e>// ...
</span><span style=color:#75715e></span><span style=color:#75715e>#elif PYLONG_BITS_IN_DIGIT == 15
</span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>short</span> digit;
<span style=color:#75715e>// ...
</span><span style=color:#75715e></span><span style=color:#75715e>#endif
</span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>_longobject</span> PyLongObject; <span style=color:#75715e>/* Revealed in longintrepr.h */</span>

<span style=color:#75715e>// Include/longintrepr.h
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>_longobject</span> {
    PyObject_VAR_HEAD
    digit ob_digit[<span style=color:#ae81ff>1</span>];
};
</code></pre></div><p>它由两部分组成，分别是：</p>
<ol>
<li>
<p>一个变长对象 <code>PyVarObject ob_base</code>，其中包括引用计数 <code>Py_ssize_t ob_refcnt</code>、类型指针 <code>PyTypeObject *ob_type</code>、变长部分的长度 <code>Py_ssize_t ob_size</code>，表明 <code>PyLongObject</code> 也是一个<strong>变长对象</strong>；</p>
</li>
<li>
<p>一个 <code>digit</code> 类型的数组 <code>ob_digit</code> ，用于存储整数值，数组长度默认为 1，在初始化时如果长度不够则会被扩大； <code>digit</code> 是一个被 <code>PYLONG_BITS_IN_DIGIT </code> 宏控制的类型，在编译 Python 解释器时可以通过修改这个宏来指定其类型；如果没有指定 <code>PYLONG_BITS_IN_DIGIT </code> 宏的值，则默认会根据操作系统的类型来决定，当指针占用 8 字节以上空间时（64 位以上操作系统），<code>PYLONG_BITS_IN_DIGIT = 30</code>，<code>digit</code> 即为 <code>uint32_t</code>，否则 <code>PYLONG_BITS_IN_DIGIT = 15</code>，<code>digit</code> 则是 <code>unsigned short</code>：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp></code></pre></div></li>
</ol>
<p>#ifndef PYLONG_BITS_IN_DIGIT
#if SIZEOF_VOID_P >= 8
#define PYLONG_BITS_IN_DIGIT 30
#else
#define PYLONG_BITS_IN_DIGIT 15
#endif
#endif</p>
<pre tabindex=0><code>
`PyLongObject` 的内存结构大致如图：

![PyLongObject](https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/python/PyLongObject.png)

### 1.2 数据表示

在 `ob_digit` 数组中，数据的表示遵循两个原则：

1. `ob_size` 的绝对值表示 `ob_digit` 数组的长度，`ob_size = 0` 表示 `PyLongObject` 的数值等于 0；数据的正负由 `ob_size` 的正负来标识，`ob_size &gt; 0` 表示 `PyLongObject &gt; 0`，`ob_size &lt; 0` 表示 `PyLongObject &lt; 0`；
2. `ob_digit` 数组的每一个元素都是一个最大为 `2^30`（假设 `PYLONG_BITS_IN_DIGIT == 30`）的整数，如果整数超过了这个值，则会清零并使其后一位自增 1，假设 `ob_size = n`，那么数据的绝对值则等于 `ob_digit[0] + ob_digit[1] * 2^30 + ob_digit[2] * 2^60 + ... + ob_digit[n-1] * 2^(30 * (n-1))`；

例如对于整数 4294967297，可以被表示为 `1 + 4 * 2^30`，因此其 `ob_size = 2`, `ob_digit[0] = 1`, `ob_digit[1] = 4`，其内存结构大致如图：

![PyLongObject-1](https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/python/PyLongObject-1.png)

通过这种大数存储方式，Python 从语言层面解决了 `2^(30*2147483648) - 1` 以下（`ob_size` 的类型 `Py_ssize_t` 是通过 `typedef long int Py_ssize_t` 定义的）的大数的溢出问题。

### 1.3 创建对象

在 Python 中， `PyLongObject` 对象一般是通过 `_PyLong_New` 函数创建出来的：

```cpp
/* Allocate a new int object with size digits.
Return NULL and set exception if we run out of memory. */

#define MAX_LONG_DIGITS \
 ((PY_SSIZE_T_MAX - offsetof(PyLongObject, ob_digit))/sizeof(digit))

PyLongObject *
_PyLong_New(Py_ssize_t size)
{
 PyLongObject *result;
 /* Number of bytes needed is: offsetof(PyLongObject, ob_digit) +
    sizeof(digit)*size.  Previous incarnations of this code used
    sizeof(PyVarObject) instead of the offsetof, but this risks being
    incorrect in the presence of padding between the PyVarObject header
    and the digits. */
 if (size &gt; (Py_ssize_t)MAX_LONG_DIGITS) {
     PyErr_SetString(PyExc_OverflowError,
                     &quot;too many digits in integer&quot;);
     return NULL;
 }
 result = PyObject_MALLOC(offsetof(PyLongObject, ob_digit) +
                          size*sizeof(digit));
 if (!result) {
     PyErr_NoMemory();
     return NULL;
 }
 _PyObject_InitVar((PyVarObject*)result, &amp;PyLong_Type, size);
 return result;
}
</code></pre><p>这个函数非常简单，主要是做了两件事：</p>
<ol>
<li>内存分配前后的检查，包括参数 <code>size</code> 不能超过 <code>MAX_LONG_DIGITS</code>，也就是说 <code>PyLongObject</code> 所表示的整数大小不能超过 <code>2^(30*2147483648) - 1</code>，以及生成使用 <code>malloc</code> 分配内存失败后的报错信息；</li>
<li>为 <code>PyLongObject</code> 对象申请内存，其大小分为两部分，第一部分是 <code>PyVarObject</code> 在内存对齐后所占用的空间，即 <code>offsetof(PyLongObject, ob_digit)</code>；第二部分是 <code>ob_digit</code> 数组所占用的空间，其中参数 <code>size</code> 是 <code>ob_digit</code> 数组的长度。</li>
</ol>
<h3 id=14-数据转化>1.4 数据转化<a hidden class=anchor aria-hidden=true href=#14-数据转化>#</a></h3>
<p>每一个 <code>PyLongObject</code> 对象都拥有不同的内存地址，我们可以通过 Python 中的 <code>id</code> 函数来查看一个变量的标识，这个标识会因内存地址的不同而改变：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>5</span>):
	print(id(i))
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ python3 main.py 
<span style=color:#ae81ff>139748219328384</span>
<span style=color:#ae81ff>139748219328416</span>
<span style=color:#ae81ff>139748219328448</span>
<span style=color:#ae81ff>139748219328480</span>
<span style=color:#ae81ff>139748219328512</span>
</code></pre></div><p>可以看出 0 到 4 这 5 个数的标识里每两个都相差了 32，刚好符合每一个 <code>PyLongObject</code> 对象所占用的空间 32 字节，而不是 C 语言里一个 <code>long</code> 类型变量通常所占用的 4 字节或 8 字节，这是因为所有原始的数据都会被转化为 <code>PyLongObject</code> 对象。</p>
<p>数据转化的方法有很多，以 <code>PyLong_FromLong</code> 为例，它会将一个 <code>long</code> 类型的整数转化为 <code>PyLongObject</code> 对象：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// Objects/longobject.c
</span><span style=color:#75715e></span><span style=color:#75715e>/* interpreter state */</span>
<span style=color:#75715e>#define _PY_NSMALLPOSINTS           257
</span><span style=color:#75715e>#define _PY_NSMALLNEGINTS           5
</span><span style=color:#75715e></span>
<span style=color:#75715e>#define NSMALLNEGINTS           _PY_NSMALLNEGINTS
</span><span style=color:#75715e>#define NSMALLPOSINTS           _PY_NSMALLPOSINTS
</span><span style=color:#75715e></span>
<span style=color:#75715e>#define IS_SMALL_INT(ival) (-NSMALLNEGINTS &lt;= (ival) &amp;&amp; (ival) &lt; NSMALLPOSINTS)
</span><span style=color:#75715e></span>
PyObject <span style=color:#f92672>*</span>
<span style=color:#a6e22e>PyLong_FromLong</span>(<span style=color:#66d9ef>long</span> ival)
{
    PyLongObject <span style=color:#f92672>*</span>v;
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> abs_ival;
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> t;  <span style=color:#75715e>/* unsigned so &gt;&gt; doesn&#39;t propagate sign bit */</span>
    <span style=color:#66d9ef>int</span> ndigits <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>int</span> sign;

    <span style=color:#66d9ef>if</span> (IS_SMALL_INT(ival)) {
        <span style=color:#66d9ef>return</span> get_small_int((sdigit)ival);
    }

    <span style=color:#66d9ef>if</span> (ival <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
        <span style=color:#75715e>/* negate: can&#39;t write this as abs_ival = -ival since that
</span><span style=color:#75715e>           invokes undefined behaviour when ival is LONG_MIN */</span>
        abs_ival <span style=color:#f92672>=</span> <span style=color:#ae81ff>0U</span><span style=color:#f92672>-</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>)ival;
        sign <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
    }
    <span style=color:#66d9ef>else</span> {
        abs_ival <span style=color:#f92672>=</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>)ival;
        sign <span style=color:#f92672>=</span> ival <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>?</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>;
    }

    <span style=color:#75715e>/* Fast path for single-digit ints */</span>
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(abs_ival <span style=color:#f92672>&gt;&gt;</span> PyLong_SHIFT)) {
        v <span style=color:#f92672>=</span> _PyLong_New(<span style=color:#ae81ff>1</span>);
        <span style=color:#66d9ef>if</span> (v) {
            Py_SET_SIZE(v, sign);
            v<span style=color:#f92672>-&gt;</span>ob_digit[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> Py_SAFE_DOWNCAST(
                abs_ival, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>, digit);
        }
        <span style=color:#66d9ef>return</span> (PyObject<span style=color:#f92672>*</span>)v;
    }

<span style=color:#75715e>#if PyLong_SHIFT==15
</span><span style=color:#75715e></span>    <span style=color:#75715e>/* 2 digits */</span>
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(abs_ival <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>PyLong_SHIFT)) {
        v <span style=color:#f92672>=</span> _PyLong_New(<span style=color:#ae81ff>2</span>);
        <span style=color:#66d9ef>if</span> (v) {
            Py_SET_SIZE(v, <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> sign);
            v<span style=color:#f92672>-&gt;</span>ob_digit[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> Py_SAFE_DOWNCAST(
                abs_ival <span style=color:#f92672>&amp;</span> PyLong_MASK, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>, digit);
            v<span style=color:#f92672>-&gt;</span>ob_digit[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> Py_SAFE_DOWNCAST(
                  abs_ival <span style=color:#f92672>&gt;&gt;</span> PyLong_SHIFT, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>, digit);
        }
        <span style=color:#66d9ef>return</span> (PyObject<span style=color:#f92672>*</span>)v;
    }
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>
    <span style=color:#75715e>/* Larger numbers: loop to determine number of digits */</span>
    t <span style=color:#f92672>=</span> abs_ival;
    <span style=color:#66d9ef>while</span> (t) {
        <span style=color:#f92672>++</span>ndigits;
        t <span style=color:#f92672>&gt;&gt;=</span> PyLong_SHIFT;
    }
    v <span style=color:#f92672>=</span> _PyLong_New(ndigits);
    <span style=color:#66d9ef>if</span> (v <span style=color:#f92672>!=</span> NULL) {
        digit <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> v<span style=color:#f92672>-&gt;</span>ob_digit;
        Py_SET_SIZE(v, ndigits <span style=color:#f92672>*</span> sign);
        t <span style=color:#f92672>=</span> abs_ival;
        <span style=color:#66d9ef>while</span> (t) {
            <span style=color:#f92672>*</span>p<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> Py_SAFE_DOWNCAST(
                t <span style=color:#f92672>&amp;</span> PyLong_MASK, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>, digit);
            t <span style=color:#f92672>&gt;&gt;=</span> PyLong_SHIFT;
        }
    }
    <span style=color:#66d9ef>return</span> (PyObject <span style=color:#f92672>*</span>)v;
}
</code></pre></div><p>虽然看起来比较长，但其实思路非常简单：</p>
<ol>
<li>创建用于存储返回值的指针 <code>PyLongObject *z</code>，保存数据绝对值的变量 <code>unsigned long abs_ival, t</code>，标识数组长度的 <code>int ndigits</code> 和标识数据正负的 <code>int sign</code>；</li>
<li>如果数据范围在 [-5, 257) 内，则通过 <code>get_small_int</code> 函数返回结果；</li>
<li>获取数据的绝对值和正负符号；</li>
<li>如果数据绝对值没有超过 <code>ob_digit</code> 数组的单个元素所能表示的大小，则通过一个快速路径返回结果；</li>
<li>对于较大的数据，确定其 <code>ob_digit</code> 数组的长度，逐位置入。</li>
</ol>
<p>可以注意到，第 2 步针对 [-5, 257) 区间内的小整数做了特殊处理，最终在调用到 <code>__PyLong_GetSmallInt_internal</code> 函数时，会通过 <code>tstate->interp->small_ints[index]</code> 缓存数组获取小整数对应的指针对象并将其返回，这里的 <code>small_ints</code> 数组是一个全局变量，一般称为<strong>小整数对象池</strong>，是针对常用的小整数做的一个优化：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// Objects/longobject.c
</span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> PyObject<span style=color:#f92672>*</span> <span style=color:#a6e22e>__PyLong_GetSmallInt_internal</span>(<span style=color:#66d9ef>int</span> value)
{
    PyThreadState <span style=color:#f92672>*</span>tstate <span style=color:#f92672>=</span> _PyThreadState_GET();
<span style=color:#75715e>#ifdef Py_DEBUG
</span><span style=color:#75715e></span>    _Py_EnsureTstateNotNULL(tstate);
<span style=color:#75715e>#endif
</span><span style=color:#75715e></span>    assert(<span style=color:#f92672>-</span>_PY_NSMALLNEGINTS <span style=color:#f92672>&lt;=</span> value <span style=color:#f92672>&amp;&amp;</span> value <span style=color:#f92672>&lt;</span> _PY_NSMALLPOSINTS);
    size_t index <span style=color:#f92672>=</span> _PY_NSMALLNEGINTS <span style=color:#f92672>+</span> value;
    PyObject <span style=color:#f92672>*</span>obj <span style=color:#f92672>=</span> (PyObject<span style=color:#f92672>*</span>)tstate<span style=color:#f92672>-&gt;</span>interp<span style=color:#f92672>-&gt;</span>small_ints[index];
    <span style=color:#75715e>// _PyLong_GetZero() and _PyLong_GetOne() must not be called
</span><span style=color:#75715e></span>    <span style=color:#75715e>// before _PyLong_Init() nor after _PyLong_Fini()
</span><span style=color:#75715e></span>    assert(obj <span style=color:#f92672>!=</span> NULL);
    <span style=color:#66d9ef>return</span> obj;
}
</code></pre></div><h2 id=2-数学运算>2 数学运算<a hidden class=anchor aria-hidden=true href=#2-数学运算>#</a></h2>
<p><code>PyLongObject</code> 的类型对象是 <code>PyLong_Type</code>，<code>PyLong_Type</code> 的成员变量 <code>PyNumberMethods *tp_as_number</code> 由 <code>static PyNumberMethods long_as_number*</code> 结构体指针初始化，其中包含了许多数学运算的函数指针，当我们对 <code>PyLong_Type</code> 进行数学运算时，实际上会调用这些函数：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// Objects/longobject.c
</span><span style=color:#75715e></span>PyTypeObject PyLong_Type <span style=color:#f92672>=</span> {
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    <span style=color:#f92672>&amp;</span>long_as_number,                            <span style=color:#75715e>/* tp_as_number */</span>
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>};

<span style=color:#66d9ef>static</span> PyNumberMethods long_as_number <span style=color:#f92672>=</span> {
    (binaryfunc)long_add,       <span style=color:#75715e>/*nb_add*/</span>
    (binaryfunc)long_sub,       <span style=color:#75715e>/*nb_subtract*/</span>
    (binaryfunc)long_mul,       <span style=color:#75715e>/*nb_multiply*/</span>
    long_mod,                   <span style=color:#75715e>/*nb_remainder*/</span>
    long_divmod,                <span style=color:#75715e>/*nb_divmod*/</span>
    long_pow,                   <span style=color:#75715e>/*nb_power*/</span>
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>};
</code></pre></div><h3 id=21-加法>2.1 加法<a hidden class=anchor aria-hidden=true href=#21-加法>#</a></h3>
<p><code>PyLong_Type</code> 的加法运算对应的函数是 <code>long_add</code>，其实现和相关的宏定义如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// Objects/longobject.c
</span><span style=color:#75715e></span><span style=color:#75715e>#define CHECK_BINOP(v,w)                                \
</span><span style=color:#75715e>    do {                                                \
</span><span style=color:#75715e>        if (!PyLong_Check(v) || !PyLong_Check(w))       \
</span><span style=color:#75715e>            Py_RETURN_NOTIMPLEMENTED;                   \
</span><span style=color:#75715e>    } while(0)
</span><span style=color:#75715e></span>
<span style=color:#75715e>/* convert a PyLong of size 1, 0 or -1 to an sdigit */</span>
<span style=color:#75715e>#define MEDIUM_VALUE(x) (assert(-1 &lt;= Py_SIZE(x) &amp;&amp; Py_SIZE(x) &lt;= 1),   \
</span><span style=color:#75715e>         Py_SIZE(x) &lt; 0 ? -(sdigit)(x)-&gt;ob_digit[0] :   \
</span><span style=color:#75715e>             (Py_SIZE(x) == 0 ? (sdigit)0 :                             \
</span><span style=color:#75715e>              (sdigit)(x)-&gt;ob_digit[0]))
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>static</span> PyObject <span style=color:#f92672>*</span>
<span style=color:#a6e22e>long_add</span>(PyLongObject <span style=color:#f92672>*</span>a, PyLongObject <span style=color:#f92672>*</span>b)
{
    PyLongObject <span style=color:#f92672>*</span>z;

    CHECK_BINOP(a, b);

    <span style=color:#66d9ef>if</span> (Py_ABS(Py_SIZE(a)) <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> Py_ABS(Py_SIZE(b)) <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span>) {
        <span style=color:#66d9ef>return</span> PyLong_FromLong(MEDIUM_VALUE(a) <span style=color:#f92672>+</span> MEDIUM_VALUE(b));
    }
    <span style=color:#66d9ef>if</span> (Py_SIZE(a) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
        <span style=color:#66d9ef>if</span> (Py_SIZE(b) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
            z <span style=color:#f92672>=</span> x_add(a, b);
            <span style=color:#66d9ef>if</span> (z <span style=color:#f92672>!=</span> NULL) {
                <span style=color:#75715e>/* x_add received at least one multiple-digit int,
</span><span style=color:#75715e>                   and thus z must be a multiple-digit int.
</span><span style=color:#75715e>                   That also means z is not an element of
</span><span style=color:#75715e>                   small_ints, so negating it in-place is safe. */</span>
                assert(Py_REFCNT(z) <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>);
                Py_SET_SIZE(z, <span style=color:#f92672>-</span>(Py_SIZE(z)));
            }
        }
        <span style=color:#66d9ef>else</span>
            z <span style=color:#f92672>=</span> x_sub(b, a);
    }
    <span style=color:#66d9ef>else</span> {
        <span style=color:#66d9ef>if</span> (Py_SIZE(b) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
            z <span style=color:#f92672>=</span> x_sub(a, b);
        <span style=color:#66d9ef>else</span>
            z <span style=color:#f92672>=</span> x_add(a, b);
    }
    <span style=color:#66d9ef>return</span> (PyObject <span style=color:#f92672>*</span>)z;
}
</code></pre></div><p>可以看到它的实现非常简单，主要分为以下几个步骤：</p>
<ol>
<li>创建一个用于存储返回值的指针 <code>PyLongObject *z</code>；</li>
<li>检查两个参数是否都是 <code>PyLongObject</code> 类型的指针 <code>CHECK_BINOP(a, b)</code>；</li>
<li>如果两个参数都满足 <code>ob_size &lt;= 1</code>（即绝对值均小于 <code>2^30</code>），那么先通过 <code>MEDIUM_VALUE</code> 获取两个 <code>ob_digit[0]</code> 的值，并将两数直接相加（一定不会溢出），再通过 <code>PyLong_FromLong</code> 将这个数包装为一个 <code>PyLongObject</code> 指针并返回；通常我们进行运算的数都不会太大，因此这里可以利用简化的运算步骤和 CPU 分支预测来提高效率；</li>
<li>判断两者的正负关系，将问题简化为绝对值加减法，利用辅助函数 <code>x_add</code> 和 <code>x_sub</code> 进行运算并返回结果。</li>
</ol>
<h3 id=22-绝对值加法>2.2 绝对值加法<a hidden class=anchor aria-hidden=true href=#22-绝对值加法>#</a></h3>
<p>绝对值加法函数 <code>x_add</code> 的定义如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>#if PYLONG_BITS_IN_DIGIT == 30
</span><span style=color:#75715e>#define PyLong_SHIFT    30
</span><span style=color:#75715e></span><span style=color:#75715e>// ...
</span><span style=color:#75715e></span><span style=color:#75715e>#endif
</span><span style=color:#75715e>#define PyLong_BASE     ((digit)1 &lt;&lt; PyLong_SHIFT)
</span><span style=color:#75715e>#define PyLong_MASK     ((digit)(PyLong_BASE - 1))
</span><span style=color:#75715e></span>
<span style=color:#75715e>/* Add the absolute values of two integers. */</span>
<span style=color:#66d9ef>static</span> PyLongObject <span style=color:#f92672>*</span>
<span style=color:#a6e22e>x_add</span>(PyLongObject <span style=color:#f92672>*</span>a, PyLongObject <span style=color:#f92672>*</span>b)
{
    Py_ssize_t size_a <span style=color:#f92672>=</span> Py_ABS(Py_SIZE(a)), size_b <span style=color:#f92672>=</span> Py_ABS(Py_SIZE(b));
    PyLongObject <span style=color:#f92672>*</span>z;
    Py_ssize_t i;
    digit carry <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

    <span style=color:#75715e>/* Ensure a is the larger of the two: */</span>
    <span style=color:#66d9ef>if</span> (size_a <span style=color:#f92672>&lt;</span> size_b) {
        { PyLongObject <span style=color:#f92672>*</span>temp <span style=color:#f92672>=</span> a; a <span style=color:#f92672>=</span> b; b <span style=color:#f92672>=</span> temp; }
        { Py_ssize_t size_temp <span style=color:#f92672>=</span> size_a;
            size_a <span style=color:#f92672>=</span> size_b;
            size_b <span style=color:#f92672>=</span> size_temp; }
    }
    z <span style=color:#f92672>=</span> _PyLong_New(size_a<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>);
    <span style=color:#66d9ef>if</span> (z <span style=color:#f92672>==</span> NULL)
        <span style=color:#66d9ef>return</span> NULL;
    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> size_b; <span style=color:#f92672>++</span>i) {
        carry <span style=color:#f92672>+=</span> a<span style=color:#f92672>-&gt;</span>ob_digit[i] <span style=color:#f92672>+</span> b<span style=color:#f92672>-&gt;</span>ob_digit[i];
        z<span style=color:#f92672>-&gt;</span>ob_digit[i] <span style=color:#f92672>=</span> carry <span style=color:#f92672>&amp;</span> PyLong_MASK;
        carry <span style=color:#f92672>&gt;&gt;=</span> PyLong_SHIFT;
    }
    <span style=color:#66d9ef>for</span> (; i <span style=color:#f92672>&lt;</span> size_a; <span style=color:#f92672>++</span>i) {
        carry <span style=color:#f92672>+=</span> a<span style=color:#f92672>-&gt;</span>ob_digit[i];
        z<span style=color:#f92672>-&gt;</span>ob_digit[i] <span style=color:#f92672>=</span> carry <span style=color:#f92672>&amp;</span> PyLong_MASK;
        carry <span style=color:#f92672>&gt;&gt;=</span> PyLong_SHIFT;
    }
    z<span style=color:#f92672>-&gt;</span>ob_digit[i] <span style=color:#f92672>=</span> carry;
    <span style=color:#66d9ef>return</span> long_normalize(z);
}
</code></pre></div><p>其步骤大致分为以下几步：</p>
<ol>
<li>获取两个参数的 <code>ob_size</code> 的绝对值，创建存储返回值的指针 <code>PyLongObject *z</code>，</li>
<li>如果 <code>a->ob_size &lt; b->ob_size</code> 则交换两者，保证 a 的值较大；</li>
<li>将 z 的 <code>ob_size</code> 设置为 <code>size_a + 1</code>，保证不会溢出；</li>
<li>以 <code>i = 0</code> 为下标，从小到大依次对两数的每一位进行相加操作，将没有超过 <code>2^30</code> 的部分存储在 <code>z->ob_digit[i]</code> 中，超过的部分进位保存在 <code>carry</code> 中；这里充分利用了两个小于 <code>2^30</code> 的数相加不会溢出的特性；如果 <code>size_a > size_b</code> 还需要将 <code>a->ob_digit</code> 多余的部分按照相同的方法置入 <code>z->ob_digit</code>里；</li>
<li>得到的结果 <code>z</code> 中，其 <code>ob_digit</code> 的最后一个元素可能等于 0，因此通过 <code>long_normalize</code> 函数将其转换为符合 <code>PyLongObject</code> 定义的格式返回。</li>
</ol>
<p>整个过程可以抽象为类似 <code>2^30</code> 进制的加法，和十进制加法的过程几乎完全一样，只不过是把十进制每一位的数字换成了一个最大值为 <code>2^30</code> 的数字，每逢 <code>2^30</code> 进一位；举个例，假设有 <code>a->ob_digit = {4, 5, 6}</code>, <code>b->ob_digit = {1073741823, 1073741823}</code>，那么整个加法的步骤为：</p>
<ol>
<li><code>v->ob_digit[0] = (4 + 1073741823) % 1073741824 = 3</code>, <code>carry = 1</code>；</li>
<li><code>v->ob_digit[1] = (5 + 1073741823 + 1) % 1073741824 = 5</code>, <code>carry = 1</code>；</li>
<li><code>v->ob_digit[2] = (6 + 1) % 1073741824 = 7</code>, <code>carry = 0</code>；</li>
<li><code>v->ob_digit[3] = 0</code>；</li>
</ol>
<p>结果即 <code>v->ob_digit = {3, 5, 7, 0}</code>，最后一个元素 0 需要通过 <code>long_normalize</code> 函数去掉。</p>
<h3 id=23-绝对值减法>2.3 绝对值减法<a hidden class=anchor aria-hidden=true href=#23-绝对值减法>#</a></h3>
<p>绝对值减法的实现如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>/* Subtract the absolute values of two integers. */</span>
<span style=color:#66d9ef>static</span> PyLongObject <span style=color:#f92672>*</span>
<span style=color:#a6e22e>x_sub</span>(PyLongObject <span style=color:#f92672>*</span>a, PyLongObject <span style=color:#f92672>*</span>b)
{
    Py_ssize_t size_a <span style=color:#f92672>=</span> Py_ABS(Py_SIZE(a)), size_b <span style=color:#f92672>=</span> Py_ABS(Py_SIZE(b));
    PyLongObject <span style=color:#f92672>*</span>z;
    Py_ssize_t i;
    <span style=color:#66d9ef>int</span> sign <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
    digit borrow <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

    <span style=color:#75715e>/* Ensure a is the larger of the two: */</span>
    <span style=color:#66d9ef>if</span> (size_a <span style=color:#f92672>&lt;</span> size_b) {
        sign <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
        { PyLongObject <span style=color:#f92672>*</span>temp <span style=color:#f92672>=</span> a; a <span style=color:#f92672>=</span> b; b <span style=color:#f92672>=</span> temp; }
        { Py_ssize_t size_temp <span style=color:#f92672>=</span> size_a;
            size_a <span style=color:#f92672>=</span> size_b;
            size_b <span style=color:#f92672>=</span> size_temp; }
    }
    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (size_a <span style=color:#f92672>==</span> size_b) {
        <span style=color:#75715e>/* Find highest digit where a and b differ: */</span>
        i <span style=color:#f92672>=</span> size_a;
        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>--</span>i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> a<span style=color:#f92672>-&gt;</span>ob_digit[i] <span style=color:#f92672>==</span> b<span style=color:#f92672>-&gt;</span>ob_digit[i])
            ;
        <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
            <span style=color:#66d9ef>return</span> (PyLongObject <span style=color:#f92672>*</span>)PyLong_FromLong(<span style=color:#ae81ff>0</span>);
        <span style=color:#66d9ef>if</span> (a<span style=color:#f92672>-&gt;</span>ob_digit[i] <span style=color:#f92672>&lt;</span> b<span style=color:#f92672>-&gt;</span>ob_digit[i]) {
            sign <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
            { PyLongObject <span style=color:#f92672>*</span>temp <span style=color:#f92672>=</span> a; a <span style=color:#f92672>=</span> b; b <span style=color:#f92672>=</span> temp; }
        }
        size_a <span style=color:#f92672>=</span> size_b <span style=color:#f92672>=</span> i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
    }
    z <span style=color:#f92672>=</span> _PyLong_New(size_a);
    <span style=color:#66d9ef>if</span> (z <span style=color:#f92672>==</span> NULL)
        <span style=color:#66d9ef>return</span> NULL;
    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> size_b; <span style=color:#f92672>++</span>i) {
        <span style=color:#75715e>/* The following assumes unsigned arithmetic
</span><span style=color:#75715e>           works module 2**N for some N&gt;PyLong_SHIFT. */</span>
        borrow <span style=color:#f92672>=</span> a<span style=color:#f92672>-&gt;</span>ob_digit[i] <span style=color:#f92672>-</span> b<span style=color:#f92672>-&gt;</span>ob_digit[i] <span style=color:#f92672>-</span> borrow;
        z<span style=color:#f92672>-&gt;</span>ob_digit[i] <span style=color:#f92672>=</span> borrow <span style=color:#f92672>&amp;</span> PyLong_MASK;
        borrow <span style=color:#f92672>&gt;&gt;=</span> PyLong_SHIFT;
        borrow <span style=color:#f92672>&amp;=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>/* Keep only one sign bit */</span>
    }
    <span style=color:#66d9ef>for</span> (; i <span style=color:#f92672>&lt;</span> size_a; <span style=color:#f92672>++</span>i) {
        borrow <span style=color:#f92672>=</span> a<span style=color:#f92672>-&gt;</span>ob_digit[i] <span style=color:#f92672>-</span> borrow;
        z<span style=color:#f92672>-&gt;</span>ob_digit[i] <span style=color:#f92672>=</span> borrow <span style=color:#f92672>&amp;</span> PyLong_MASK;
        borrow <span style=color:#f92672>&gt;&gt;=</span> PyLong_SHIFT;
        borrow <span style=color:#f92672>&amp;=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>/* Keep only one sign bit */</span>
    }
    assert(borrow <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>);
    <span style=color:#66d9ef>if</span> (sign <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
        Py_SET_SIZE(z, <span style=color:#f92672>-</span>Py_SIZE(z));
    }
    <span style=color:#66d9ef>return</span> maybe_small_long(long_normalize(z));
}
</code></pre></div><p>其步骤和绝对值加法类似，大致分为以下几步：</p>
<ol>
<li>获取两个参数的 <code>ob_size</code> 的绝对值，创建存储返回值的指针 <code>PyLongObject *z</code>，</li>
<li>如果 <code>a->ob_size &lt; b->ob_size</code> 则交换两者，保证 a 的值较大，并用 <code>sign</code> 记录运算结果为负；如果 <code>a->ob_size == b->ob_size</code> 则从最高位依次往低位找到第一次出现 <code>a->ob_digit[i] != b->ob_digit[i]</code> 的位置，比较 <code>a->ob_digit[i]</code> 和 <code>b->ob_digit[i]</code>，并决定是否交换两者以及 <code>sign</code> 的值；</li>
<li>将 z 的 <code>ob_size</code> 设置为 <code>size_a</code>；</li>
<li>以 <code>i = 0</code> 为下标，从小到大依次对两数的每一位进行相减操作，如果被减数 <code>a->ob_digit[i]</code> 小于减数 <code>b->ob_digit[i]</code> 则要向高位 <code>a->ob_digit[i + 1]</code> 借 1；在十进制的减法中向高位借到的数是 10，这里向 <code>digit</code> 数组的高位借到的则是 <code>2^30</code>；但 <code>digit</code> 是通过 <code>typedef uint32_t digit</code> 定义出来，通过公式 <code>borrow = a->ob_digit[i] - b->ob_digit[i] - borrow</code> 实际上得到的是 <code>2^32 + a->ob_digit[i] - b->ob_digit[i]</code>，所以还需要与 <code>PyLong_MASK</code> 做 <code>&</code> 操作，取后 30 位，便能得到借位相减后的结果，再将结果存储在 <code>z->ob_digit[i]</code> 中；借位部分 <code>borrow</code> 向右位移 30 位后还剩 2 位，只需要将其与 1 进行 <code>&</code> 操作即可知道此次减法运算是否有借位；如果 <code>size_a > size_b</code> 还需要将 <code>a->ob_digit</code> 多余的部分按照相同的方法置入 <code>z->ob_digit</code>里；</li>
<li>得到的结果 <code>z</code> 中，其 <code>ob_digit</code> 的最后一个元素可能等于 0，因此通过 <code>long_normalize</code> 函数将其转换为符合 <code>PyLongObject</code> 定义的格式返回。</li>
</ol>
<p>可以看到这里的步骤也跟十进制减法几乎完全相同，都跟 NOIP 入门的大数加减法加法思路相同。</p>
</div>
<footer class=post-footer>
<nav class=paginav>
<a class=prev href=http://zintrulcre.github.io/posts/serialization/protocol-buffer/>
<span class=title>« Prev Page</span>
<br>
<span>ProtoBuf 语法和编码原理入门</span>
</a>
<a class=next href=http://zintrulcre.github.io/posts/python/source-code-1/>
<span class=title>Next Page »</span>
<br>
<span>Python 源码学习（1）：类型和对象</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>
Zhengyu &copy; 2022
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>