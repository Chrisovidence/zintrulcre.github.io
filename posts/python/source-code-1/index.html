<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Python 源码学习（1）：类型和对象 | 尾張</title>
<meta name=keywords content>
<meta name=description content="Python 源码学习（1）：类型和对象 Python 是一门解释型，动态类型，多范式的编程语言，当我们从 python.org 下载并安装运行 Python 的某个分发版本时，我们实际上是在运行由 C 语言编写的 CPython，除此之外 Python 的运行时还有 Jython, PyPy, Cython 等；CPython 的源码中有一系列的库，组件和工具：
$ git clone https://github.com/python/cpython $ tree -d -L 2 . . `-- cpython |-- Doc	# 文档 |-- Grammar |-- Include # C 头文件 |-- Lib	# 用 Python 写的库文件 |-- Mac	# 用于在 macOS 上构建的文件 |-- Misc	# 杂项 |-- Modules	# 用 C 写的库文件 |-- Objects # 核心类型，以及对象模型的定义 |-- PC	# 用于在 Windows 上构建的文件 |-- PCbuild # 用于在老版本的 Windows 上构建的文件 |-- Parser	# Python 解析器源码 |-- Programs	# Python 可执行文件和其他 |-- Python	# CPython 编译器源码 |-- Tools	# 构建时的工具 `-- m4 16 directories 本系列主要以阅读和分析 CPython 源码的方式学习 Python。">
<meta name=author content>
<link rel=canonical href=http://zintrulcre.github.io/posts/python/source-code-1/>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.0">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-132809676-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="Python 源码学习（1）：类型和对象">
<meta property="og:description" content="Python 源码学习（1）：类型和对象 Python 是一门解释型，动态类型，多范式的编程语言，当我们从 python.org 下载并安装运行 Python 的某个分发版本时，我们实际上是在运行由 C 语言编写的 CPython，除此之外 Python 的运行时还有 Jython, PyPy, Cython 等；CPython 的源码中有一系列的库，组件和工具：
$ git clone https://github.com/python/cpython $ tree -d -L 2 . . `-- cpython |-- Doc	# 文档 |-- Grammar |-- Include # C 头文件 |-- Lib	# 用 Python 写的库文件 |-- Mac	# 用于在 macOS 上构建的文件 |-- Misc	# 杂项 |-- Modules	# 用 C 写的库文件 |-- Objects # 核心类型，以及对象模型的定义 |-- PC	# 用于在 Windows 上构建的文件 |-- PCbuild # 用于在老版本的 Windows 上构建的文件 |-- Parser	# Python 解析器源码 |-- Programs	# Python 可执行文件和其他 |-- Python	# CPython 编译器源码 |-- Tools	# 构建时的工具 `-- m4 16 directories 本系列主要以阅读和分析 CPython 源码的方式学习 Python。">
<meta property="og:type" content="article">
<meta property="og:url" content="http://zintrulcre.github.io/posts/python/source-code-1/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-03-14T16:05:52+08:00">
<meta property="article:modified_time" content="2021-03-14T16:05:52+08:00"><meta property="og:site_name" content="尾張">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Python 源码学习（1）：类型和对象">
<meta name=twitter:description content="Python 源码学习（1）：类型和对象 Python 是一门解释型，动态类型，多范式的编程语言，当我们从 python.org 下载并安装运行 Python 的某个分发版本时，我们实际上是在运行由 C 语言编写的 CPython，除此之外 Python 的运行时还有 Jython, PyPy, Cython 等；CPython 的源码中有一系列的库，组件和工具：
$ git clone https://github.com/python/cpython $ tree -d -L 2 . . `-- cpython |-- Doc	# 文档 |-- Grammar |-- Include # C 头文件 |-- Lib	# 用 Python 写的库文件 |-- Mac	# 用于在 macOS 上构建的文件 |-- Misc	# 杂项 |-- Modules	# 用 C 写的库文件 |-- Objects # 核心类型，以及对象模型的定义 |-- PC	# 用于在 Windows 上构建的文件 |-- PCbuild # 用于在老版本的 Windows 上构建的文件 |-- Parser	# Python 解析器源码 |-- Programs	# Python 可执行文件和其他 |-- Python	# CPython 编译器源码 |-- Tools	# 构建时的工具 `-- m4 16 directories 本系列主要以阅读和分析 CPython 源码的方式学习 Python。">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://zintrulcre.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Python 源码学习（1）：类型和对象","item":"http://zintrulcre.github.io/posts/python/source-code-1/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python 源码学习（1）：类型和对象","name":"Python 源码学习（1）：类型和对象","description":"Python 源码学习（1）：类型和对象 Python 是一门解释型，动态类型，多范式的编程语言，当我们从 python.org 下载并安装运行 Python 的某个分发版本时，我们实际上是在运行由 C 语言编写的 CPython，除此之外 Python 的运行时还有 Jython, PyPy, Cython 等；CPython 的源码中有一系列的库，组件和工具：\n$ git clone https://github.com/python/cpython $ tree -d -L 2 . . `-- cpython |-- Doc\t# 文档 |-- Grammar |-- Include # C 头文件 |-- Lib\t# 用 Python 写的库文件 |-- Mac\t# 用于在 macOS 上构建的文件 |-- Misc\t# 杂项 |-- Modules\t# 用 C 写的库文件 |-- Objects # 核心类型，以及对象模型的定义 |-- PC\t# 用于在 Windows 上构建的文件 |-- PCbuild # 用于在老版本的 Windows 上构建的文件 |-- Parser\t# Python 解析器源码 |-- Programs\t# Python 可执行文件和其他 |-- Python\t# CPython 编译器源码 |-- Tools\t# 构建时的工具 `-- m4 16 directories 本系列主要以阅读和分析 CPython 源码的方式学习 Python。","keywords":[],"articleBody":"Python 源码学习（1）：类型和对象 Python 是一门解释型，动态类型，多范式的编程语言，当我们从 python.org 下载并安装运行 Python 的某个分发版本时，我们实际上是在运行由 C 语言编写的 CPython，除此之外 Python 的运行时还有 Jython, PyPy, Cython 等；CPython 的源码中有一系列的库，组件和工具：\n$ git clone https://github.com/python/cpython $ tree -d -L 2 . . `-- cpython |-- Doc\t# 文档 |-- Grammar |-- Include # C 头文件 |-- Lib\t# 用 Python 写的库文件 |-- Mac\t# 用于在 macOS 上构建的文件 |-- Misc\t# 杂项 |-- Modules\t# 用 C 写的库文件 |-- Objects # 核心类型，以及对象模型的定义 |-- PC\t# 用于在 Windows 上构建的文件 |-- PCbuild # 用于在老版本的 Windows 上构建的文件 |-- Parser\t# Python 解析器源码 |-- Programs\t# Python 可执行文件和其他 |-- Python\t# CPython 编译器源码 |-- Tools\t# 构建时的工具 `-- m4 16 directories 本系列主要以阅读和分析 CPython 源码的方式学习 Python。\n1 对象模型 Python 是一门面向对象的语言，我们可以使用 Python 中的 type() 函数查看一个对象所属的类：\n type(1) 'int'  type(True) 'bool' 可以看到整数对象和布尔值对象的类型分别是  和 ；\n而实际上，在 Python 中无论是整数，布尔值还是基本数据类型，甚至自定义的 class，都是对象：\nclass Foo: pass print(type(int)) print(type(Foo)) 'type' 'type' 可以看到 int 类型和自定义类 Foo 的类型都是 ，它们是 type 这个类的实例对象；type 类型是专门用于定义类型的类型，也称为元类型；实际上， type 这个类型本身也是一个对象，它所属的类也是 type：\n type(type) 'type' 同时，Python 中的所有类型，无论是 int, type, 还是自定义类 Foo 都是继承自一个叫 object 的基类，而 object 则是继承链的终点：\n int.__base__ 'object'  type.__base__ 'object'  print(Foo.__base__) 'object'  print(object.__base__) None 而 object 基类也是一个 type 类型的对象：\n type(object) 'type' 上面的关系用图表达出来则是：\n可以看到，所有类型的基类都是 object，所有类型的类型都是 type，这就是 Python 的对象模型（object model），也是 Objects/ 目录下源码所包含的内容。\n2 核心类型与对象 虽然在 Python 的语法层面有非常多所谓的类型（包括 int, type, Foo 等），但实际上它们在源码（C 语言）层面上都是结构体对象。\n2.1 对象 PyObject Python 中所有的类型都由 PyObject 结构体扩展而来，这个结构体中有以下几个成员变量：\n Py_ssize_t ob_refcnt 用于保存对象的引用计数； PyTypeObject *ob_type 指向对象的类型对象，用来标识对象属于的类型，并存储类型的元数据； _PyObject_HEAD_EXTRA 宏代表了两个 PyObject* 双向链表的指针，用于把堆上的所有对象链接起来，只会在开启了 Py_TRACE_REFS 宏的时候进行构造，方便调试；  // Include/object.h  /* Define pointers to support a doubly-linked list of all live heap objects. */ #define _PyObject_HEAD_EXTRA \\ struct _object *_ob_next; \\ struct _object *_ob_prev;  /* Nothing is actually declared to be a PyObject, but every pointer to * a Python object can be cast to a PyObject*. This is inheritance built * by hand. Similarly every pointer to a variable-size Python object can, * in addition, be cast to PyVarObject*. */ typedef struct _object { _PyObject_HEAD_EXTRA\t// 双向链表，用于追踪堆中所有对象，在开启了 Py_TRACE_REFS 宏的时候有用  Py_ssize_t ob_refcnt;\t// 引用计数，用于垃圾回收  PyTypeObject *ob_type;\t// 指针，指向当前对象的类型对象，用于查询对象的类型 } PyObject; PyVarObject Python 中有可以自由修改长度的 PyVarObject 变长对象，它由一个 PyObject 对象和一个存储变长部分的长度（元素个数）的变量 ob_size 组成：\ntypedef struct { PyObject ob_base; Py_ssize_t ob_size; /* Number of items in variable part */ } PyVarObject; PyObject 和 PyVarObject 一般是作为头部被包含在一个变量结构体中的，根据该变量大小是否固定来选择使用哪一种：\n// Include/object.h /* PyObject_HEAD defines the initial segment of every PyObject. */ #define PyObject_HEAD PyObject ob_base;  /* PyObject_VAR_HEAD defines the initial segment of all variable-size * container objects. These end with a declaration of an array with 1 * element, but enough space is malloc'ed so that the array actually * has room for ob_size elements. Note that ob_size is an element count, * not necessarily a byte count. */ #define PyObject_VAR_HEAD PyVarObject ob_base; Python 中最典型的变长对象就是列表 List，它和 std::vector 比较类似，列表对象里有三个成员变量，包括：\n 基础的变长对象 PyVarObject ob_base，其中 ob_base.ob_size 用于表示列表当前的元素个数； 指向动态数组的指针 PyObject **ob_item； 动态数组当前的容量 Py_ssize_t allocated：  // Inlucde/cpython/listobject.h  typedef struct { PyObject_VAR_HEAD /* Vector of pointers to list elements. list[0] is ob_item[0], etc. */ PyObject **ob_item; /* ob_item contains space for 'allocated' elements. The number * currently in use is ob_size. * Invariants: * 0 * len(list) == ob_size * ob_item == NULL implies ob_size == allocated == 0 * list.sort() temporarily sets allocated to -1 to detect mutations. * * Items must normally not be NULL, except during construction when * the list is not yet visible outside the function that builds it. */ Py_ssize_t allocated; } PyListObject; 2.2 类型 PyTypeObject PyObject 类中的 PyTypeObject *ob_type 是一个指向对象类型的指针，它是类在 Python 中的表现形式；PyTypeObject 不仅决定了 PyObject 对象属于什么类型，还包含了非常多的元数据，例如：\n PyObject_VAR_HEAD 表示 PyTypeObject 本身是一个变长对象； const char *tp_name 表示类型的名字； struct _typeobject *tp_base 是指向基类的指针，保存类型的继承信息； Py_ssize_t tp_basicsize, tp_itemsize 表示创建实力对象时分配的内存大小； setattrfunc tp_setattr 设置值，getattrfunc tp_getattr 获取值，destructor tp_dealloc 析构，hashfunc tp_hash 哈希等函数指针表示该类型所支持的标准操作；  // Include/object.h  /* PyTypeObject structure is defined in cpython/object.h. In Py_LIMITED_API, PyTypeObject is an opaque structure. */ typedef struct _typeobject PyTypeObject; // Include/cpython/object.h struct _typeobject { PyObject_VAR_HEAD // 即 PyVarObject ob_base;  const char *tp_name; /* For printing, in format \".\" */ Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */ /* Methods to implement standard operations */ destructor tp_dealloc; Py_ssize_t tp_vectorcall_offset; getattrfunc tp_getattr; setattrfunc tp_setattr; PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python 2) or tp_reserved (Python 3) */ // Strong reference on a heap type, borrowed reference on a static type  struct _typeobject *tp_base; /* More standard operations (here for binary compatibility) */ // ... }; Python 中的每一种类型对象都是全局唯一的，他们在源码中以全局变量的形式存在，例如 int 类型：\n// Objects/longobject.c PyTypeObject PyLong_Type = { PyVarObject_HEAD_INIT(\u0026PyType_Type, 0) \"int\", /* tp_name */ offsetof(PyLongObject, ob_digit), /* tp_basicsize */ sizeof(digit), /* tp_itemsize */ 0, /* tp_dealloc */ 0, /* tp_vectorcall_offset */ 0, /* tp_getattr */ 0, /* tp_setattr */ 0, /* tp_as_async */ long_to_decimal_string, /* tp_repr */ \u0026long_as_number, /* tp_as_number */ // ... }; PyVarObject_HEAD_INIT 宏用于初始化 PyVarObject 中的 ob_refcnt, ob_type 和 ob_size：\n#define PyObject_HEAD_INIT(type) \\ { 1, type },  #define PyVarObject_HEAD_INIT(type, size) \\ { PyObject_HEAD_INIT(type) size },  可以看到在 PyLong_Type 中，ob_type 被初始化为 \u0026PyType_Type，它是专门用于定义类型对象的类型，抑或叫做类型的类型或原类型。\nPyType_Type 在前面已经了解到，type 类型对象所属的类也是 type，那么类型对象 PyTypeObject 本身也是一个类对象，它也拥有指向其类型对象的指针 PyTypeObject *ob_type；对于类型对象本身来说，它的类型对象都基于一个叫做 PyType_Type（即元类型）的 PyTypeObject 类对象：\n// Objects/typeobject.c PyTypeObject PyType_Type = { PyVarObject_HEAD_INIT(\u0026PyType_Type, 0)\t// PyType_Type 在初始化的时候将指向自身的指针传递并用于构造了一个 PyVarObject 类型的对象 ob_base，其中 ob_base-ob_type = \u0026PyType_Type，参考附录 1  \"type\", /* tp_name */ sizeof(PyHeapTypeObject), /* tp_basicsize */ sizeof(PyMemberDef), /* tp_itemsize */ (destructor)type_dealloc, /* tp_dealloc */ offsetof(PyTypeObject, tp_vectorcall), /* tp_vectorcall_offset */ // ... }; Python 中类型对象都定义在了 Objects/ 目录下，例如 bool 类型：\n// Objects/boolobject.c  /* The type object for bool. Note that this cannot be subclassed! */ PyTypeObject PyBool_Type = { PyVarObject_HEAD_INIT(\u0026PyType_Type, 0)\t// 同 PyType_Type，ob_base-ob_type = \u0026PyType_Type  \"bool\",\t// tp_name = \"bool\"  sizeof(struct _longobject),\t/* tp_basicsize */ 0,\t/* tp_itemsize */ 0, /* tp_dealloc */ 0, /* tp_vectorcall_offset */ 0, /* tp_getattr */ 0, /* tp_setattr */ 0, /* tp_as_async */ bool_repr, /* tp_repr */ \u0026bool_as_number, /* tp_as_number */ // ...  0, /* tp_base */ // ... }; 在 Python 中，无论是内建类型（int, bool 等），还是自定义类型（Foo），都是通过 PyTypeObject 这个结构体构造的，且一定满足 ob_base-ob_type = \u0026PyType_Type。\n前文提到 tp_base 是指向基类的指针，保存类型的继承信息，但实际上在定义 PyBool_Type 的时候可以看到 tp_base = 0，实际上这个 tp_base 是在 PyType_Ready 函数中被赋值为 PyBaseObject_Type 的：\n// Objects/typeobject.c  int PyType_Ready(PyTypeObject *type) { PyTypeObject *base; // ... \t/* Initialize tp_base (defaults to BaseObject unless that's us) */ base = type-tp_base; if (base == NULL \u0026\u0026 type != \u0026PyBaseObject_Type) { base = \u0026PyBaseObject_Type; if (type-tp_flags \u0026 Py_TPFLAGS_HEAPTYPE) { type-tp_base = (PyTypeObject*)Py_NewRef((PyObject*)base); } else { type-tp_base = base; } } // ... } 这里 PyTypeObject *base 被赋值为的 PyBaseObject_Type 就是前文提到的基类型。\nPyBaseObject_Type PyBaseObject_Type 定义在 typeobject.c 文件中：\n// Objects/typeobject.c PyTypeObject PyBaseObject_Type = { PyVarObject_HEAD_INIT(\u0026PyType_Type, 0)\t// 同 PyType_Type，ob_base-ob_type = \u0026PyType_Type  \"object\", /* tp_name */ sizeof(PyObject), /* tp_basicsize */ 0, /* tp_itemsize */ object_dealloc, /* tp_dealloc */ // ...  object_repr, /* tp_repr */ // ...  0, /* tp_base */ // ... }; 可以看到无论是 PyBool_Type，PyType_Type 还是 PyBaseObject_Type，都有两个共同点：\n 它们是以同样的方式 PyVarObject_HEAD_INIT(\u0026PyType_Type, 0) 定义其类型的，因此它们的类型都是 PyTypeObject； 它们指向基类的指针 tp_base 初始化时都是 NULL；  不同的地方是，在使用 PyType_Ready 函数为它们的基类指针 tp_base 赋值时，只有 PyBaseObject_Type.tp_base 不会被赋值，其他的 tp_base 则都会被赋值为 PyBaseObject_Type，这也印证了 PyBaseObject_Type 是继承链的终点。\n我们可以将上面的关系整理为一个图：\n附录 1 PyType_Type 构造 struct Bar; struct Foo { Bar* p_b; int ref_count; }; struct Bar { Foo f; const char* name; }; Bar b { Foo{ \u0026b, 1 }, \"ClassBar\" }; int main() { printf(\"%s\\n\", b.f.p_b-name); return 0; } $ ./test ClassBar ","wordCount":"1106","inLanguage":"en","datePublished":"2021-03-14T16:05:52+08:00","dateModified":"2021-03-14T16:05:52+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://zintrulcre.github.io/posts/python/source-code-1/"},"publisher":{"@type":"Organization","name":"尾張","logo":{"@type":"ImageObject","url":"http://zintrulcre.github.io/%3Clink%20/%20abs%20url%3E"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://zintrulcre.github.io/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=http://zintrulcre.github.io/archives/ title=Posts>
<span>Posts</span>
</a>
</li>
<li>
<a href=http://zintrulcre.github.io/about/ title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=http://zintrulcre.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://zintrulcre.github.io/posts/>Posts</a></div>
<h1 class=post-title>
Python 源码学习（1）：类型和对象
</h1>
<div class=post-meta><span title="2021-03-14 16:05:52 +0800 CST">March 14, 2021</span>&nbsp;·&nbsp;6 min
</div>
</header> <div class=toc>
<details open>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#python-%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a01%e7%b1%bb%e5%9e%8b%e5%92%8c%e5%af%b9%e8%b1%a1 aria-label="Python 源码学习（1）：类型和对象">Python 源码学习（1）：类型和对象</a><ul>
<li>
<a href=#1-%e5%af%b9%e8%b1%a1%e6%a8%a1%e5%9e%8b aria-label="1 对象模型">1 对象模型</a></li>
<li>
<a href=#2-%e6%a0%b8%e5%bf%83%e7%b1%bb%e5%9e%8b%e4%b8%8e%e5%af%b9%e8%b1%a1 aria-label="2 核心类型与对象">2 核心类型与对象</a><ul>
<li>
<a href=#21-%e5%af%b9%e8%b1%a1 aria-label="2.1 对象">2.1 对象</a><ul>
<li>
<a href=#pyobject aria-label=PyObject>PyObject</a></li>
<li>
<a href=#pyvarobject aria-label=PyVarObject>PyVarObject</a></li></ul>
</li>
<li>
<a href=#22-%e7%b1%bb%e5%9e%8b aria-label="2.2 类型">2.2 类型</a><ul>
<li>
<a href=#pytypeobject aria-label=PyTypeObject>PyTypeObject</a></li>
<li>
<a href=#pytype_type aria-label=PyType_Type>PyType_Type</a></li>
<li>
<a href=#pybaseobject_type aria-label=PyBaseObject_Type>PyBaseObject_Type</a></li></ul>
</li></ul>
</li>
<li>
<a href=#%e9%99%84%e5%bd%95 aria-label=附录>附录</a><ul>
<li>
<a href=#1-pytype_type-%e6%9e%84%e9%80%a0 aria-label="1 PyType_Type 构造">1 PyType_Type 构造</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h1 id=python-源码学习1类型和对象>Python 源码学习（1）：类型和对象<a hidden class=anchor aria-hidden=true href=#python-源码学习1类型和对象>#</a></h1>
<p>Python 是一门解释型，动态类型，多范式的编程语言，当我们从 <a href=https://www.python.org/>python.org</a> 下载并安装运行 Python 的某个分发版本时，我们实际上是在运行由 C 语言编写的 <a href=https://github.com/python/cpython>CPython</a>，除此之外 Python 的运行时还有 Jython, PyPy, Cython 等；CPython 的源码中有一系列的库，组件和工具：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ git clone https://github.com/python/cpython
$ tree -d -L <span style=color:#ae81ff>2</span> .
.
<span style=color:#e6db74>`</span>-- cpython
    |-- Doc			<span style=color:#75715e># 文档</span>
    |-- Grammar
    |-- Include 	<span style=color:#75715e># C 头文件</span>
    |-- Lib			<span style=color:#75715e># 用 Python 写的库文件</span>
    |-- Mac			<span style=color:#75715e># 用于在 macOS 上构建的文件</span>
    |-- Misc		<span style=color:#75715e># 杂项</span>
    |-- Modules		<span style=color:#75715e># 用 C 写的库文件</span>
    |-- Objects 	<span style=color:#75715e># 核心类型，以及对象模型的定义</span>
    |-- PC			<span style=color:#75715e># 用于在 Windows 上构建的文件</span>
    |-- PCbuild 	<span style=color:#75715e># 用于在老版本的 Windows 上构建的文件</span>
    |-- Parser		<span style=color:#75715e># Python 解析器源码</span>
    |-- Programs	<span style=color:#75715e># Python 可执行文件和其他</span>
    |-- Python		<span style=color:#75715e># CPython 编译器源码</span>
    |-- Tools		<span style=color:#75715e># 构建时的工具</span>
    <span style=color:#e6db74>`</span>-- m4

<span style=color:#ae81ff>16</span> directories
</code></pre></div><p>本系列主要以阅读和分析 CPython 源码的方式学习 Python。</p>
<h2 id=1-对象模型>1 对象模型<a hidden class=anchor aria-hidden=true href=#1-对象模型>#</a></h2>
<p>Python 是一门面向对象的语言，我们可以使用 Python 中的 <code>type()</code> 函数查看一个对象所属的类：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>&gt;&gt;&gt; type<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span>
&lt;class <span style=color:#e6db74>&#39;int&#39;</span>&gt;
&gt;&gt;&gt; type<span style=color:#f92672>(</span>True<span style=color:#f92672>)</span>
&lt;class <span style=color:#e6db74>&#39;bool&#39;</span>&gt;
</code></pre></div><p>可以看到整数对象和布尔值对象的类型分别是 <code>&lt;class 'int'></code> 和 <code>&lt;class 'bool'></code>；</p>
<p>而实际上，在 Python 中无论是整数，布尔值还是基本数据类型，甚至自定义的 class，都是对象：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Foo</span>:
    <span style=color:#66d9ef>pass</span>

print(type(int))
print(type(Foo))
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>&lt;class <span style=color:#e6db74>&#39;type&#39;</span>&gt;
&lt;class <span style=color:#e6db74>&#39;type&#39;</span>&gt;
</code></pre></div><p>可以看到 <code>int</code> 类型和自定义类 <code>Foo</code> 的类型都是 <code>&lt;class 'type'></code>，它们是 <code>type</code> 这个类的实例对象；<code>type</code> 类型是专门用于定义类型的类型，也称为<strong>元类型</strong>；实际上， <code>type</code> 这个类型本身也是一个对象，它所属的类也是 <code>type</code>：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>&gt;&gt;&gt; type<span style=color:#f92672>(</span>type<span style=color:#f92672>)</span> 
&lt;class <span style=color:#e6db74>&#39;type&#39;</span>&gt;
</code></pre></div><p>同时，Python 中的所有类型，无论是 <code>int</code>, <code>type</code>, 还是自定义类 <code>Foo</code> 都是继承自一个叫 <code>object</code> 的基类，而 <code>object</code> 则是继承链的终点：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>&gt;&gt;&gt; int.__base__
&lt;class <span style=color:#e6db74>&#39;object&#39;</span>&gt;
&gt;&gt;&gt; type.__base__
&lt;class <span style=color:#e6db74>&#39;object&#39;</span>&gt;
&gt;&gt;&gt; print<span style=color:#f92672>(</span>Foo.__base__<span style=color:#f92672>)</span>
&lt;class <span style=color:#e6db74>&#39;object&#39;</span>&gt;
&gt;&gt;&gt; print<span style=color:#f92672>(</span>object.__base__<span style=color:#f92672>)</span>
None
</code></pre></div><p>而 <code>object</code> 基类也是一个 <code>type</code> 类型的对象：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>&gt;&gt;&gt; type<span style=color:#f92672>(</span>object<span style=color:#f92672>)</span>
&lt;class <span style=color:#e6db74>&#39;type&#39;</span>&gt;
</code></pre></div><p>上面的关系用图表达出来则是：</p>
<p><img loading=lazy src=https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/python/type-0.png alt=process>
</p>
<p>可以看到，所有类型的基类都是 <code>object</code>，所有类型的类型都是 <code>type</code>，这就是 Python 的<strong>对象模型</strong>（object model），也是 Objects/ 目录下源码所包含的内容。</p>
<h2 id=2-核心类型与对象>2 核心类型与对象<a hidden class=anchor aria-hidden=true href=#2-核心类型与对象>#</a></h2>
<p>虽然在 Python 的语法层面有非常多所谓的类型（包括 <code>int</code>, <code>type</code>, <code>Foo</code> 等），但实际上它们在源码（C 语言）层面上都是结构体对象。</p>
<h3 id=21-对象>2.1 对象<a hidden class=anchor aria-hidden=true href=#21-对象>#</a></h3>
<h4 id=pyobject>PyObject<a hidden class=anchor aria-hidden=true href=#pyobject>#</a></h4>
<p>Python 中所有的类型都由 <strong><code>PyObject</code></strong> 结构体扩展而来，这个结构体中有以下几个成员变量：</p>
<ol>
<li><code>Py_ssize_t ob_refcnt</code> 用于保存对象的<strong>引用计数</strong>；</li>
<li><code>PyTypeObject *ob_type</code> 指向对象的<strong>类型对象</strong>，用来标识对象属于的类型，并存储类型的<strong>元数据</strong>；</li>
<li><code>_PyObject_HEAD_EXTRA</code> 宏代表了两个 <code>PyObject*</code> 双向链表的指针，用于把堆上的所有对象链接起来，只会在开启了 <code>Py_TRACE_REFS</code> 宏的时候进行构造，方便调试；</li>
</ol>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// Include/object.h
</span><span style=color:#75715e></span>
<span style=color:#75715e>/* Define pointers to support a doubly-linked list of all live heap objects. */</span>
<span style=color:#75715e>#define _PyObject_HEAD_EXTRA            \
</span><span style=color:#75715e>    struct _object *_ob_next;           \
</span><span style=color:#75715e>    struct _object *_ob_prev;
</span><span style=color:#75715e></span>
<span style=color:#75715e>/* Nothing is actually declared to be a PyObject, but every pointer to
</span><span style=color:#75715e> * a Python object can be cast to a PyObject*.  This is inheritance built
</span><span style=color:#75715e> * by hand.  Similarly every pointer to a variable-size Python object can,
</span><span style=color:#75715e> * in addition, be cast to PyVarObject*.
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> _object {
    _PyObject_HEAD_EXTRA	<span style=color:#75715e>// 双向链表，用于追踪堆中所有对象，在开启了 Py_TRACE_REFS 宏的时候有用
</span><span style=color:#75715e></span>    Py_ssize_t ob_refcnt;	<span style=color:#75715e>// 引用计数，用于垃圾回收
</span><span style=color:#75715e></span>    PyTypeObject <span style=color:#f92672>*</span>ob_type;	<span style=color:#75715e>// 指针，指向当前对象的类型对象，用于查询对象的类型
</span><span style=color:#75715e></span>} PyObject;
</code></pre></div><h4 id=pyvarobject>PyVarObject<a hidden class=anchor aria-hidden=true href=#pyvarobject>#</a></h4>
<p>Python 中有可以自由修改长度的 <code>PyVarObject</code> 变长对象，它由一个 <code>PyObject</code> 对象和一个存储变长部分的长度（元素个数）的变量 <code>ob_size</code> 组成：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> {
    PyObject ob_base;
    Py_ssize_t ob_size; <span style=color:#75715e>/* Number of items in variable part */</span>
} PyVarObject;
</code></pre></div><p><code>PyObject</code> 和 <code>PyVarObject</code> 一般是作为头部被包含在一个变量结构体中的，根据该变量大小是否固定来选择使用哪一种：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// Include/object.h
</span><span style=color:#75715e></span><span style=color:#75715e>/* PyObject_HEAD defines the initial segment of every PyObject. */</span>
<span style=color:#75715e>#define PyObject_HEAD          PyObject ob_base;
</span><span style=color:#75715e></span>
<span style=color:#75715e>/* PyObject_VAR_HEAD defines the initial segment of all variable-size
</span><span style=color:#75715e> * container objects.  These end with a declaration of an array with 1
</span><span style=color:#75715e> * element, but enough space is malloc&#39;ed so that the array actually
</span><span style=color:#75715e> * has room for ob_size elements.  Note that ob_size is an element count,
</span><span style=color:#75715e> * not necessarily a byte count.
</span><span style=color:#75715e> */</span>
<span style=color:#75715e>#define PyObject_VAR_HEAD      PyVarObject ob_base;
</span></code></pre></div><p>Python 中最典型的变长对象就是列表 List，它和 <code>std::vector</code> 比较类似，列表对象里有三个成员变量，包括：</p>
<ul>
<li>基础的变长对象 <code>PyVarObject ob_base</code>，其中 <code>ob_base.ob_size</code> 用于表示列表当前的元素个数；</li>
<li>指向动态数组的指针 <code>PyObject **ob_item</code>；</li>
<li>动态数组当前的容量 <code>Py_ssize_t allocated</code>：</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// Inlucde/cpython/listobject.h
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> {
    PyObject_VAR_HEAD
    <span style=color:#75715e>/* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */</span>
    PyObject <span style=color:#f92672>**</span>ob_item;

    <span style=color:#75715e>/* ob_item contains space for &#39;allocated&#39; elements.  The number
</span><span style=color:#75715e>     * currently in use is ob_size.
</span><span style=color:#75715e>     * Invariants:
</span><span style=color:#75715e>     *     0 &lt;= ob_size &lt;= allocated
</span><span style=color:#75715e>     *     len(list) == ob_size
</span><span style=color:#75715e>     *     ob_item == NULL implies ob_size == allocated == 0
</span><span style=color:#75715e>     * list.sort() temporarily sets allocated to -1 to detect mutations.
</span><span style=color:#75715e>     *
</span><span style=color:#75715e>     * Items must normally not be NULL, except during construction when
</span><span style=color:#75715e>     * the list is not yet visible outside the function that builds it.
</span><span style=color:#75715e>     */</span>
    Py_ssize_t allocated;
} PyListObject;
</code></pre></div><h3 id=22-类型>2.2 类型<a hidden class=anchor aria-hidden=true href=#22-类型>#</a></h3>
<h4 id=pytypeobject>PyTypeObject<a hidden class=anchor aria-hidden=true href=#pytypeobject>#</a></h4>
<p><code>PyObject</code> 类中的 <code>PyTypeObject *ob_type</code> 是一个指向<strong>对象类型</strong>的指针，它是<strong>类</strong>在 Python 中的表现形式；<code>PyTypeObject</code> 不仅决定了 <code>PyObject</code> 对象属于什么类型，还包含了非常多的<strong>元数据</strong>，例如：</p>
<ol>
<li><code>PyObject_VAR_HEAD</code> 表示 <code>PyTypeObject</code> 本身是一个<strong>变长对象</strong>；</li>
<li><code>const char *tp_name</code> 表示类型的名字；</li>
<li><code>struct _typeobject *tp_base</code> 是指向基类的指针，保存类型的继承信息；</li>
<li><code>Py_ssize_t tp_basicsize, tp_itemsize</code> 表示创建实力对象时分配的内存大小；</li>
<li><code>setattrfunc tp_setattr</code> 设置值，<code>getattrfunc tp_getattr</code> 获取值，<code>destructor tp_dealloc</code> 析构，<code>hashfunc tp_hash</code> 哈希等函数指针表示该类型所支持的标准操作；</li>
</ol>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// Include/object.h
</span><span style=color:#75715e></span>
<span style=color:#75715e>/* PyTypeObject structure is defined in cpython/object.h.
</span><span style=color:#75715e>   In Py_LIMITED_API, PyTypeObject is an opaque structure. */</span>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> _typeobject PyTypeObject;

<span style=color:#75715e>// Include/cpython/object.h
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> _typeobject {
    PyObject_VAR_HEAD <span style=color:#75715e>// 即 PyVarObject ob_base;
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>tp_name; <span style=color:#75715e>/* For printing, in format &#34;&lt;module&gt;.&lt;name&gt;&#34; */</span>
    Py_ssize_t tp_basicsize, tp_itemsize; <span style=color:#75715e>/* For allocation */</span>

    <span style=color:#75715e>/* Methods to implement standard operations */</span>

    destructor tp_dealloc;
    Py_ssize_t tp_vectorcall_offset;
    getattrfunc tp_getattr;
    setattrfunc tp_setattr;
    PyAsyncMethods <span style=color:#f92672>*</span>tp_as_async; <span style=color:#75715e>/* formerly known as tp_compare (Python 2)
</span><span style=color:#75715e>                                    or tp_reserved (Python 3) */</span>

    <span style=color:#75715e>// Strong reference on a heap type, borrowed reference on a static type
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> _typeobject <span style=color:#f92672>*</span>tp_base;
    
    <span style=color:#75715e>/* More standard operations (here for binary compatibility) */</span>
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>};
</code></pre></div><p>Python 中的每一种<strong>类型对象</strong>都是<strong>全局唯一</strong>的，他们在源码中以<strong>全局变量</strong>的形式存在，例如 <code>int</code> 类型：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// Objects/longobject.c
</span><span style=color:#75715e></span>PyTypeObject PyLong_Type <span style=color:#f92672>=</span> {
    PyVarObject_HEAD_INIT(<span style=color:#f92672>&amp;</span>PyType_Type, <span style=color:#ae81ff>0</span>)
    <span style=color:#e6db74>&#34;int&#34;</span>,                                      <span style=color:#75715e>/* tp_name */</span>
    offsetof(PyLongObject, ob_digit),           <span style=color:#75715e>/* tp_basicsize */</span>
    <span style=color:#66d9ef>sizeof</span>(digit),                              <span style=color:#75715e>/* tp_itemsize */</span>
    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_dealloc */</span>
    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_vectorcall_offset */</span>
    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_getattr */</span>
    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_setattr */</span>
    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_as_async */</span>
    long_to_decimal_string,                     <span style=color:#75715e>/* tp_repr */</span>
    <span style=color:#f92672>&amp;</span>long_as_number,                            <span style=color:#75715e>/* tp_as_number */</span>
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>};
</code></pre></div><p><code>PyVarObject_HEAD_INIT</code> 宏用于初始化 <code>PyVarObject</code> 中的 <code>ob_refcnt</code>, <code>ob_type</code> 和 <code>ob_size</code>：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>#define PyObject_HEAD_INIT(type)        \
</span><span style=color:#75715e>    { 1, type },
</span><span style=color:#75715e></span>
<span style=color:#75715e>#define PyVarObject_HEAD_INIT(type, size)       \
</span><span style=color:#75715e>    { PyObject_HEAD_INIT(type) size },
</span><span style=color:#75715e></span>
</code></pre></div><p>可以看到在 <code>PyLong_Type</code> 中，<code>ob_type</code> 被初始化为 <code>&PyType_Type</code>，它是专门用于<strong>定义类型对象的类型</strong>，抑或叫做<strong>类型的类型</strong>或<strong>原类型</strong>。</p>
<h4 id=pytype_type>PyType_Type<a hidden class=anchor aria-hidden=true href=#pytype_type>#</a></h4>
<p>在前面已经了解到，<code>type</code> <strong>类型对象</strong>所属的类也是 <code>type</code>，那么<strong>类型对象</strong> <code>PyTypeObject</code> 本身也是一个类对象，它也拥有指向其<strong>类型对象</strong>的指针 <code>PyTypeObject *ob_type</code>；对于<strong>类型对象</strong>本身来说，它的<strong>类型对象</strong>都基于一个叫做 <code>PyType_Type</code>（即<strong>元类型</strong>）的 <code>PyTypeObject</code> 类对象：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// Objects/typeobject.c
</span><span style=color:#75715e></span>PyTypeObject PyType_Type <span style=color:#f92672>=</span> {
    PyVarObject_HEAD_INIT(<span style=color:#f92672>&amp;</span>PyType_Type, <span style=color:#ae81ff>0</span>)		<span style=color:#75715e>// PyType_Type 在初始化的时候将指向自身的指针传递并用于构造了一个 PyVarObject 类型的对象 ob_base，其中 ob_base-&gt;ob_type = &amp;PyType_Type，参考附录 1
</span><span style=color:#75715e></span>    <span style=color:#e6db74>&#34;type&#34;</span>,                                     <span style=color:#75715e>/* tp_name */</span>
    <span style=color:#66d9ef>sizeof</span>(PyHeapTypeObject),                   <span style=color:#75715e>/* tp_basicsize */</span>
    <span style=color:#66d9ef>sizeof</span>(PyMemberDef),                        <span style=color:#75715e>/* tp_itemsize */</span>
    (destructor)type_dealloc,                   <span style=color:#75715e>/* tp_dealloc */</span>
    offsetof(PyTypeObject, tp_vectorcall),      <span style=color:#75715e>/* tp_vectorcall_offset */</span>
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>};
</code></pre></div><p>Python 中<strong>类型对象</strong>都定义在了 Objects/ 目录下，例如 <code>bool</code> 类型：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// Objects/boolobject.c
</span><span style=color:#75715e></span>
<span style=color:#75715e>/* The type object for bool.  Note that this cannot be subclassed! */</span>

PyTypeObject PyBool_Type <span style=color:#f92672>=</span> {
    PyVarObject_HEAD_INIT(<span style=color:#f92672>&amp;</span>PyType_Type, <span style=color:#ae81ff>0</span>)		<span style=color:#75715e>// 同 PyType_Type，ob_base-&gt;ob_type = &amp;PyType_Type
</span><span style=color:#75715e></span>    <span style=color:#e6db74>&#34;bool&#34;</span>,										<span style=color:#75715e>// tp_name = &#34;bool&#34;
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>_longobject</span>),					<span style=color:#75715e>/* tp_basicsize */</span>
    <span style=color:#ae81ff>0</span>,											<span style=color:#75715e>/* tp_itemsize */</span>
    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_dealloc */</span>
    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_vectorcall_offset */</span>
    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_getattr */</span>
    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_setattr */</span>
    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_as_async */</span>
    bool_repr,                                  <span style=color:#75715e>/* tp_repr */</span>
    <span style=color:#f92672>&amp;</span>bool_as_number,                            <span style=color:#75715e>/* tp_as_number */</span>
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_base */</span>
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>};
</code></pre></div><p>在 Python 中，无论是内建类型（<code>int</code>, <code>bool</code> 等），还是自定义类型（<code>Foo</code>），都是通过 <code>PyTypeObject</code> 这个结构体构造的，且一定满足 <code>ob_base->ob_type = &PyType_Type</code>。</p>
<p>前文提到 <code>tp_base</code> 是指向基类的指针，保存类型的继承信息，但实际上在定义 <code>PyBool_Type</code> 的时候可以看到 <code>tp_base = 0</code>，实际上这个 <code>tp_base</code> 是在 <code>PyType_Ready</code> 函数中被赋值为 <code>PyBaseObject_Type</code> 的：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// Objects/typeobject.c
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span>
<span style=color:#a6e22e>PyType_Ready</span>(PyTypeObject <span style=color:#f92672>*</span>type)
{
    PyTypeObject <span style=color:#f92672>*</span>base;
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>	<span style=color:#75715e>/* Initialize tp_base (defaults to BaseObject unless that&#39;s us) */</span>
    base <span style=color:#f92672>=</span> type<span style=color:#f92672>-&gt;</span>tp_base;
    <span style=color:#66d9ef>if</span> (base <span style=color:#f92672>==</span> NULL <span style=color:#f92672>&amp;&amp;</span> type <span style=color:#f92672>!=</span> <span style=color:#f92672>&amp;</span>PyBaseObject_Type) {
        base <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>PyBaseObject_Type;
        <span style=color:#66d9ef>if</span> (type<span style=color:#f92672>-&gt;</span>tp_flags <span style=color:#f92672>&amp;</span> Py_TPFLAGS_HEAPTYPE) {
            type<span style=color:#f92672>-&gt;</span>tp_base <span style=color:#f92672>=</span> (PyTypeObject<span style=color:#f92672>*</span>)Py_NewRef((PyObject<span style=color:#f92672>*</span>)base);
        }
        <span style=color:#66d9ef>else</span> {
            type<span style=color:#f92672>-&gt;</span>tp_base <span style=color:#f92672>=</span> base;
        }
    }
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>}
</code></pre></div><p>这里 <code>PyTypeObject *base</code> 被赋值为的 <code>PyBaseObject_Type</code> 就是前文提到的<strong>基类型</strong>。</p>
<h4 id=pybaseobject_type>PyBaseObject_Type<a hidden class=anchor aria-hidden=true href=#pybaseobject_type>#</a></h4>
<p><code>PyBaseObject_Type</code> 定义在 typeobject.c 文件中：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// Objects/typeobject.c
</span><span style=color:#75715e></span>PyTypeObject PyBaseObject_Type <span style=color:#f92672>=</span> {
    PyVarObject_HEAD_INIT(<span style=color:#f92672>&amp;</span>PyType_Type, <span style=color:#ae81ff>0</span>)		<span style=color:#75715e>// 同 PyType_Type，ob_base-&gt;ob_type = &amp;PyType_Type
</span><span style=color:#75715e></span>    <span style=color:#e6db74>&#34;object&#34;</span>,                                   <span style=color:#75715e>/* tp_name */</span>
    <span style=color:#66d9ef>sizeof</span>(PyObject),                           <span style=color:#75715e>/* tp_basicsize */</span>
    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_itemsize */</span>
    object_dealloc,                             <span style=color:#75715e>/* tp_dealloc */</span>
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    object_repr,                                <span style=color:#75715e>/* tp_repr */</span>
	<span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    <span style=color:#ae81ff>0</span>,                                          <span style=color:#75715e>/* tp_base */</span>
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>};
</code></pre></div><p>可以看到无论是 <code>PyBool_Type</code>，<code>PyType_Type</code> 还是 <code>PyBaseObject_Type</code>，都有两个共同点：</p>
<ol>
<li>它们是以同样的方式 <code>PyVarObject_HEAD_INIT(&PyType_Type, 0)</code> 定义其类型的，因此它们的类型都是 <code>PyTypeObject</code>；</li>
<li>它们指向基类的指针 <code>tp_base</code> 初始化时都是 NULL；</li>
</ol>
<p>不同的地方是，在使用 <code>PyType_Ready</code> 函数为它们的基类指针 <code>tp_base</code> 赋值时，只有 <code>PyBaseObject_Type.tp_base</code> 不会被赋值，其他的 <code>tp_base</code> 则都会被赋值为 <code>PyBaseObject_Type</code>，这也印证了 <code>PyBaseObject_Type</code> 是继承链的终点。</p>
<p>我们可以将上面的关系整理为一个图：</p>
<p><img loading=lazy src=https://raw.githubusercontent.com/ZintrulCre/warehouse/master/resources/python/type-1.png alt=process>
</p>
<h2 id=附录>附录<a hidden class=anchor aria-hidden=true href=#附录>#</a></h2>
<h3 id=1-pytype_type-构造>1 PyType_Type 构造<a hidden class=anchor aria-hidden=true href=#1-pytype_type-构造>#</a></h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Bar</span>;

<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Foo</span>
{
	Bar<span style=color:#f92672>*</span> p_b;
	<span style=color:#66d9ef>int</span> ref_count;
};

<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Bar</span>
{
	Foo f;
	<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> name;
};

Bar b
{
	Foo{ <span style=color:#f92672>&amp;</span>b, <span style=color:#ae81ff>1</span> },
	<span style=color:#e6db74>&#34;ClassBar&#34;</span>
};

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
{
	printf(<span style=color:#e6db74>&#34;%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, b.f.p_b<span style=color:#f92672>-&gt;</span>name);
	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ ./test
ClassBar
</code></pre></div>
</div>
<footer class=post-footer>
<nav class=paginav>
<a class=prev href=http://zintrulcre.github.io/posts/python/source-code-2/>
<span class=title>« Prev Page</span>
<br>
<span>Python 源码学习（2）：int 类型</span>
</a>
<a class=next href=http://zintrulcre.github.io/posts/c++/smart-pointer/smart-pointer/>
<span class=title>Next Page »</span>
<br>
<span>C++ 智能指针的简单实现</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>
Zhengyu &copy; 2022
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>