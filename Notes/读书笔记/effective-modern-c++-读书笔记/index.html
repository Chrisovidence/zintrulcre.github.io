<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Zhengyu Chen">
    <meta name="description" content="ZintrulCre @ 尾張">
    <meta name="keywords" content="ZintrulCre, 尾張">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="Effective Modern C&#43;&#43; 读书笔记 [TOC] 1. 类型推导 1. 理解模板类型推导 template&lt;typename T&gt; void f(ParamType param); f(expr); T 的类型推导同时依赖于 expr 和 ParamType 的形式，分三种情况： ParamType 是指针或引用类型，但不是万能引用 如"/>

    <meta property="og:title" content="" />
<meta property="og:description" content="Effective Modern C&#43;&#43; 读书笔记 [TOC] 1. 类型推导 1. 理解模板类型推导 template&lt;typename T&gt; void f(ParamType param); f(expr); T 的类型推导同时依赖于 expr 和 ParamType 的形式，分三种情况： ParamType 是指针或引用类型，但不是万能引用 如" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zintrulcre.vip/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/effective-modern-c&#43;&#43;-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" />



    
      <base href="https://zintrulcre.vip/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/effective-modern-c&#43;&#43;-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">
    
    <title>
   · 尾張
</title>

    
      <link rel="canonical" href="https://zintrulcre.vip/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/effective-modern-c&#43;&#43;-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="https://zintrulcre.vip/css/coder.min.28d751104f30c16da1aa1bb04015cbe662cacfe0d1b01af4f2240ad58580069c.css" integrity="sha256-KNdREE8wwW2hqhuwQBXL5mLKz&#43;DRsBr08iQK1YWABpw=" crossorigin="anonymous" media="screen" />
    

    

    

    

    <link rel="icon" type="image/png" href="https://zintrulcre.vip/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://zintrulcre.vip/images/favicon-16x16.png" sizes="16x16">

    <meta name="generator" content="Hugo 0.74.3" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://zintrulcre.vip">
      尾張
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://zintrulcre.vip/posts/">Posts</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://zintrulcre.vip/about/">About</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container page">
  <article>
    <header>
      <h1></h1>
    </header>

    <h1 id="effective-modern-c-读书笔记">Effective Modern C++ 读书笔记</h1>
<p>[TOC]</p>
<h2 id="1-类型推导">1. 类型推导</h2>
<h3 id="1-理解模板类型推导">1. 理解模板类型推导</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">template</span>&lt;<span style="color:#fff;font-weight:bold">typename</span> T&gt;
<span style="color:#fff;font-weight:bold">void</span> f(ParamType param);

f(expr);
</code></pre></div><p>T 的类型推导同时依赖于 expr 和 ParamType 的形式，分三种情况：</p>
<ol>
<li>
<p>ParamType 是指针或引用类型，但不是万能引用</p>
<ul>
<li>如果 expr 是引用类型，先将引用部分忽略掉，然后对 expr 和 ParamType 的类型执行模式匹配，来决定 T 的类型</li>
</ul>
</li>
<li>
<p>ParamType 是万能引用</p>
<ul>
<li>万能引用是指在模板函数中，有一个模板参数 T，那么 T&amp;&amp; 就是万能引用/通用引用</li>
</ul>
</li>
<li>
<p>ParamType 既非指针也非引用</p>
<ul>
<li>通过 pass-by-value 的方式处理，param 会成为一个全新的拷贝</li>
<li>const 和 volatile 等关键字都会被忽略，因为 param 是一个拷贝，而不是原本的变量 expr</li>
</ul>
</li>
</ol>
<h3 id="2-理解-auto-自动类型推导">2. 理解 auto 自动类型推导</h3>
<p>在 C++ 11 中，decltype 最主要的用途就是用于获取函数模板返回类型。</p>
<p>对一个 T 类型的容器使用 operator[]，通常会返回一个 T&amp; 对象，但对于 std::vector&lt;bool&gt;，operator[] 不会返回 bool&amp;，它会返回一个有名字的对象类型。</p>
<h3 id="3">3.</h3>
<h3 id="4-查看推导类型">4. 查看推导类型</h3>
<p>运行时输出 std::type_info::name：<code>std::cout &lt;&lt; typeid(x).name() &lt;&lt; '\n';</code></p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">template</span>&lt;<span style="color:#fff;font-weight:bold">typename</span> T&gt;
<span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> PrintType(<span style="color:#fff;font-weight:bold">const</span> T &amp;t)
{
    std::cout &lt;&lt; <span style="color:#fff;font-weight:bold">typeid</span>(T).name() &lt;&lt; std::endl;
    std::cout &lt;&lt; <span style="color:#fff;font-weight:bold">typeid</span>(t).name() &lt;&lt; std::endl;
}

<span style="color:#fff;font-weight:bold">int</span> main()
{
    PrintType(<span style="color:#ff0;font-weight:bold">1</span>);
}
</code></pre></div><div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">[joelzychen@DevCloud ~/test]$ clang++ -std=c++11 -otest joelzychen_test.cpp 
[joelzychen@DevCloud ~/test]$ ./test 
i
i
</code></pre></div><p>结果并不可靠，T 的类型是 int，但 t 的类型应该是 const int&amp;。</p>
<h2 id="2-auto">2. auto</h2>
<h3 id="5-优先使用-auto-而不是显式类型声明">5. 优先使用 auto 而不是显式类型声明</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">std::function 是 C++11 标准模板库中的一个模板，它泛化了函数指针的概念；与函数指针只能指向函数不同，std::function 可以指向任何可调用对象，也就是那些像函数一样能进行调用的东西。
当你声明函数指针时你必须指定函数签名，同样当你创建 std::function 对象时你也需要提供函数签名，例如
bool(const std::unique_ptr&lt;Widget&gt; &amp;p1, const std::unique_ptr&lt;Widget&gt; &amp;p2);
对应的 std::function 类型的签名是
std::function&lt;bool(const std::unique_ptr&lt;Widget&gt; &amp;p1,
const std::unique_ptr&lt;Widget&gt; &amp;p2)&gt; func;
</code></pre></div><h3 id="7-创建对象时区分--和">7. 创建对象时区分 () 和</h3>
<h3 id="9">9.</h3>
<p>对于通过 typedef 定义的变量名，在模板中需要用 typename 前缀来修饰，例如</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">template</span> &lt;<span style="color:#fff;font-weight:bold">typename</span> T&gt;
<span style="color:#fff;font-weight:bold">class</span> Widget
{
    <span style="color:#fff;font-weight:bold">typename</span> Vec&lt;T&gt;::type vec;
};

<span style="color:#fff;font-weight:bold">template</span> &lt;<span style="color:#fff;font-weight:bold">typename</span> T&gt;
<span style="color:#fff;font-weight:bold">using</span> Widget_t = <span style="color:#fff;font-weight:bold">typename</span> Widget&lt;T&gt;::type;
</code></pre></div><h3 id="10-优先考虑限域枚举">10. 优先考虑限域枚举</h3>
<p>通常来说，在大括号中声明的名字的作用域会被限制在大括号之内，而枚举类型却拥有与定义它们的 enum 相同的作用域，这叫做未限域枚举 unscoped enum。C++ 11 中新增了限域枚举 scoped enum，它不会导致枚举名泄露，例如：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">enum</span> <span style="color:#fff;font-weight:bold">class</span> Color : <span style="color:#fff;font-weight:bold">uint8_t</span> { <span style="color:#007f7f">// 为限域枚举指定基础类型，默认是 int
</span><span style="color:#007f7f"></span>    red = <span style="color:#ff0;font-weight:bold">0</span>,
    green = <span style="color:#ff0;font-weight:bold">1</span>,
    blue = <span style="color:#ff0;font-weight:bold">0xff</span>
};
</code></pre></div><p>使用限域枚举的好处：</p>
<ol>
<li>减少命名空间污染</li>
<li>限域枚举的枚举名是强类型，而未限域枚举的枚举名会隐式转换为整型</li>
<li>限域枚举可以前置</li>
</ol>
<h3 id="11-使用-deleted-函数替代未定义的-private-成员函数">11. 使用 deleted 函数替代未定义的 private 成员函数</h3>
<p>防止函数被调用的方法：</p>
<ol>
<li>将函数声明为私有成员，可以防止其被外部调用，但仍可以被其他成员函数或友元函数调用</li>
<li>只声明而不定义函数，如果它们被调用就会在<strong>链接时</strong>引发缺少函数定义 missing function definitions 的错误</li>
<li>C++ 11 中，使用 = delete 将函数标记为 deleted 函数，调用 deleted 函数将不能通过<strong>编译</strong></li>
</ol>
<p>C++ 中一般有三类指针：</p>
<ol>
<li>void* 指针，无法直接解引用，或者进行自增自减操作</li>
<li>char* 指针，一般代表 C 风格的字符串</li>
<li>其他指针</li>
</ol>
<p>delete 的优势：</p>
<ol>
<li>将 deleted 函数声明为 public 成员可以让编译器生成正确的编译报错，而不是产生因非 public 而导致的报错</li>
<li>任何函数都可以被声明为 deleted 函数，而 private 只能修饰成员函数</li>
</ol>
<h3 id="12-使用-override-修饰重载函数">12. 使用 override 修饰重载函数</h3>
<h3 id="13-使用-const_iterator-替代-iterator">13. 使用 const_iterator 替代 iterator</h3>
<p>STL::const_iterator 是指向常量的迭代器指针。</p>
<h3 id="14-使用-noexcept-修饰不抛出异常的函数">14. 使用 noexcept 修饰不抛出异常的函数</h3>
<p><code>noexcept</code>保证函数不会抛出任何异常。</p>
<p>表明函数不抛异常的方法有两种：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#fff;font-weight:bold">void</span> Func() <span style="color:#fff;font-weight:bold">throw</span>(); <span style="color:#007f7f">// C++98 风格
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">void</span> Func() <span style="color:#fff;font-weight:bold">noexcept</span>; <span style="color:#007f7f">// C++11 风格，优化更好
</span></code></pre></div><h3 id="15-尽可能使用-constexpr">15. 尽可能使用 constexpr</h3>
<p><code>constexpr</code>表示一个值不仅是常量，且它是编译期可知的。</p>
<h3 id="16-保证-const-成员函数线程安全">16. 保证 const 成员函数线程安全</h3>
<h3 id="17-理解特殊成员函数的生成">17. 理解特殊成员函数的生成</h3>
<p>C++98 中特殊成员函数包含四个，这些函数仅在需要的时候被生成，它们都具有 public 访问层级，且都是 inline 的：</p>
<ol>
<li>
<p>默认构造函数</p>
<ul>
<li>当类里没有声明任何构造函数的时候，编译器会生成默认构造函数</li>
</ul>
</li>
<li>
<p>析构函数</p>
<ul>
<li>在 C++ 11 中默认是 noexcept 的</li>
<li>当类是继承自某个含有虚函数的类时，编译器生成的析构函数也是虚函数</li>
</ul>
</li>
<li>
<p>拷贝构造函数</p>
</li>
<li>
<p>拷贝赋值操作符</p>
</li>
</ol>
<p>在 C++11 中新增了两个特殊成员函数：</p>
<ol>
<li>
<p>移动构造函数：使用形参 rhs 的各个非静态成员对自身的成员进行移动构造</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">Widget(Widget &amp;&amp;rhs);
</code></pre></div></li>
<li>
<p>移动赋值操作符：使用形参 rhs 的各个非静态成员对自身的成员进行移动赋值</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">Widget &amp;<span style="color:#fff;font-weight:bold">operator</span>=(Widget &amp;&amp;rhs);
</code></pre></div></li>
</ol>
<p>移动操作并不一定会真的发生，对于不支持移动操作的成员，会执行拷贝操作；一旦声明了移动操作，编译器就会删除拷贝操作。</p>
<p>两个拷贝操作相互独立，而若生成了两个移动操作的其中一个，编译器就会阻止另一个的生成。</p>
<p>Rule of Three：如果声明了<strong>拷贝构造</strong>函数，<strong>拷贝赋值</strong>操作符，和<strong>析构函数</strong>中的任何一个，就应该同时声明另外两个，因为如果有改写拷贝操作的需求，往往意味着该类需要进行某些资源管理，也就是说：</p>
<ol>
<li>在一种拷贝操作中进行的资源管理，很有可能在另一种拷贝操作中也需要进行</li>
<li>析构函数也应该参与到资源管理中</li>
</ol>
<p>标准库中用于进行内存管理的类都遵从 Rule of Three。</p>
<p>在 C++ 11 中，只要用户声明了<strong>拷贝操作</strong>或<strong>析构函数</strong>就会阻止<strong>移动操作</strong>的生成，因此，移动操作的生成条件是：</p>
<ol>
<li>类中未声明<strong>拷贝操作</strong></li>
<li>类中未声明<strong>析构函数</strong></li>
<li>类中未声明其他<strong>移动操作</strong></li>
</ol>
<p>同样的，C++ 11 中，<strong>在已存在拷贝操作之一或析构函数的条件下，编译器自动生成其他拷贝操作</strong>的行为已经被废弃。如果需要，可以用 ”= default“ 来显式地表达出默认实现式正确的。</p>
<p>成员函数模板不会抑制特殊成员函数的生成。</p>
<h2 id="4-智能指针">4. 智能指针</h2>
<h3 id="18-使用-stdunique_ptr-管理具备专属所有权的资源">18. 使用 std::unique_ptr 管理具备专属所有权的资源</h3>
<p>可以为 std::unique_ptr 设置自定义析构器；在使用默认析构器的前提下，可以认为 std::unique_ptr 和裸指针的尺寸相同；而如果析构器是函数指针，那么其尺寸会增加一到两个字长；如果析构器是函数对象，则带来的尺寸变化取决于该函数对象中存储了多少状态；无状态的函数对象（例如无捕获的 lambda 表达式）不会浪费任何存储尺寸。</p>
<p>std::unique_ptr 有两种形式：</p>
<ol>
<li>std::unique_ptr&lt;T&gt; 单个对象，其对象种类不会产生二义性</li>
<li>std::unique_ptr&lt;T[]&gt; 数组，不提供提领操作符（* 和 -&gt;）；可以使用 std::vector，std::array，std::string 替代数组智能指针</li>
</ol>
<h3 id="21-优先使用-stdmake_unique-和-stdmake_shared-替代-new">21. 优先使用 std::make_unique 和 std::make_shared 替代 new</h3>
<h2 id="5-右值引用移动语义和完美转发">5. 右值引用，移动语义和完美转发</h2>
<h3 id="23-理解-stdmove-和-stdforward">23. 理解 std::move 和 std::forward</h3>
<h3 id="heading"></h3>

  </article>
</section>


      </div>

      <footer class="footer">
  <section class="container">
    
    
    
    
      
      <a href="https://github.com/luizdepra/hugo-coder/tree/"></a>
    
  </section>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
    </main>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-132809676-1', 'auto');
	
	ga('send', 'pageview');
}
</script>


  </body>

</html>
