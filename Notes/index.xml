<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Notes on 尾張</title>
    <link>https://zintrulcre.vip/notes/</link>
    <description>Recent content in Notes on 尾張</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    
	<atom:link href="https://zintrulcre.vip/notes/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://zintrulcre.vip/notes/c&#43;&#43;-core-guidelines-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zintrulcre.vip/notes/c&#43;&#43;-core-guidelines-%E7%AC%94%E8%AE%B0/</guid>
      <description>P.1: 直接在代码中表达想法 原因：编译器和许多程序员都不会阅读你的评论，或者设计文档。代码中的内容已经定义了语义，并且可以被编译器和其他工具检测。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zintrulcre.vip/notes/c&#43;&#43;-%E5%86%85%E5%AD%98%E6%B1%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zintrulcre.vip/notes/c&#43;&#43;-%E5%86%85%E5%AD%98%E6%B1%A0/</guid>
      <description>编译器内存管理 在编程的过程中需要大量的使用堆上的内存，例如维护一个链表时需要频繁的新增或删除节点，此时如果使用编译器自带的 new/malloc 和 delete/free 函数会有一定</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zintrulcre.vip/notes/c&#43;&#43;-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zintrulcre.vip/notes/c&#43;&#43;-%E7%AC%94%E8%AE%B0/</guid>
      <description>宏 #：将其后的宏参数进行字符串化操作（Stringfication），即在其左右各加上一个双引号 ##：连接符（concatenator），将</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zintrulcre.vip/notes/linux-%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zintrulcre.vip/notes/linux-%E6%8C%87%E4%BB%A4/</guid>
      <description>Linux 指令 压缩 tar cvf file.tar.gz file1 file2 &amp;hellip; 解压 tar xvf file.tar.gz</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zintrulcre.vip/notes/rtti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zintrulcre.vip/notes/rtti/</guid>
      <description>RTTI 即 Run-time type information（运行时类型信息），是一种允许在运行时确定对象类型的机制。 C++ 是一种静态强类型语言，即其数据类型在编译期就能够确</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zintrulcre.vip/notes/temp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zintrulcre.vip/notes/temp/</guid>
      <description>这是因为 string 本身是一个对 char* 的一个封装，在 string 头文件的源码中我们可以看到如下代码： using string = basic_string&amp;lt;char&amp;gt;; using u16string = basic_string&amp;lt;char16_t&amp;gt;; using u32string = basic_string&amp;lt;char32_t&amp;gt;; using wstring = basic_string&amp;lt;wchar_t&amp;gt;; string, u16string, u32string, wstring 这四种类型其实都是由模板</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zintrulcre.vip/notes/vs%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zintrulcre.vip/notes/vs%E6%8C%87%E4%BB%A4/</guid>
      <description>VS指令 在头文件和源文件之间跳转：Ctrl + k, Ctrl + O 在侧边栏搜索文件名：Ctrl + ;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zintrulcre.vip/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/effective-c&#43;&#43;-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zintrulcre.vip/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/effective-c&#43;&#43;-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <description>Effective C++ 读书笔记 [TOC] 0 导言 1 构造函数 default 构造函数：可被调用而不带任何实参的构造函数，这样的构造函数要不没有参数，要不每个参数都带有默认值，例如 class Bar {</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zintrulcre.vip/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/effective-modern-c&#43;&#43;-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zintrulcre.vip/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/effective-modern-c&#43;&#43;-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <description>Effective Modern C++ 读书笔记 [TOC] 1. 类型推导 1. 理解模板类型推导 template&amp;lt;typename T&amp;gt; void f(ParamType param); f(expr); T 的类型推导同时依赖于 expr 和 ParamType 的形式，分三种情况： ParamType 是指针或引用类型，但不是万能引用 如</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zintrulcre.vip/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%87%8D%E6%9E%84%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zintrulcre.vip/notes/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%87%8D%E6%9E%84%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <description>重构：改善既有代码的设计（第2版）笔记 基本概念 在给程序添加特性时，如果发现代码结构不易于更改，可以先重构再添加 每次做小步修改 提炼函数时移除局</description>
    </item>
    
  </channel>
</rss>