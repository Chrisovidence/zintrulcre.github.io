<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>尾張</title>
    <link>https://zintrulcre.vip/</link>
    <description>Recent content on 尾張</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Sun, 15 Mar 2020 17:24:27 +0800</lastBuildDate>
    
	<atom:link href="https://zintrulcre.vip/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>coverity 的 WRAPPER_ESCAPE 告警</title>
      <link>https://zintrulcre.vip/posts/c&#43;&#43;/%E5%9F%BA%E7%A1%80/wrapper_escape-in-coverity/</link>
      <pubDate>Sun, 15 Mar 2020 17:24:27 +0800</pubDate>
      
      <guid>https://zintrulcre.vip/posts/c&#43;&#43;/%E5%9F%BA%E7%A1%80/wrapper_escape-in-coverity/</guid>
      <description>coverity 的 WRAPPER_ESCAPE 告警 const char* Foo() { std::string str_msg(&amp;#34;test&amp;#34;); return str_msg.c_str(); } int main() { const char *p_msg = Foo(); printf(&amp;#34;%s\n&amp;#34;, p_msg); return 0; } // output:（为空，或乱码） D? 上面代码中的 Foo 函数会被 coverity 报告 WRAPPER_ESCA</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 协程（1）：函数和协程</title>
      <link>https://zintrulcre.vip/posts/c&#43;&#43;/%E5%8D%8F%E7%A8%8B/c&#43;&#43;-%E5%8D%8F%E7%A8%8B1%E5%87%BD%E6%95%B0%E5%92%8C%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Mon, 20 Jan 2020 20:15:05 +0800</pubDate>
      
      <guid>https://zintrulcre.vip/posts/c&#43;&#43;/%E5%8D%8F%E7%A8%8B/c&#43;&#43;-%E5%8D%8F%E7%A8%8B1%E5%87%BD%E6%95%B0%E5%92%8C%E5%8D%8F%E7%A8%8B/</guid>
      <description>C++ 协程（1）：函数和协程 这篇文章的目的是探究 C++ 中协程的机制和用法，以及怎样利用协程的特性来构建上层的库和应用。 1. 栈帧和函数 栈帧是一个函数执行</description>
    </item>
    
    <item>
      <title>LeetCode 树（3）</title>
      <link>https://zintrulcre.vip/posts/leetcode/tree-3/</link>
      <pubDate>Sat, 24 Aug 2019 19:12:25 +1000</pubDate>
      
      <guid>https://zintrulcre.vip/posts/leetcode/tree-3/</guid>
      <description>LeetCode 树（3） 题目 4. 递归求解 617 合并二叉树 合并两个二叉树。 判断各个节点是否存在，全部合并到一棵树上即可。 class Solution { public: TreeNode *mergeTrees(TreeNode *t1, TreeNode *t2) { if (!t1 &amp;amp;&amp;amp; !t2) return nullptr; else if (!t1) return t2;</description>
    </item>
    
    <item>
      <title>LeetCode 排序</title>
      <link>https://zintrulcre.vip/posts/leetcode/sort/</link>
      <pubDate>Sat, 17 Aug 2019 19:12:25 +1000</pubDate>
      
      <guid>https://zintrulcre.vip/posts/leetcode/sort/</guid>
      <description>LeetCode 排序 题目 56 合并区间 按照间隔的起始进行排序，判断下一个间隔的起始是否大于前一个间隔的末尾，如果大于的话就把之前的间隔加入结果数组，否则继续扩</description>
    </item>
    
    <item>
      <title>LeetCode 堆</title>
      <link>https://zintrulcre.vip/posts/leetcode/heap/</link>
      <pubDate>Mon, 05 Aug 2019 19:12:25 +1000</pubDate>
      
      <guid>https://zintrulcre.vip/posts/leetcode/heap/</guid>
      <description>LeetCode 堆 题目 215 数组中的第 K 个最大元素 最简单的堆的应用。 class Solution { public: int findKthLargest(vector&amp;lt;int&amp;gt; &amp;amp;nums, int k) { priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;&amp;gt;&amp;gt; heap; for (auto &amp;amp;m:nums) { if (heap.size() &amp;lt; k || m &amp;gt; heap.top()) heap.push(m); if (heap.size() &amp;gt; k) heap.pop(); } return heap.top(); } }; 347 前 K 个高频元素</description>
    </item>
    
    <item>
      <title>LeetCode 双指针</title>
      <link>https://zintrulcre.vip/posts/leetcode/twopointers/</link>
      <pubDate>Wed, 31 Jul 2019 19:12:25 +1000</pubDate>
      
      <guid>https://zintrulcre.vip/posts/leetcode/twopointers/</guid>
      <description>LeetCode DFS 题目 26 删除排序数组中的重复项 用两个指针 len 和 i 分别表示没有重复的项的下标与遍历数组的下标，将没有重复的项拷贝到 nums[len] 下然后 ++len 即可。 class Solution { public: int removeDuplicates(vector&amp;lt;int&amp;gt;&amp;amp;</description>
    </item>
    
    <item>
      <title>LeetCode 深度优先搜索</title>
      <link>https://zintrulcre.vip/posts/leetcode/dfs/</link>
      <pubDate>Sat, 27 Jul 2019 12:12:25 +1000</pubDate>
      
      <guid>https://zintrulcre.vip/posts/leetcode/dfs/</guid>
      <description>LeetCode DFS 题目 78 子集 典型的回溯，找出所有可能情况。 class Solution { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; subsets(vector&amp;lt;int&amp;gt; &amp;amp;nums) { res = vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;(1, vector&amp;lt;int&amp;gt;()); vector&amp;lt;int&amp;gt; curr; DFS(nums, 0, curr); return res; } void DFS(vector&amp;lt;int&amp;gt; &amp;amp;nums, int idx, vector&amp;lt;int&amp;gt; &amp;amp;curr) { for (int i = idx; i &amp;lt; nums.size(); ++i) { curr.push_back(nums[i]); res.push_back(curr); DFS(nums, i + 1, curr); curr.pop_back();</description>
    </item>
    
    <item>
      <title>LeetCode 并发</title>
      <link>https://zintrulcre.vip/posts/leetcode/concurrency/</link>
      <pubDate>Mon, 22 Jul 2019 10:10:25 +1000</pubDate>
      
      <guid>https://zintrulcre.vip/posts/leetcode/concurrency/</guid>
      <description>LeetCode 并发 题目 1114 按序打印 C++ mutex class Foo { mutex lock1, lock2; public: Foo() { lock1.lock(); lock2.lock(); } void first(function&amp;lt;void()&amp;gt; printFirst) { printFirst(); lock1.unlock(); } void second(function&amp;lt;void()&amp;gt; printSecond) { lock1.lock(); printSecond(); lock1.unlock(); lock2.unlock(); } void third(function&amp;lt;void()&amp;gt; printThird) { lock2.lock(); printThird(); lock2.unlock(); } }; C++ condition_variable class Foo { int i; mutex mut; condition_variable con_var1, con_var2; public: Foo() : i(1) { } void first(function&amp;lt;void()&amp;gt; printFirst)</description>
    </item>
    
    <item>
      <title>LeetCode 树（2）</title>
      <link>https://zintrulcre.vip/posts/leetcode/tree-2/</link>
      <pubDate>Thu, 18 Jul 2019 19:12:25 +1000</pubDate>
      
      <guid>https://zintrulcre.vip/posts/leetcode/tree-2/</guid>
      <description>LeetCode 树（2） 题目 3. 二叉搜索树 95 不同的二叉搜索树 II 生成由 1 &amp;hellip; n 为节点所组成的二叉搜索树。 为了构造以 i 为根节点的二叉搜索树，我们需要先构造以 1 &amp;hellip; i</description>
    </item>
    
    <item>
      <title>LeetCode 树（1）</title>
      <link>https://zintrulcre.vip/posts/leetcode/tree-1/</link>
      <pubDate>Sat, 13 Jul 2019 19:12:25 +1000</pubDate>
      
      <guid>https://zintrulcre.vip/posts/leetcode/tree-1/</guid>
      <description>LeetCode 树（1） 题目 1. 树的遍历 144 二叉树的前序遍历 前序遍历一个二叉树。 前序遍历是按照根节点，左子节点，右子节点的顺序来遍历一个二叉树，有递归和迭代两</description>
    </item>
    
  </channel>
</rss>