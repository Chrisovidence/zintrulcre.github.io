<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ZinBlog</title>
    <link>http://zintrulcre.vip/</link>
    <description>Recent content on ZinBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Sun, 17 Mar 2019 11:48:06 +1100</lastBuildDate>
    
	<atom:link href="http://zintrulcre.vip/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Notebooks</title>
      <link>http://zintrulcre.vip/notebooks/</link>
      <pubDate>Sun, 17 Mar 2019 11:48:06 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/notebooks/</guid>
      <description> Deep Learning
 Command
  </description>
    </item>
    
    <item>
      <title>LeetCode 208 实现 Trie (前缀树)</title>
      <link>http://zintrulcre.vip/posts/leetcode/208/</link>
      <pubDate>Fri, 15 Mar 2019 10:56:12 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/posts/leetcode/208/</guid>
      <description>LeetCode 208 实现 Trie (前缀树) 实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。 示例: Trie trie = new Trie(); trie.insert(&amp;#34;apple&amp;#34;); trie.search(&amp;#34;apple&amp;#34;); // 返回 true trie.search(&amp;#34;app&amp;#34;); // 返回 false trie.startsWith(&amp;#34;app&amp;#34;); // 返回 true trie.insert(&amp;#34;app&amp;#34;); trie.search(&amp;#34;app&amp;#34;); // 返回 true 说明: 你可以假</description>
    </item>
    
    <item>
      <title>LeetCode 98 验证二叉搜索树</title>
      <link>http://zintrulcre.vip/posts/leetcode/98/</link>
      <pubDate>Tue, 12 Feb 2019 21:44:35 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/posts/leetcode/98/</guid>
      <description>LeetCode 98 验证二叉搜索树 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点</description>
    </item>
    
    <item>
      <title>LeetCode 560 和为K的子数组</title>
      <link>http://zintrulcre.vip/posts/leetcode/560/</link>
      <pubDate>Wed, 06 Feb 2019 22:11:18 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/posts/leetcode/560/</guid>
      <description>LeetCode 560 和为K的子数组 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例 1: 输入:nums = [1,1,1], k = 2 输出: 2 , [1,1] 与 [1,1]</description>
    </item>
    
    <item>
      <title>Projects</title>
      <link>http://zintrulcre.vip/projects/</link>
      <pubDate>Mon, 04 Feb 2019 23:26:26 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/projects/</guid>
      <description>Refactoring&amp;hellip;</description>
    </item>
    
    <item>
      <title>About</title>
      <link>http://zintrulcre.vip/about/</link>
      <pubDate>Sat, 26 Jan 2019 12:21:35 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/about/</guid>
      <description>Refactoring&amp;hellip;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;智能指针（3）：shared_ptr</title>
      <link>http://zintrulcre.vip/posts/c&#43;&#43;-smart-pointer/c&#43;&#43;-smart-pointer-3/</link>
      <pubDate>Fri, 25 Jan 2019 17:47:38 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/posts/c&#43;&#43;-smart-pointer/c&#43;&#43;-smart-pointer-3/</guid>
      <description>分析 UniquePointer对象只能绑定单个指针，要实现指针的自动管理和销毁需要引入计数器 private: int *counter; T *pointer; D *deleter; 计数器的主要作用是标识当前指针被几</description>
    </item>
    
    <item>
      <title>C&#43;&#43;智能指针（2）：unique_ptr</title>
      <link>http://zintrulcre.vip/posts/c&#43;&#43;-smart-pointer/c&#43;&#43;-smart-pointer-2/</link>
      <pubDate>Sat, 19 Jan 2019 01:02:02 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/posts/c&#43;&#43;-smart-pointer/c&#43;&#43;-smart-pointer-2/</guid>
      <description>分析 在使用auto_ptr的时候会发生所有权转移和内存泄漏的问题，所以我们可以对AutoPointer类稍加修改，修复这两个问题。 所有权转</description>
    </item>
    
    <item>
      <title>使用Scrapy爬取LeetCode（3）：登录</title>
      <link>http://zintrulcre.vip/posts/use-scrapy-to-crawl-leetcode/use-scrapy-to-crawl-leetcode-3/</link>
      <pubDate>Fri, 11 Jan 2019 13:15:17 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/posts/use-scrapy-to-crawl-leetcode/use-scrapy-to-crawl-leetcode-3/</guid>
      <description>本项目ZintrulCre/LeetCode_Crawler已完成，并正在维护中，欢迎在GitHub上star和fork。 Cookie和Se</description>
    </item>
    
    <item>
      <title>C&#43;&#43;智能指针（1.5）：move语义</title>
      <link>http://zintrulcre.vip/posts/c&#43;&#43;-smart-pointer/c&#43;&#43;-smart-pointer-1.5/</link>
      <pubDate>Wed, 02 Jan 2019 09:55:05 +1100</pubDate>
      
      <guid>http://zintrulcre.vip/posts/c&#43;&#43;-smart-pointer/c&#43;&#43;-smart-pointer-1.5/</guid>
      <description>move语义 定义 右值引用（Rvalue Referene）是 C++ 11中引入的新特性，它实现了转移语义（Move Sementics）和精确传递（P</description>
    </item>
    
  </channel>
</rss>